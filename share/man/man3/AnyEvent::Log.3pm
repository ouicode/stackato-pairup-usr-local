.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent::Log 3"
.TH AnyEvent::Log 3 "2012-04-08" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::Log \- simple logging "framework"
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Simple uses:
.PP
.Vb 1
\&   use AnyEvent;
\&
\&   AE::log fatal => "No config found, cannot continue!"; # never returns
\&   AE::log alert => "The battery died!";
\&   AE::log crit  => "The battery temperature is too hot!";
\&   AE::log error => "Division by zero attempted.";
\&   AE::log warn  => "Couldn\*(Aqt delete the file.";
\&   AE::log note  => "Wanted to create config, but config already exists.";
\&   AE::log info  => "File soandso successfully deleted.";
\&   AE::log debug => "the function returned 3";
\&   AE::log trace => "going to call function abc";
.Ve
.PP
Log level overview:
.PP
.Vb 10
\&   LVL NAME      SYSLOG   PERL  NOTE
\&    1  fatal     emerg    exit  system unusable, aborts program!
\&    2  alert                    failure in primary system
\&    3  critical  crit           failure in backup system
\&    4  error     err      die   non\-urgent program errors, a bug
\&    5  warn      warning        possible problem, not necessarily error
\&    6  note      notice         unusual conditions
\&    7  info                     normal messages, no action required
\&    8  debug                    debugging messages for development
\&    9  trace                    copious tracing output
.Ve
.PP
\&\*(L"Complex\*(R" uses (for speed sensitive code, e.g. trace/debug messages):
.PP
.Vb 1
\&   use AnyEvent::Log;
\&
\&   my $tracer = AnyEvent::Log::logger trace => \e$my $trace;
\&
\&   $tracer\->("i am here") if $trace;
\&   $tracer\->(sub { "lots of data: " . Dumper $self }) if $trace;
.Ve
.PP
Configuration (also look at the \s-1EXAMPLES\s0 section):
.PP
.Vb 2
\&   # set logging for the current package to errors and higher only
\&   AnyEvent::Log::ctx\->level ("error");
\&
\&   # set logging level to suppress anything below "notice"
\&   $AnyEvent::Log::FILTER\->level ("notice");
\&
\&   # send all critical and higher priority messages to syslog,
\&   # regardless of (most) other settings
\&   $AnyEvent::Log::COLLECT\->attach (new AnyEvent::Log::Ctx
\&      level         => "critical",
\&      log_to_syslog => "user",
\&   );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements a relatively simple \*(L"logging framework\*(R". It doesn't
attempt to be \*(L"the\*(R" logging solution or even \*(L"a\*(R" logging solution for
AnyEvent \- AnyEvent simply creates logging messages internally, and this
module more or less exposes the mechanism, with some extra spiff to allow
using it from other modules as well.
.PP
Remember that the default verbosity level is \f(CW4\fR (\f(CW\*(C`error\*(C'\fR), so only
errors and more important messages will be logged, unless you set
\&\f(CW\*(C`PERL_ANYEVENT_VERBOSE\*(C'\fR to a higher number before starting your program
(\f(CW\*(C`AE_VERBOSE=5\*(C'\fR is recommended during development), or change the logging
level at runtime with something like:
.PP
.Vb 2
\&   use AnyEvent::Log;
\&   $AnyEvent::Log::FILTER\->level ("info");
.Ve
.PP
The design goal behind this module was to keep it simple (and small),
but make it powerful enough to be potentially useful for any module, and
extensive enough for the most common tasks, such as logging to multiple
targets, or being able to log into a database.
.PP
The module is also usable before AnyEvent itself is initialised, in which
case some of the functionality might be reduced.
.PP
The amount of documentation might indicate otherwise, but the runtime part
of the module is still just below 300 lines of code.
.SH "LOGGING LEVELS"
.IX Header "LOGGING LEVELS"
Logging levels in this module range from \f(CW1\fR (highest priority) to \f(CW9\fR
(lowest priority). Note that the lowest numerical value is the highest
priority, so when this document says \*(L"higher priority\*(R" it means \*(L"lower
numerical value\*(R".
.PP
Instead of specifying levels by name you can also specify them by aliases:
.PP
.Vb 10
\&   LVL NAME      SYSLOG   PERL  NOTE
\&    1  fatal     emerg    exit  system unusable, aborts program!
\&    2  alert                    failure in primary system
\&    3  critical  crit           failure in backup system
\&    4  error     err      die   non\-urgent program errors, a bug
\&    5  warn      warning        possible problem, not necessarily error
\&    6  note      notice         unusual conditions
\&    7  info                     normal messages, no action required
\&    8  debug                    debugging messages for development
\&    9  trace                    copious tracing output
.Ve
.PP
As you can see, some logging levels have multiple aliases \- the first one
is the \*(L"official\*(R" name, the second one the \*(L"syslog\*(R" name (if it differs)
and the third one the \*(L"perl\*(R" name, suggesting (only!) that you log \f(CW\*(C`die\*(C'\fR
messages at \f(CW\*(C`error\*(C'\fR priority. The \s-1NOTE\s0 column tries to provide some
rationale on how to chose a logging level.
.PP
As a rough guideline, levels 1..3 are primarily meant for users of the
program (admins, staff), and are the only ones logged to \s-1STDERR\s0 by
default. Levels 4..6 are meant for users and developers alike, while
levels 7..9 are usually meant for developers.
.PP
You can normally only log a message once at highest priority level (\f(CW1\fR,
\&\f(CW\*(C`fatal\*(C'\fR), because logging a fatal message will also quit the program \- so
use it sparingly :)
.PP
For example, a program that finds an unknown switch on the commandline
might well use a fatal logging level to tell users about it \- the \*(L"system\*(R"
in this case would be the program, or module.
.PP
Some methods also offer some extra levels, such as \f(CW0\fR, \f(CW\*(C`off\*(C'\fR, \f(CW\*(C`none\*(C'\fR
or \f(CW\*(C`all\*(C'\fR \- these are only valid for the methods that documented them.
.SH "LOGGING FUNCTIONS"
.IX Header "LOGGING FUNCTIONS"
The following functions allow you to log messages. They always use the
caller's package as a \*(L"logging context\*(R". Also, the main logging function,
\&\f(CW\*(C`log\*(C'\fR, is aliased to \f(CW\*(C`AnyEvent::log\*(C'\fR and \f(CW\*(C`AE::log\*(C'\fR when the \f(CW\*(C`AnyEvent\*(C'\fR
module is loaded.
.ie n .IP "AnyEvent::Log::log $level, $msg[, @args]" 4
.el .IP "AnyEvent::Log::log \f(CW$level\fR, \f(CW$msg\fR[, \f(CW@args\fR]" 4
.IX Item "AnyEvent::Log::log $level, $msg[, @args]"
Requests logging of the given \f(CW$msg\fR with the given log level, and
returns true if the message was logged \fIsomewhere\fR.
.Sp
For loglevel \f(CW\*(C`fatal\*(C'\fR, the program will abort.
.Sp
If only a \f(CW$msg\fR is given, it is logged as-is. With extra \f(CW@args\fR, the
\&\f(CW$msg\fR is interpreted as an sprintf format string.
.Sp
The \f(CW$msg\fR should not end with \f(CW\*(C`\en\*(C'\fR, but may if that is convenient for
you. Also, multiline messages are handled properly.
.Sp
Last not least, \f(CW$msg\fR might be a code reference, in which case it is
supposed to return the message. It will be called only then the message
actually gets logged, which is useful if it is costly to create the
message in the first place.
.Sp
This function takes care of saving and restoring \f(CW$!\fR and \f(CW$@\fR, so you
don't have to.
.Sp
Whether the given message will be logged depends on the maximum log level
and the caller's package. The return value can be used to ensure that
messages or not \*(L"lost\*(R" \- for example, when AnyEvent::Debug detects a
runtime error it tries to log it at \f(CW\*(C`die\*(C'\fR level, but if that message is
lost it simply uses warn.
.Sp
Note that you can (and should) call this function as \f(CW\*(C`AnyEvent::log\*(C'\fR or
\&\f(CW\*(C`AE::log\*(C'\fR, without \f(CW\*(C`use\*(C'\fR\-ing this module if possible (i.e. you don't
need any additional functionality), as those functions will load the
logging module on demand only. They are also much shorter to write.
.Sp
Also, if you optionally generate a lot of debug messages (such as when
tracing some code), you should look into using a logger callback and a
boolean enabler (see \f(CW\*(C`logger\*(C'\fR, below).
.Sp
Example: log something at error level.
.Sp
.Vb 1
\&   AE::log error => "something";
.Ve
.Sp
Example: use printf-formatting.
.Sp
.Vb 1
\&   AE::log info => "%5d %\-10.10s %s", $index, $category, $msg;
.Ve
.Sp
Example: only generate a costly dump when the message is actually being logged.
.Sp
.Vb 1
\&   AE::log debug => sub { require Data::Dump; Data::Dump::dump \e%cache };
.Ve
.ie n .IP "$logger = AnyEvent::Log::logger $level[, \e$enabled]" 4
.el .IP "\f(CW$logger\fR = AnyEvent::Log::logger \f(CW$level\fR[, \e$enabled]" 4
.IX Item "$logger = AnyEvent::Log::logger $level[, $enabled]"
Creates a code reference that, when called, acts as if the
\&\f(CW\*(C`AnyEvent::Log::log\*(C'\fR function was called at this point with the given
level. \f(CW$logger\fR is passed a \f(CW$msg\fR and optional \f(CW@args\fR, just as with
the \f(CW\*(C`AnyEvent::Log::log\*(C'\fR function:
.Sp
.Vb 1
\&   my $debug_log = AnyEvent::Log::logger "debug";
\&
\&   $debug_log\->("debug here");
\&   $debug_log\->("%06d emails processed", 12345);
\&   $debug_log\->(sub { $obj\->as_string });
.Ve
.Sp
The idea behind this function is to decide whether to log before actually
logging \- when the \f(CW\*(C`logger\*(C'\fR function is called once, but the returned
logger callback often, then this can be a tremendous speed win.
.Sp
Despite this speed advantage, changes in logging configuration will
still be reflected by the logger callback, even if configuration changes
\&\fIafter\fR it was created.
.Sp
To further speed up logging, you can bind a scalar variable to the logger,
which contains true if the logger should be called or not \- if it is
false, calling the logger can be safely skipped. This variable will be
updated as long as \f(CW$logger\fR is alive.
.Sp
Full example:
.Sp
.Vb 2
\&   # near the init section
\&   use AnyEvent::Log;
\&
\&   my $debug_log = AnyEvent:Log::logger debug => \emy $debug;
\&
\&   # and later in your program
\&   $debug_log\->("yo, stuff here") if $debug;
\&
\&   $debug and $debug_log\->("123");
.Ve
.ie n .IP "AnyEvent::Log::exact_time $on" 4
.el .IP "AnyEvent::Log::exact_time \f(CW$on\fR" 4
.IX Item "AnyEvent::Log::exact_time $on"
By default, \f(CW\*(C`AnyEvent::Log\*(C'\fR will use \f(CW\*(C`AE::now\*(C'\fR, i.e. the cached
eventloop time, for the log timestamps. After calling this function with a
true value it will instead resort to \f(CW\*(C`AE::time\*(C'\fR, i.e. fetch the current
time on each log message. This only makes a difference for event loops
that actually cache the time (such as \s-1EV\s0 or AnyEvent::Loop).
.Sp
This setting can be changed at any time by calling this function.
.Sp
Since \f(CW\*(C`AnyEvent::Log\*(C'\fR has to work even before the AnyEvent has been
initialised, this switch will also decide whether to use \f(CW\*(C`CORE::time\*(C'\fR or
\&\f(CW\*(C`Time::HiRes::time\*(C'\fR when logging a message before AnyEvent becomes
available.
.SH "LOGGING CONTEXTS"
.IX Header "LOGGING CONTEXTS"
This module associates every log message with a so-called \fIlogging
context\fR, based on the package of the caller. Every perl package has its
own logging context.
.PP
A logging context has three major responsibilities: filtering, logging and
propagating the message.
.PP
For the first purpose, filtering, each context has a set of logging
levels, called the log level mask. Messages not in the set will be ignored
by this context (masked).
.PP
For logging, the context stores a formatting callback (which takes the
timestamp, context, level and string message and formats it in the way
it should be logged) and a logging callback (which is responsible for
actually logging the formatted message and telling \f(CW\*(C`AnyEvent::Log\*(C'\fR
whether it has consumed the message, or whether it should be propagated).
.PP
For propagation, a context can have any number of attached \fIslave
contexts\fR. Any message that is neither masked by the logging mask nor
masked by the logging callback returning true will be passed to all slave
contexts.
.PP
Each call to a logging function will log the message at most once per
context, so it does not matter (much) if there are cycles or if the
message can arrive at the same context via multiple paths.
.SS "\s-1DEFAULTS\s0"
.IX Subsection "DEFAULTS"
By default, all logging contexts have an full set of log levels (\*(L"all\*(R"), a
disabled logging callback and the default formatting callback.
.PP
Package contexts have the package name as logging title by default.
.PP
They have exactly one slave \- the context of the \*(L"parent\*(R" package. The
parent package is simply defined to be the package name without the last
component, i.e. \f(CW\*(C`AnyEvent::Debug::Wrapped\*(C'\fR becomes \f(CW\*(C`AnyEvent::Debug\*(C'\fR,
and \f(CW\*(C`AnyEvent\*(C'\fR becomes ... \f(CW$AnyEvent::Log::COLLECT\fR which is the
exception of the rule \- just like the \*(L"parent\*(R" of any single-component
package name in Perl is \f(CW\*(C`main\*(C'\fR, the default slave of any top-level
package context is \f(CW$AnyEvent::Log::COLLECT\fR.
.PP
Since perl packages form only an approximate hierarchy, this slave
context can of course be removed.
.PP
All other (anonymous) contexts have no slaves and an empty title by
default.
.PP
When the module is loaded it creates the \f(CW$AnyEvent::Log::LOG\fR logging
context that simply logs everything via \f(CW\*(C`warn\*(C'\fR, without propagating
anything anywhere by default.  The purpose of this context is to provide
a convenient place to override the global logging target or to attach
additional log targets. It's not meant for filtering.
.PP
It then creates the \f(CW$AnyEvent::Log::FILTER\fR context whose
purpose is to suppress all messages with priority higher
than \f(CW$ENV{PERL_ANYEVENT_VERBOSE}\fR. It then attached the
\&\f(CW$AnyEvent::Log::LOG\fR context to it. The purpose of the filter context
is to simply provide filtering according to some global log level.
.PP
Finally it creates the top-level package context \f(CW$AnyEvent::Log::COLLECT\fR
and attaches the \f(CW$AnyEvent::Log::FILTER\fR context to it, but otherwise
leaves it at default config. Its purpose is simply to collect all log
messages system-wide.
.PP
The hierarchy is then:
.PP
.Vb 1
\&   any package, eventually \-> $COLLECT \-> $FILTER \-> $LOG
.Ve
.PP
The effect of all this is that log messages, by default, wander up to the
\&\f(CW$AnyEvent::Log::COLLECT\fR context where all messages normally end up,
from there to \f(CW$AnyEvent::Log::FILTER\fR where log messages with lower
priority then \f(CW$ENV{PERL_ANYEVENT_VERBOSE}\fR will be filtered out and then
to the \f(CW$AnyEvent::Log::LOG\fR context to be passed to \f(CW\*(C`warn\*(C'\fR.
.PP
This makes it easy to set a global logging level (by modifying \f(CW$FILTER\fR),
but still allow other contexts to send, for example, their debug and trace
messages to the \f(CW$LOG\fR target despite the global logging level, or to attach
additional log targets that log messages, regardless of the global logging
level.
.PP
It also makes it easy to modify the default warn-logger ($LOG) to
something that logs to a file, or to attach additional logging targets
(such as loggign to a file) by attaching it to \f(CW$FILTER\fR.
.SS "\s-1CREATING/FINDING/DESTROYING\s0 \s-1CONTEXTS\s0"
.IX Subsection "CREATING/FINDING/DESTROYING CONTEXTS"
.ie n .IP "$ctx = AnyEvent::Log::ctx [$pkg]" 4
.el .IP "\f(CW$ctx\fR = AnyEvent::Log::ctx [$pkg]" 4
.IX Item "$ctx = AnyEvent::Log::ctx [$pkg]"
This function creates or returns a logging context (which is an object).
.Sp
If a package name is given, then the context for that packlage is
returned. If it is called without any arguments, then the context for the
callers package is returned (i.e. the same context as a \f(CW\*(C`AE::log\*(C'\fR call
would use).
.Sp
If \f(CW\*(C`undef\*(C'\fR is given, then it creates a new anonymous context that is not
tied to any package and is destroyed when no longer referenced.
.IP "AnyEvent::Log::reset" 4
.IX Item "AnyEvent::Log::reset"
Resets all package contexts and recreates the default hierarchy if
necessary, i.e. resets the logging subsystem to defaults, as much as
possible. This process keeps references to contexts held by other parts of
the program intact.
.Sp
This can be used to implement config-file (re\-)loading: before loading a
configuration, reset all contexts.
.ie n .IP "$ctx = new AnyEvent::Log::Ctx methodname => param..." 4
.el .IP "\f(CW$ctx\fR = new AnyEvent::Log::Ctx methodname => param..." 4
.IX Item "$ctx = new AnyEvent::Log::Ctx methodname => param..."
This is a convenience constructor that makes it simpler to construct
anonymous logging contexts.
.Sp
Each key-value pair results in an invocation of the method of the same
name as the key with the value as parameter, unless the value is an
arrayref, in which case it calls the method with the contents of the
array. The methods are called in the same order as specified.
.Sp
Example: create a new logging context and set both the default logging
level, some slave contexts and a logging callback.
.Sp
.Vb 6
\&   $ctx = new AnyEvent::Log::Ctx
\&      title   => "dubious messages",
\&      level   => "error",
\&      log_cb  => sub { print STDOUT shift; 0 },
\&      slaves  => [$ctx1, $ctx, $ctx2],
\&   ;
.Ve
.SS "\s-1CONFIGURING\s0 A \s-1LOG\s0 \s-1CONTEXT\s0"
.IX Subsection "CONFIGURING A LOG CONTEXT"
The following methods can be used to configure the logging context.
.ie n .IP "$ctx\->title ([$new_title])" 4
.el .IP "\f(CW$ctx\fR\->title ([$new_title])" 4
.IX Item "$ctx->title ([$new_title])"
Returns the title of the logging context \- this is the package name, for
package contexts, and a user defined string for all others.
.Sp
If \f(CW$new_title\fR is given, then it replaces the package name or title.
.PP
\fI\s-1LOGGING\s0 \s-1LEVELS\s0\fR
.IX Subsection "LOGGING LEVELS"
.PP
The following methods deal with the logging level set associated with the
log context.
.PP
The most common method to use is probably \f(CW\*(C`$ctx\->level ($level)\*(C'\fR,
which configures the specified and any higher priority levels.
.PP
All functions which accept a list of levels also accept the special string
\&\f(CW\*(C`all\*(C'\fR which expands to all logging levels.
.ie n .IP "$ctx\->levels ($level[, $level...)" 4
.el .IP "\f(CW$ctx\fR\->levels ($level[, \f(CW$level\fR...)" 4
.IX Item "$ctx->levels ($level[, $level...)"
Enables logging for the given levels and disables it for all others.
.ie n .IP "$ctx\->level ($level)" 4
.el .IP "\f(CW$ctx\fR\->level ($level)" 4
.IX Item "$ctx->level ($level)"
Enables logging for the given level and all lower level (higher priority)
ones. In addition to normal logging levels, specifying a level of \f(CW0\fR or
\&\f(CW\*(C`off\*(C'\fR disables all logging for this level.
.Sp
Example: log warnings, errors and higher priority messages.
.Sp
.Vb 2
\&   $ctx\->level ("warn");
\&   $ctx\->level (5); # same thing, just numeric
.Ve
.ie n .IP "$ctx\->enable ($level[, $level...])" 4
.el .IP "\f(CW$ctx\fR\->enable ($level[, \f(CW$level\fR...])" 4
.IX Item "$ctx->enable ($level[, $level...])"
Enables logging for the given levels, leaving all others unchanged.
.ie n .IP "$ctx\->disable ($level[, $level...])" 4
.el .IP "\f(CW$ctx\fR\->disable ($level[, \f(CW$level\fR...])" 4
.IX Item "$ctx->disable ($level[, $level...])"
Disables logging for the given levels, leaving all others unchanged.
.ie n .IP "$ctx\->cap ($level)" 4
.el .IP "\f(CW$ctx\fR\->cap ($level)" 4
.IX Item "$ctx->cap ($level)"
Caps the maximum priority to the given level, for all messages logged
to, or passing through, this context. That is, while this doesn't affect
whether a message is logged or passed on, the maximum priority of messages
will be limited to the specified level \- messages with a higher priority
will be set to the specified priority.
.Sp
Another way to view this is that \f(CW\*(C`\->level\*(C'\fR filters out messages with
a too low priority, while \f(CW\*(C`\->cap\*(C'\fR modifies messages with a too high
priority.
.Sp
This is useful when different log targets have different interpretations
of priority. For example, for a specific command line program, a wrong
command line switch might well result in a \f(CW\*(C`fatal\*(C'\fR log message, while the
same message, logged to syslog, is likely \fInot\fR fatal to the system or
syslog facility as a whole, but more likely a mere \f(CW\*(C`error\*(C'\fR.
.Sp
This can be modeled by having a stderr logger that logs messages \*(L"as-is\*(R"
and a syslog logger that logs messages with a level cap of, say, \f(CW\*(C`error\*(C'\fR,
or, for truly system-critical components, actually \f(CW\*(C`critical\*(C'\fR.
.PP
\fI\s-1SLAVE\s0 \s-1CONTEXTS\s0\fR
.IX Subsection "SLAVE CONTEXTS"
.PP
The following methods attach and detach another logging context to a
logging context.
.PP
Log messages are propagated to all slave contexts, unless the logging
callback consumes the message.
.ie n .IP "$ctx\->attach ($ctx2[, $ctx3...])" 4
.el .IP "\f(CW$ctx\fR\->attach ($ctx2[, \f(CW$ctx3\fR...])" 4
.IX Item "$ctx->attach ($ctx2[, $ctx3...])"
Attaches the given contexts as slaves to this context. It is not an error
to add a context twice (the second add will be ignored).
.Sp
A context can be specified either as package name or as a context object.
.ie n .IP "$ctx\->detach ($ctx2[, $ctx3...])" 4
.el .IP "\f(CW$ctx\fR\->detach ($ctx2[, \f(CW$ctx3\fR...])" 4
.IX Item "$ctx->detach ($ctx2[, $ctx3...])"
Removes the given slaves from this context \- it's not an error to attempt
to remove a context that hasn't been added.
.Sp
A context can be specified either as package name or as a context object.
.ie n .IP "$ctx\->slaves ($ctx2[, $ctx3...])" 4
.el .IP "\f(CW$ctx\fR\->slaves ($ctx2[, \f(CW$ctx3\fR...])" 4
.IX Item "$ctx->slaves ($ctx2[, $ctx3...])"
Replaces all slaves attached to this context by the ones given.
.PP
\fI\s-1LOG\s0 \s-1TARGETS\s0\fR
.IX Subsection "LOG TARGETS"
.PP
The following methods configure how the logging context actually does
the logging (which consists of formatting the message and printing it or
whatever it wants to do with it).
.ie n .IP "$ctx\->log_cb ($cb\->($str))" 4
.el .IP "\f(CW$ctx\fR\->log_cb ($cb\->($str))" 4
.IX Item "$ctx->log_cb ($cb->($str))"
Replaces the logging callback on the context (\f(CW\*(C`undef\*(C'\fR disables the
logging callback).
.Sp
The logging callback is responsible for handling formatted log messages
(see \f(CW\*(C`fmt_cb\*(C'\fR below) \- normally simple text strings that end with a
newline (and are possibly multiline themselves).
.Sp
It also has to return true iff it has consumed the log message, and false
if it hasn't. Consuming a message means that it will not be sent to any
slave context. When in doubt, return \f(CW0\fR from your logging callback.
.Sp
Example: a very simple logging callback, simply dump the message to \s-1STDOUT\s0
and do not consume it.
.Sp
.Vb 1
\&   $ctx\->log_cb (sub { print STDERR shift; 0 });
.Ve
.Sp
You can filter messages by having a log callback that simply returns \f(CW1\fR
and does not do anything with the message, but this counts as \*(L"message
being logged\*(R" and might not be very efficient.
.Sp
Example: propagate all messages except for log levels \*(L"debug\*(R" and
\&\*(L"trace\*(R". The messages will still be generated, though, which can slow down
your program.
.Sp
.Vb 2
\&   $ctx\->levels ("debug", "trace");
\&   $ctx\->log_cb (sub { 1 }); # do not log, but eat debug and trace messages
.Ve
.ie n .IP "$ctx\->fmt_cb ($fmt_cb\->($timestamp, $orig_ctx, $level, $message))" 4
.el .IP "\f(CW$ctx\fR\->fmt_cb ($fmt_cb\->($timestamp, \f(CW$orig_ctx\fR, \f(CW$level\fR, \f(CW$message\fR))" 4
.IX Item "$ctx->fmt_cb ($fmt_cb->($timestamp, $orig_ctx, $level, $message))"
Replaces the formatting callback on the context (\f(CW\*(C`undef\*(C'\fR restores the
default formatter).
.Sp
The callback is passed the (possibly fractional) timestamp, the original
logging context (object, not title), the (numeric) logging level and
the raw message string and needs to return a formatted log message. In
most cases this will be a string, but it could just as well be an array
reference that just stores the values.
.Sp
If, for some reason, you want to use \f(CW\*(C`caller\*(C'\fR to find out more about the
logger then you should walk up the call stack until you are no longer
inside the \f(CW\*(C`AnyEvent::Log\*(C'\fR package.
.Sp
Example: format just the raw message, with numeric log level in angle
brackets.
.Sp
.Vb 2
\&   $ctx\->fmt_cb (sub {
\&      my ($time, $ctx, $lvl, $msg) = @_;
\&
\&      "<$lvl>$msg\en"
\&   });
.Ve
.Sp
Example: return an array reference with just the log values, and use
\&\f(CW\*(C`PApp::SQL::sql_exec\*(C'\fR to store the message in a database.
.Sp
.Vb 3
\&   $ctx\->fmt_cb (sub { \e@_ });
\&   $ctx\->log_cb (sub {
\&      my ($msg) = @_;
\&
\&      sql_exec "insert into log (when, subsys, prio, msg) values (?, ?, ?, ?)",
\&               $msg\->[0] + 0,
\&               "$msg\->[1]",
\&               $msg\->[2] + 0,
\&               "$msg\->[3]";
\&
\&      0
\&   });
.Ve
.ie n .IP "$ctx\->log_to_warn" 4
.el .IP "\f(CW$ctx\fR\->log_to_warn" 4
.IX Item "$ctx->log_to_warn"
Sets the \f(CW\*(C`log_cb\*(C'\fR to simply use \f(CW\*(C`CORE::warn\*(C'\fR to report any messages
(usually this logs to \s-1STDERR\s0).
.ie n .IP "$ctx\->log_to_file ($path)" 4
.el .IP "\f(CW$ctx\fR\->log_to_file ($path)" 4
.IX Item "$ctx->log_to_file ($path)"
Sets the \f(CW\*(C`log_cb\*(C'\fR to log to a file (by appending), unbuffered. The
function might return before the log file has been opened or created.
.ie n .IP "$ctx\->log_to_path ($path)" 4
.el .IP "\f(CW$ctx\fR\->log_to_path ($path)" 4
.IX Item "$ctx->log_to_path ($path)"
Same as \f(CW\*(C`\->log_to_file\*(C'\fR, but opens the file for each message. This
is much slower, but allows you to change/move/rename/delete the file at
basically any time.
.Sp
Needless(?) to say, if you do not want to be bitten by some evil person
calling \f(CW\*(C`chdir\*(C'\fR, the path should be absolute. Doesn't help with
\&\f(CW\*(C`chroot\*(C'\fR, but hey...
.ie n .IP "$ctx\->log_to_syslog ([$facility])" 4
.el .IP "\f(CW$ctx\fR\->log_to_syslog ([$facility])" 4
.IX Item "$ctx->log_to_syslog ([$facility])"
Logs all messages via Sys::Syslog, mapping \f(CW\*(C`trace\*(C'\fR to \f(CW\*(C`debug\*(C'\fR and
all the others in the obvious way. If specified, then the \f(CW$facility\fR is
used as the facility (\f(CW\*(C`user\*(C'\fR, \f(CW\*(C`auth\*(C'\fR, \f(CW\*(C`local0\*(C'\fR and so on). The default
facility is \f(CW\*(C`user\*(C'\fR.
.Sp
Note that this function also sets a \f(CW\*(C`fmt_cb\*(C'\fR \- the logging part requires
an array reference with [$level, \f(CW$str\fR] as input.
.PP
\fI\s-1MESSAGE\s0 \s-1LOGGING\s0\fR
.IX Subsection "MESSAGE LOGGING"
.PP
These methods allow you to log messages directly to a context, without
going via your package context.
.ie n .IP "$ctx\->log ($level, $msg[, @params])" 4
.el .IP "\f(CW$ctx\fR\->log ($level, \f(CW$msg\fR[, \f(CW@params\fR])" 4
.IX Item "$ctx->log ($level, $msg[, @params])"
Same as \f(CW\*(C`AnyEvent::Log::log\*(C'\fR, but uses the given context as log context.
.Sp
Example: log a message in the context of another package.
.Sp
.Vb 1
\&   (AnyEvent::Log::ctx "Other::Package")\->log (warn => "heely bo");
.Ve
.ie n .IP "$logger = $ctx\->logger ($level[, \e$enabled])" 4
.el .IP "\f(CW$logger\fR = \f(CW$ctx\fR\->logger ($level[, \e$enabled])" 4
.IX Item "$logger = $ctx->logger ($level[, $enabled])"
Same as \f(CW\*(C`AnyEvent::Log::logger\*(C'\fR, but uses the given context as log
context.
.ie n .SH "CONFIGURATION VIA $ENV{PERL_ANYEVENT_LOG}"
.el .SH "CONFIGURATION VIA \f(CW$ENV\fP{PERL_ANYEVENT_LOG}"
.IX Header "CONFIGURATION VIA $ENV{PERL_ANYEVENT_LOG}"
Logging can also be configured by setting the environment variable
\&\f(CW\*(C`PERL_ANYEVENT_LOG\*(C'\fR (or \f(CW\*(C`AE_LOG\*(C'\fR).
.PP
The value consists of one or more logging context specifications separated
by \f(CW\*(C`:\*(C'\fR or whitespace. Each logging specification in turn starts with a
context name, followed by \f(CW\*(C`=\*(C'\fR, followed by zero or more comma-separated
configuration directives, here are some examples:
.PP
.Vb 2
\&   # set default logging level
\&   filter=warn
\&
\&   # log to file instead of to stderr
\&   log=file=/tmp/mylog
\&
\&   # log to file in addition to stderr
\&   log=+%file:%file=file=/tmp/mylog
\&
\&   # enable debug log messages, log warnings and above to syslog
\&   filter=debug:log=+%warnings:%warnings=warn,syslog=LOG_LOCAL0
\&
\&   # log trace messages (only) from AnyEvent::Debug to file
\&   AnyEvent::Debug=+%trace:%trace=only,trace,file=/tmp/tracelog
.Ve
.PP
A context name in the log specification can be any of the following:
.ie n .IP """collect"", ""filter"", ""log""" 4
.el .IP "\f(CWcollect\fR, \f(CWfilter\fR, \f(CWlog\fR" 4
.IX Item "collect, filter, log"
Correspond to the three predefined \f(CW$AnyEvent::Log::COLLECT\fR,
\&\f(CW\*(C`AnyEvent::Log::FILTER\*(C'\fR and \f(CW$AnyEvent::Log::LOG\fR contexts.
.ie n .IP "%name" 4
.el .IP "\f(CW%name\fR" 4
.IX Item "%name"
Context names starting with a \f(CW\*(C`%\*(C'\fR are anonymous contexts created when the
name is first mentioned. The difference to package contexts is that by
default they have no attached slaves.
.IP "a perl package name" 4
.IX Item "a perl package name"
Any other string references the logging context associated with the given
Perl \f(CW\*(C`package\*(C'\fR. In the unlikely case where you want to specify a package
context that matches on of the other context name forms, you can add a
\&\f(CW\*(C`::\*(C'\fR to the package name to force interpretation as a package.
.PP
The configuration specifications can be any number of the following:
.ie n .IP """stderr""" 4
.el .IP "\f(CWstderr\fR" 4
.IX Item "stderr"
Configures the context to use Perl's \f(CW\*(C`warn\*(C'\fR function (which typically
logs to \f(CW\*(C`STDERR\*(C'\fR). Works like \f(CW\*(C`log_to_warn\*(C'\fR.
.ie n .IP """file=""\fIpath\fR" 4
.el .IP "\f(CWfile=\fR\fIpath\fR" 4
.IX Item "file=path"
Configures the context to log to a file with the given path. Works like
\&\f(CW\*(C`log_to_file\*(C'\fR.
.ie n .IP """path=""\fIpath\fR" 4
.el .IP "\f(CWpath=\fR\fIpath\fR" 4
.IX Item "path=path"
Configures the context to log to a file with the given path. Works like
\&\f(CW\*(C`log_to_path\*(C'\fR.
.ie n .IP """syslog"" or ""syslog=""\fIexpr\fR" 4
.el .IP "\f(CWsyslog\fR or \f(CWsyslog=\fR\fIexpr\fR" 4
.IX Item "syslog or syslog=expr"
Configures the context to log to syslog. If \fIexpr\fR is given, then it is
evaluated in the Sys::Syslog package, so you could use:
.Sp
.Vb 1
\&   log=syslog=LOG_LOCAL0
.Ve
.ie n .IP """nolog""" 4
.el .IP "\f(CWnolog\fR" 4
.IX Item "nolog"
Configures the context to not log anything by itself, which is the
default. Same as \f(CW\*(C`$ctx\->log_cb (undef)\*(C'\fR.
.ie n .IP """cap=""\fIlevel\fR" 4
.el .IP "\f(CWcap=\fR\fIlevel\fR" 4
.IX Item "cap=level"
Caps logging messages entering this context at the given level, i.e.
reduces the priority of messages with higher priority than this level. The
default is \f(CW0\fR (or \f(CW\*(C`off\*(C'\fR), meaning the priority will not be touched.
.ie n .IP "0 or ""off""" 4
.el .IP "\f(CW0\fR or \f(CWoff\fR" 4
.IX Item "0 or off"
Sets the logging level of the context to \f(CW0\fR, i.e. all messages will be
filtered out.
.ie n .IP """all""" 4
.el .IP "\f(CWall\fR" 4
.IX Item "all"
Enables all logging levels, i.e. filtering will effectively be switched
off (the default).
.ie n .IP """only""" 4
.el .IP "\f(CWonly\fR" 4
.IX Item "only"
Disables all logging levels, and changes the interpretation of following
level specifications to enable the specified level only.
.Sp
Example: only enable debug messages for a context.
.Sp
.Vb 1
\&   context=only,debug
.Ve
.ie n .IP """except""" 4
.el .IP "\f(CWexcept\fR" 4
.IX Item "except"
Enables all logging levels, and changes the interpretation of following
level specifications to disable that level. Rarely used.
.Sp
Example: enable all logging levels except fatal and trace (this is rather
nonsensical).
.Sp
.Vb 1
\&   filter=exept,fatal,trace
.Ve
.ie n .IP """level""" 4
.el .IP "\f(CWlevel\fR" 4
.IX Item "level"
Enables all logging levels, and changes the interpretation of following
level specifications to be \*(L"that level or any higher priority
message\*(R". This is the default.
.Sp
Example: log anything at or above warn level.
.Sp
.Vb 1
\&   filter=warn
\&
\&   # or, more verbose
\&   filter=only,level,warn
.Ve
.ie n .IP "1..9 or a logging level name (""error"", ""debug"" etc.)" 4
.el .IP "\f(CW1\fR..\f(CW9\fR or a logging level name (\f(CWerror\fR, \f(CWdebug\fR etc.)" 4
.IX Item "1..9 or a logging level name (error, debug etc.)"
A numeric loglevel or the name of a loglevel will be interpreted according
to the most recent \f(CW\*(C`only\*(C'\fR, \f(CW\*(C`except\*(C'\fR or \f(CW\*(C`level\*(C'\fR directive. By default,
specifying a logging level enables that and any higher priority messages.
.ie n .IP """+""\fIcontext\fR" 4
.el .IP "\f(CW+\fR\fIcontext\fR" 4
.IX Item "+context"
Attaches the named context as slave to the context.
.ie n .IP """+""" 4
.el .IP "\f(CW+\fR" 4
.IX Item "+"
A lone \f(CW\*(C`+\*(C'\fR detaches all contexts, i.e. clears the slave list from the
context. Anonymous (\f(CW%name\fR) contexts have no attached slaves by default,
but package contexts have the parent context as slave by default.
.Sp
Example: log messages from My::Module to a file, do not send them to the
default log collector.
.Sp
.Vb 1
\&   My::Module=+,file=/tmp/mymodulelog
.Ve
.PP
Any character can be escaped by prefixing it with a \f(CW\*(C`\e\*(C'\fR (backslash), as
usual, so to log to a file containing a comma, colon, backslash and some
spaces in the filename, you would do this:
.PP
.Vb 1
\&   PERL_ANYEVENT_LOG=\*(Aqlog=file=/some\e \e:file\e with\e,\e \e\e\-escapes\*(Aq
.Ve
.PP
Since whitespace (which includes newlines) is allowed, it is fine to
specify multiple lines in \f(CW\*(C`PERL_ANYEVENT_LOG\*(C'\fR, e.g.:
.PP
.Vb 5
\&   PERL_ANYEVENT_LOG="
\&      filter=warn
\&      AnyEvent::Debug=+%trace
\&      %trace=only,trace,+log
\&   " myprog
.Ve
.PP
Also, in the unlikely case when you want to concatenate specifications,
use whitespace as separator, as \f(CW\*(C`::\*(C'\fR will be interpreted as part of a
module name, an empty spec with two separators:
.PP
.Vb 1
\&   PERL_ANYEVENT_LOG="$PERL_ANYEVENT_LOG MyMod=debug"
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
This section shows some common configurations, both as code, and as
\&\f(CW\*(C`PERL_ANYEVENT_LOG\*(C'\fR string.
.IP "Setting the global logging level." 4
.IX Item "Setting the global logging level."
Either put \f(CW\*(C`PERL_ANYEVENT_VERBOSE=\*(C'\fR<number> into your environment before
running your program, use \f(CW\*(C`PERL_ANYEVENT_LOG\*(C'\fR or modify the log level of
the root context at runtime:
.Sp
.Vb 1
\&   PERL_ANYEVENT_VERBOSE=5 ./myprog
\&
\&   PERL_ANYEVENT_LOG=log=warn
\&
\&   $AnyEvent::Log::FILTER\->level ("warn");
.Ve
.IP "Append all messages to a file instead of sending them to \s-1STDERR\s0." 4
.IX Item "Append all messages to a file instead of sending them to STDERR."
This is affected by the global logging level.
.Sp
.Vb 1
\&   $AnyEvent::Log::LOG\->log_to_file ($path);
\&
\&   PERL_ANYEVENT_LOG=log=file=/some/path
.Ve
.ie n .IP "Write all messages with priority ""error"" and higher to a file." 4
.el .IP "Write all messages with priority \f(CWerror\fR and higher to a file." 4
.IX Item "Write all messages with priority error and higher to a file."
This writes them only when the global logging level allows it, because
it is attached to the default context which is invoked \fIafter\fR global
filtering.
.Sp
.Vb 2
\&   $AnyEvent::Log::FILTER\->attach (
\&      new AnyEvent::Log::Ctx log_to_file => $path);
\&
\&   PERL_ANYEVENT_LOG=filter=+%filelogger:%filelogger=file=/some/path
.Ve
.Sp
This writes them regardless of the global logging level, because it is
attached to the toplevel context, which receives all messages \fIbefore\fR
the global filtering.
.Sp
.Vb 2
\&   $AnyEvent::Log::COLLECT\->attach (
\&      new AnyEvent::Log::Ctx log_to_file => $path);
\&
\&   PERL_ANYEVENT_LOG=%filelogger=file=/some/path:collect=+%filelogger
.Ve
.Sp
In both cases, messages are still written to \s-1STDERR\s0.
.ie n .IP "Additionally log all messages with ""warn"" and higher priority to ""syslog"", but cap at ""error""." 4
.el .IP "Additionally log all messages with \f(CWwarn\fR and higher priority to \f(CWsyslog\fR, but cap at \f(CWerror\fR." 4
.IX Item "Additionally log all messages with warn and higher priority to syslog, but cap at error."
This logs all messages to the default log target, but also logs messages
with priority \f(CW\*(C`warn\*(C'\fR or higher (and not filtered otherwise) to syslog
facility \f(CW\*(C`user\*(C'\fR. Messages with priority higher than \f(CW\*(C`error\*(C'\fR will be
logged with level \f(CW\*(C`error\*(C'\fR.
.Sp
.Vb 6
\&   $AnyEvent::Log::LOG\->attach (
\&      new AnyEvent::Log::Ctx
\&         level  => "warn",
\&         cap    => "error",
\&         syslog => "user",
\&   );
\&
\&   PERL_ANYEVENT_LOG=log=+%syslog:%syslog=warn,cap=error,syslog
.Ve
.IP "Write trace messages (only) from AnyEvent::Debug to the default logging target(s)." 4
.IX Item "Write trace messages (only) from AnyEvent::Debug to the default logging target(s)."
Attach the \f(CW$AnyEvent::Log::LOG\fR context to the \f(CW\*(C`AnyEvent::Debug\*(C'\fR
context \- this simply circumvents the global filtering for trace messages.
.Sp
.Vb 2
\&   my $debug = AnyEvent::Debug\->AnyEvent::Log::ctx;
\&   $debug\->attach ($AnyEvent::Log::LOG);
\&
\&   PERL_ANYEVENT_LOG=AnyEvent::Debug=+log
.Ve
.Sp
This of course works for any package, not just AnyEvent::Debug, but
assumes the log level for AnyEvent::Debug hasn't been changed from the
default.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>
\& http://anyevent.schmorp.de
.Ve
