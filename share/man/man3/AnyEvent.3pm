.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent 3"
.TH AnyEvent 3 "2012-05-12" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent \- the DBI of event loop programming
.PP
EV, Event, Glib, Tk, Perl, Event::Lib, Irssi, rxvt\-unicode, IO::Async, Qt,
FLTK and POE are various supported event loops/environments.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use AnyEvent;
\&
\&   # if you prefer function calls, look at the AE manpage for
\&   # an alternative API.
\&
\&   # file handle or descriptor readable
\&   my $w = AnyEvent\->io (fh => $fh, poll => "r", cb => sub { ...  });
\&
\&   # one\-shot or repeating timers
\&   my $w = AnyEvent\->timer (after => $seconds, cb => sub { ...  });
\&   my $w = AnyEvent\->timer (after => $seconds, interval => $seconds, cb => ...);
\&
\&   print AnyEvent\->now;  # prints current event loop time
\&   print AnyEvent\->time; # think Time::HiRes::time or simply CORE::time.
\&
\&   # POSIX signal
\&   my $w = AnyEvent\->signal (signal => "TERM", cb => sub { ... });
\&
\&   # child process exit
\&   my $w = AnyEvent\->child (pid => $pid, cb => sub {
\&      my ($pid, $status) = @_;
\&      ...
\&   });
\&
\&   # called when event loop idle (if applicable)
\&   my $w = AnyEvent\->idle (cb => sub { ... });
\&
\&   my $w = AnyEvent\->condvar; # stores whether a condition was flagged
\&   $w\->send; # wake up current and all future recv\*(Aqs
\&   $w\->recv; # enters "main loop" till $condvar gets \->send
\&   # use a condvar in callback mode:
\&   $w\->cb (sub { $_[0]\->recv });
.Ve
.SH "INTRODUCTION/TUTORIAL"
.IX Header "INTRODUCTION/TUTORIAL"
This manpage is mainly a reference manual. If you are interested
in a tutorial or some gentle introduction, have a look at the
AnyEvent::Intro manpage.
.SH "SUPPORT"
.IX Header "SUPPORT"
An \s-1FAQ\s0 document is available as AnyEvent::FAQ.
.PP
There also is a mailinglist for discussing all things AnyEvent, and an \s-1IRC\s0
channel, too.
.PP
See the AnyEvent project page at the \fBSchmorpforge Ta-Sa Software
Repository\fR, at <http://anyevent.schmorp.de>, for more info.
.SH "WHY YOU SHOULD USE THIS MODULE (OR NOT)"
.IX Header "WHY YOU SHOULD USE THIS MODULE (OR NOT)"
Glib, \s-1POE\s0, IO::Async, Event... \s-1CPAN\s0 offers event models by the dozen
nowadays. So what is different about AnyEvent?
.PP
Executive Summary: AnyEvent is \fIcompatible\fR, AnyEvent is \fIfree of
policy\fR and AnyEvent is \fIsmall and efficient\fR.
.PP
First and foremost, \fIAnyEvent is not an event model\fR itself, it only
interfaces to whatever event model the main program happens to use, in a
pragmatic way. For event models and certain classes of immortals alike,
the statement \*(L"there can only be one\*(R" is a bitter reality: In general,
only one event loop can be active at the same time in a process. AnyEvent
cannot change this, but it can hide the differences between those event
loops.
.PP
The goal of AnyEvent is to offer module authors the ability to do event
programming (waiting for I/O or timer events) without subscribing to a
religion, a way of living, and most importantly: without forcing your
module users into the same thing by forcing them to use the same event
model you use.
.PP
For modules like \s-1POE\s0 or IO::Async (which is a total misnomer as it is
actually doing all I/O \fIsynchronously\fR...), using them in your module is
like joining a cult: After you join, you are dependent on them and you
cannot use anything else, as they are simply incompatible to everything
that isn't them. What's worse, all the potential users of your
module are \fIalso\fR forced to use the same event loop you use.
.PP
AnyEvent is different: AnyEvent + \s-1POE\s0 works fine. AnyEvent + Glib works
fine. AnyEvent + Tk works fine etc. etc. but none of these work together
with the rest: \s-1POE\s0 + \s-1EV\s0? No go. Tk + Event? No go. Again: if your module
uses one of those, every user of your module has to use it, too. But if
your module uses AnyEvent, it works transparently with all event models it
supports (including stuff like IO::Async, as long as those use one of the
supported event loops. It is easy to add new event loops to AnyEvent, too,
so it is future-proof).
.PP
In addition to being free of having to use \fIthe one and only true event
model\fR, AnyEvent also is free of bloat and policy: with \s-1POE\s0 or similar
modules, you get an enormous amount of code and strict rules you have to
follow. AnyEvent, on the other hand, is lean and to the point, by only
offering the functionality that is necessary, in as thin as a wrapper as
technically possible.
.PP
Of course, AnyEvent comes with a big (and fully optional!) toolbox
of useful functionality, such as an asynchronous \s-1DNS\s0 resolver, 100%
non-blocking connects (even with \s-1TLS/SSL\s0, IPv6 and on broken platforms
such as Windows) and lots of real-world knowledge and workarounds for
platform bugs and differences.
.PP
Now, if you \fIdo want\fR lots of policy (this can arguably be somewhat
useful) and you want to force your users to use the one and only event
model, you should \fInot\fR use this module.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
AnyEvent provides a uniform interface to various event loops. This
allows module authors to use event loop functionality without forcing
module users to use a specific event loop implementation (since more
than one event loop cannot coexist peacefully).
.PP
The interface itself is vaguely similar, but not identical to the Event
module.
.PP
During the first call of any watcher-creation method, the module tries
to detect the currently loaded event loop by probing whether one of the
following modules is already loaded: \s-1EV\s0, AnyEvent::Loop,
Event, Glib, Tk, Event::Lib, Qt, \s-1POE\s0. The first one
found is used. If none are detected, the module tries to load the first
four modules in the order given; but note that if \s-1EV\s0 is not
available, the pure-perl AnyEvent::Loop should always work, so
the other two are not normally tried.
.PP
Because AnyEvent first checks for modules that are already loaded, loading
an event model explicitly before first using AnyEvent will likely make
that model the default. For example:
.PP
.Vb 2
\&   use Tk;
\&   use AnyEvent;
\&
\&   # .. AnyEvent will likely default to Tk
.Ve
.PP
The \fIlikely\fR means that, if any module loads another event model and
starts using it, all bets are off \- this case should be very rare though,
as very few modules hardcode event loops without announcing this very
loudly.
.PP
The pure-perl implementation of AnyEvent is called \f(CW\*(C`AnyEvent::Loop\*(C'\fR. Like
other event modules you can load it explicitly and enjoy the high
availability of that event loop :)
.SH "WATCHERS"
.IX Header "WATCHERS"
AnyEvent has the central concept of a \fIwatcher\fR, which is an object that
stores relevant data for each kind of event you are waiting for, such as
the callback to call, the file handle to watch, etc.
.PP
These watchers are normal Perl objects with normal Perl lifetime. After
creating a watcher it will immediately \*(L"watch\*(R" for events and invoke the
callback when the event occurs (of course, only when the event model
is in control).
.PP
Note that \fBcallbacks must not permanently change global variables\fR
potentially in use by the event loop (such as \f(CW$_\fR or \f(CW$[\fR) and that \fBcallbacks must not \f(CB\*(C`die\*(C'\fB\fR. The former is good programming practice in
Perl and the latter stems from the fact that exception handling differs
widely between event loops.
.PP
To disable a watcher you have to destroy it (e.g. by setting the
variable you store it in to \f(CW\*(C`undef\*(C'\fR or otherwise deleting all references
to it).
.PP
All watchers are created by calling a method on the \f(CW\*(C`AnyEvent\*(C'\fR class.
.PP
Many watchers either are used with \*(L"recursion\*(R" (repeating timers for
example), or need to refer to their watcher object in other ways.
.PP
One way to achieve that is this pattern:
.PP
.Vb 4
\&   my $w; $w = AnyEvent\->type (arg => value ..., cb => sub {
\&      # you can use $w here, for example to undef it
\&      undef $w;
\&   });
.Ve
.PP
Note that \f(CW\*(C`my $w; $w =\*(C'\fR combination. This is necessary because in Perl,
my variables are only visible after the statement in which they are
declared.
.SS "I/O \s-1WATCHERS\s0"
.IX Subsection "I/O WATCHERS"
.Vb 5
\&   $w = AnyEvent\->io (
\&      fh   => <filehandle_or_fileno>,
\&      poll => <"r" or "w">,
\&      cb   => <callback>,
\&   );
.Ve
.PP
You can create an I/O watcher by calling the \f(CW\*(C`AnyEvent\->io\*(C'\fR method
with the following mandatory key-value pairs as arguments:
.PP
\&\f(CW\*(C`fh\*(C'\fR is the Perl \fIfile handle\fR (or a naked file descriptor) to watch
for events (AnyEvent might or might not keep a reference to this file
handle). Note that only file handles pointing to things for which
non-blocking operation makes sense are allowed. This includes sockets,
most character devices, pipes, fifos and so on, but not for example files
or block devices.
.PP
\&\f(CW\*(C`poll\*(C'\fR must be a string that is either \f(CW\*(C`r\*(C'\fR or \f(CW\*(C`w\*(C'\fR, which creates a
watcher waiting for \*(L"r\*(R"eadable or \*(L"w\*(R"ritable events, respectively.
.PP
\&\f(CW\*(C`cb\*(C'\fR is the callback to invoke each time the file handle becomes ready.
.PP
Although the callback might get passed parameters, their value and
presence is undefined and you cannot rely on them. Portable AnyEvent
callbacks cannot use arguments passed to I/O watcher callbacks.
.PP
The I/O watcher might use the underlying file descriptor or a copy of it.
You must not close a file handle as long as any watcher is active on the
underlying file descriptor.
.PP
Some event loops issue spurious readiness notifications, so you should
always use non-blocking calls when reading/writing from/to your file
handles.
.PP
Example: wait for readability of \s-1STDIN\s0, then read a line and disable the
watcher.
.PP
.Vb 5
\&   my $w; $w = AnyEvent\->io (fh => \e*STDIN, poll => \*(Aqr\*(Aq, cb => sub {
\&      chomp (my $input = <STDIN>);
\&      warn "read: $input\en";
\&      undef $w;
\&   });
.Ve
.SS "\s-1TIME\s0 \s-1WATCHERS\s0"
.IX Subsection "TIME WATCHERS"
.Vb 1
\&   $w = AnyEvent\->timer (after => <seconds>, cb => <callback>);
\&
\&   $w = AnyEvent\->timer (
\&      after    => <fractional_seconds>,
\&      interval => <fractional_seconds>,
\&      cb       => <callback>,
\&   );
.Ve
.PP
You can create a time watcher by calling the \f(CW\*(C`AnyEvent\->timer\*(C'\fR
method with the following mandatory arguments:
.PP
\&\f(CW\*(C`after\*(C'\fR specifies after how many seconds (fractional values are
supported) the callback should be invoked. \f(CW\*(C`cb\*(C'\fR is the callback to invoke
in that case.
.PP
Although the callback might get passed parameters, their value and
presence is undefined and you cannot rely on them. Portable AnyEvent
callbacks cannot use arguments passed to time watcher callbacks.
.PP
The callback will normally be invoked only once. If you specify another
parameter, \f(CW\*(C`interval\*(C'\fR, as a strictly positive number (> 0), then the
callback will be invoked regularly at that interval (in fractional
seconds) after the first invocation. If \f(CW\*(C`interval\*(C'\fR is specified with a
false value, then it is treated as if it were not specified at all.
.PP
The callback will be rescheduled before invoking the callback, but no
attempt is made to avoid timer drift in most backends, so the interval is
only approximate.
.PP
Example: fire an event after 7.7 seconds.
.PP
.Vb 3
\&   my $w = AnyEvent\->timer (after => 7.7, cb => sub {
\&      warn "timeout\en";
\&   });
\&
\&   # to cancel the timer:
\&   undef $w;
.Ve
.PP
Example 2: fire an event after 0.5 seconds, then roughly every second.
.PP
.Vb 3
\&   my $w = AnyEvent\->timer (after => 0.5, interval => 1, cb => sub {
\&      warn "timeout\en";
\&   };
.Ve
.PP
\fI\s-1TIMING\s0 \s-1ISSUES\s0\fR
.IX Subsection "TIMING ISSUES"
.PP
There are two ways to handle timers: based on real time (relative, \*(L"fire
in 10 seconds\*(R") and based on wallclock time (absolute, \*(L"fire at 12
o'clock\*(R").
.PP
While most event loops expect timers to specified in a relative way, they
use absolute time internally. This makes a difference when your clock
\&\*(L"jumps\*(R", for example, when ntp decides to set your clock backwards from
the wrong date of 2014\-01\-01 to 2008\-01\-01, a watcher that is supposed to
fire \*(L"after a second\*(R" might actually take six years to finally fire.
.PP
AnyEvent cannot compensate for this. The only event loop that is conscious
of these issues is \s-1EV\s0, which offers both relative (ev_timer, based
on true relative time) and absolute (ev_periodic, based on wallclock time)
timers.
.PP
AnyEvent always prefers relative timers, if available, matching the
AnyEvent \s-1API\s0.
.PP
AnyEvent has two additional methods that return the \*(L"current time\*(R":
.IP "AnyEvent\->time" 4
.IX Item "AnyEvent->time"
This returns the \*(L"current wallclock time\*(R" as a fractional number of
seconds since the Epoch (the same thing as \f(CW\*(C`time\*(C'\fR or \f(CW\*(C`Time::HiRes::time\*(C'\fR
return, and the result is guaranteed to be compatible with those).
.Sp
It progresses independently of any event loop processing, i.e. each call
will check the system clock, which usually gets updated frequently.
.IP "AnyEvent\->now" 4
.IX Item "AnyEvent->now"
This also returns the \*(L"current wallclock time\*(R", but unlike \f(CW\*(C`time\*(C'\fR, above,
this value might change only once per event loop iteration, depending on
the event loop (most return the same time as \f(CW\*(C`time\*(C'\fR, above). This is the
time that AnyEvent's timers get scheduled against.
.Sp
\&\fIIn almost all cases (in all cases if you don't care), this is the
function to call when you want to know the current time.\fR
.Sp
This function is also often faster then \f(CW\*(C`AnyEvent\->time\*(C'\fR, and
thus the preferred method if you want some timestamp (for example,
AnyEvent::Handle uses this to update its activity timeouts).
.Sp
The rest of this section is only of relevance if you try to be very exact
with your timing; you can skip it without a bad conscience.
.Sp
For a practical example of when these times differ, consider Event::Lib
and \s-1EV\s0 and the following set-up:
.Sp
The event loop is running and has just invoked one of your callbacks at
time=500 (assume no other callbacks delay processing). In your callback,
you wait a second by executing \f(CW\*(C`sleep 1\*(C'\fR (blocking the process for a
second) and then (at time=501) you create a relative timer that fires
after three seconds.
.Sp
With Event::Lib, \f(CW\*(C`AnyEvent\->time\*(C'\fR and \f(CW\*(C`AnyEvent\->now\*(C'\fR will
both return \f(CW501\fR, because that is the current time, and the timer will
be scheduled to fire at time=504 (\f(CW501\fR + \f(CW3\fR).
.Sp
With \s-1EV\s0, \f(CW\*(C`AnyEvent\->time\*(C'\fR returns \f(CW501\fR (as that is the current
time), but \f(CW\*(C`AnyEvent\->now\*(C'\fR returns \f(CW500\fR, as that is the time the
last event processing phase started. With \s-1EV\s0, your timer gets scheduled
to run at time=503 (\f(CW500\fR + \f(CW3\fR).
.Sp
In one sense, Event::Lib is more exact, as it uses the current time
regardless of any delays introduced by event processing. However, most
callbacks do not expect large delays in processing, so this causes a
higher drift (and a lot more system calls to get the current time).
.Sp
In another sense, \s-1EV\s0 is more exact, as your timer will be scheduled at
the same time, regardless of how long event processing actually took.
.Sp
In either case, if you care (and in most cases, you don't), then you
can get whatever behaviour you want with any event loop, by taking the
difference between \f(CW\*(C`AnyEvent\->time\*(C'\fR and \f(CW\*(C`AnyEvent\->now\*(C'\fR into
account.
.IP "AnyEvent\->now_update" 4
.IX Item "AnyEvent->now_update"
Some event loops (such as \s-1EV\s0 or AnyEvent::Loop) cache the current
time for each loop iteration (see the discussion of AnyEvent\->now,
above).
.Sp
When a callback runs for a long time (or when the process sleeps), then
this \*(L"current\*(R" time will differ substantially from the real time, which
might affect timers and time-outs.
.Sp
When this is the case, you can call this method, which will update the
event loop's idea of \*(L"current time\*(R".
.Sp
A typical example would be a script in a web server (e.g. \f(CW\*(C`mod_perl\*(C'\fR) \-
when mod_perl executes the script, then the event loop will have the wrong
idea about the \*(L"current time\*(R" (being potentially far in the past, when the
script ran the last time). In that case you should arrange a call to \f(CW\*(C`AnyEvent\->now_update\*(C'\fR each time the web server process wakes up again
(e.g. at the start of your script, or in a handler).
.Sp
Note that updating the time \fImight\fR cause some events to be handled.
.SS "\s-1SIGNAL\s0 \s-1WATCHERS\s0"
.IX Subsection "SIGNAL WATCHERS"
.Vb 1
\&   $w = AnyEvent\->signal (signal => <uppercase_signal_name>, cb => <callback>);
.Ve
.PP
You can watch for signals using a signal watcher, \f(CW\*(C`signal\*(C'\fR is the signal
\&\fIname\fR in uppercase and without any \f(CW\*(C`SIG\*(C'\fR prefix, \f(CW\*(C`cb\*(C'\fR is the Perl
callback to be invoked whenever a signal occurs.
.PP
Although the callback might get passed parameters, their value and
presence is undefined and you cannot rely on them. Portable AnyEvent
callbacks cannot use arguments passed to signal watcher callbacks.
.PP
Multiple signal occurrences can be clumped together into one callback
invocation, and callback invocation will be synchronous. Synchronous means
that it might take a while until the signal gets handled by the process,
but it is guaranteed not to interrupt any other callbacks.
.PP
The main advantage of using these watchers is that you can share a signal
between multiple watchers, and AnyEvent will ensure that signals will not
interrupt your program at bad times.
.PP
This watcher might use \f(CW%SIG\fR (depending on the event loop used),
so programs overwriting those signals directly will likely not work
correctly.
.PP
Example: exit on \s-1SIGINT\s0
.PP
.Vb 1
\&   my $w = AnyEvent\->signal (signal => "INT", cb => sub { exit 1 });
.Ve
.PP
\fIRestart Behaviour\fR
.IX Subsection "Restart Behaviour"
.PP
While restart behaviour is up to the event loop implementation, most will
not restart syscalls (that includes Async::Interrupt and AnyEvent's
pure perl implementation).
.PP
\fISafe/Unsafe Signals\fR
.IX Subsection "Safe/Unsafe Signals"
.PP
Perl signals can be either \*(L"safe\*(R" (synchronous to opcode handling)
or \*(L"unsafe\*(R" (asynchronous) \- the former might delay signal delivery
indefinitely, the latter might corrupt your memory.
.PP
AnyEvent signal handlers are, in addition, synchronous to the event loop,
i.e. they will not interrupt your running perl program but will only be
called as part of the normal event handling (just like timer, I/O etc.
callbacks, too).
.PP
\fISignal Races, Delays and Workarounds\fR
.IX Subsection "Signal Races, Delays and Workarounds"
.PP
Many event loops (e.g. Glib, Tk, Qt, IO::Async) do not support
attaching callbacks to signals in a generic way, which is a pity,
as you cannot do race-free signal handling in perl, requiring
C libraries for this. AnyEvent will try to do its best, which
means in some cases, signals will be delayed. The maximum time
a signal might be delayed is 10 seconds by default, but can
be overriden via \f(CW$ENV{PERL_ANYEVENT_MAX_SIGNAL_LATENCY}\fR or
\&\f(CW$AnyEvent::MAX_SIGNAL_LATENCY\fR \- see the \*(L"\s-1ENVIRONMENT\s0 \s-1VARIABLES\s0\*(R"
section for details.
.PP
All these problems can be avoided by installing the optional
Async::Interrupt module, which works with most event loops. It will not
work with inherently broken event loops such as Event or Event::Lib
(and not with \s-1POE\s0 currently). For those, you just have to suffer the
delays.
.SS "\s-1CHILD\s0 \s-1PROCESS\s0 \s-1WATCHERS\s0"
.IX Subsection "CHILD PROCESS WATCHERS"
.Vb 1
\&   $w = AnyEvent\->child (pid => <process id>, cb => <callback>);
.Ve
.PP
You can also watch for a child process exit and catch its exit status.
.PP
The child process is specified by the \f(CW\*(C`pid\*(C'\fR argument (on some backends,
using \f(CW0\fR watches for any child process exit, on others this will
croak). The watcher will be triggered only when the child process has
finished and an exit status is available, not on any trace events
(stopped/continued).
.PP
The callback will be called with the pid and exit status (as returned by
waitpid), so unlike other watcher types, you \fIcan\fR rely on child watcher
callback arguments.
.PP
This watcher type works by installing a signal handler for \f(CW\*(C`SIGCHLD\*(C'\fR,
and since it cannot be shared, nothing else should use \s-1SIGCHLD\s0 or reap
random child processes (waiting for specific child processes, e.g. inside
\&\f(CW\*(C`system\*(C'\fR, is just fine).
.PP
There is a slight catch to child watchers, however: you usually start them
\&\fIafter\fR the child process was created, and this means the process could
have exited already (and no \s-1SIGCHLD\s0 will be sent anymore).
.PP
Not all event models handle this correctly (neither \s-1POE\s0 nor IO::Async do,
see their AnyEvent::Impl manpages for details), but even for event models
that \fIdo\fR handle this correctly, they usually need to be loaded before
the process exits (i.e. before you fork in the first place). AnyEvent's
pure perl event loop handles all cases correctly regardless of when you
start the watcher.
.PP
This means you cannot create a child watcher as the very first
thing in an AnyEvent program, you \fIhave\fR to create at least one
watcher before you \f(CW\*(C`fork\*(C'\fR the child (alternatively, you can call
\&\f(CW\*(C`AnyEvent::detect\*(C'\fR).
.PP
As most event loops do not support waiting for child events, they will be
emulated by AnyEvent in most cases, in which case the latency and race
problems mentioned in the description of signal watchers apply.
.PP
Example: fork a process and wait for it
.PP
.Vb 1
\&   my $done = AnyEvent\->condvar;
\&  
\&   my $pid = fork or exit 5;
\&  
\&   my $w = AnyEvent\->child (
\&      pid => $pid,
\&      cb  => sub {
\&         my ($pid, $status) = @_;
\&         warn "pid $pid exited with status $status";
\&         $done\->send;
\&      },
\&   );
\&  
\&   # do something else, then wait for process exit
\&   $done\->recv;
.Ve
.SS "\s-1IDLE\s0 \s-1WATCHERS\s0"
.IX Subsection "IDLE WATCHERS"
.Vb 1
\&   $w = AnyEvent\->idle (cb => <callback>);
.Ve
.PP
This will repeatedly invoke the callback after the process becomes idle,
until either the watcher is destroyed or new events have been detected.
.PP
Idle watchers are useful when there is a need to do something, but it
is not so important (or wise) to do it instantly. The callback will be
invoked only when there is \*(L"nothing better to do\*(R", which is usually
defined as \*(L"all outstanding events have been handled and no new events
have been detected\*(R". That means that idle watchers ideally get invoked
when the event loop has just polled for new events but none have been
detected. Instead of blocking to wait for more events, the idle watchers
will be invoked.
.PP
Unfortunately, most event loops do not really support idle watchers (only
\&\s-1EV\s0, Event and Glib do it in a usable fashion) \- for the rest, AnyEvent
will simply call the callback \*(L"from time to time\*(R".
.PP
Example: read lines from \s-1STDIN\s0, but only process them when the
program is otherwise idle:
.PP
.Vb 4
\&   my @lines; # read data
\&   my $idle_w;
\&   my $io_w = AnyEvent\->io (fh => \e*STDIN, poll => \*(Aqr\*(Aq, cb => sub {
\&      push @lines, scalar <STDIN>;
\&
\&      # start an idle watcher, if not already done
\&      $idle_w ||= AnyEvent\->idle (cb => sub {
\&         # handle only one line, when there are lines left
\&         if (my $line = shift @lines) {
\&            print "handled when idle: $line";
\&         } else {
\&            # otherwise disable the idle watcher again
\&            undef $idle_w;
\&         }
\&      });
\&   });
.Ve
.SS "\s-1CONDITION\s0 \s-1VARIABLES\s0"
.IX Subsection "CONDITION VARIABLES"
.Vb 1
\&   $cv = AnyEvent\->condvar;
\&
\&   $cv\->send (<list>);
\&   my @res = $cv\->recv;
.Ve
.PP
If you are familiar with some event loops you will know that all of them
require you to run some blocking \*(L"loop\*(R", \*(L"run\*(R" or similar function that
will actively watch for new events and call your callbacks.
.PP
AnyEvent is slightly different: it expects somebody else to run the event
loop and will only block when necessary (usually when told by the user).
.PP
The tool to do that is called a \*(L"condition variable\*(R", so called because
they represent a condition that must become true.
.PP
Now is probably a good time to look at the examples further below.
.PP
Condition variables can be created by calling the \f(CW\*(C`AnyEvent\->condvar\*(C'\fR method, usually without arguments. The only argument pair allowed is
\&\f(CW\*(C`cb\*(C'\fR, which specifies a callback to be called when the condition variable
becomes true, with the condition variable as the first argument (but not
the results).
.PP
After creation, the condition variable is \*(L"false\*(R" until it becomes \*(L"true\*(R"
by calling the \f(CW\*(C`send\*(C'\fR method (or calling the condition variable as if it
were a callback, read about the caveats in the description for the \f(CW\*(C`\->send\*(C'\fR method).
.PP
Since condition variables are the most complex part of the AnyEvent \s-1API\s0, here are
some different mental models of what they are \- pick the ones you can connect to:
.IP "\(bu" 4
Condition variables are like callbacks \- you can call them (and pass them instead
of callbacks). Unlike callbacks however, you can also wait for them to be called.
.IP "\(bu" 4
Condition variables are signals \- one side can emit or send them,
the other side can wait for them, or install a handler that is called when
the signal fires.
.IP "\(bu" 4
Condition variables are like \*(L"Merge Points\*(R" \- points in your program
where you merge multiple independent results/control flows into one.
.IP "\(bu" 4
Condition variables represent a transaction \- functions that start
some kind of transaction can return them, leaving the caller the choice
between waiting in a blocking fashion, or setting a callback.
.IP "\(bu" 4
Condition variables represent future values, or promises to deliver
some result, long before the result is available.
.PP
Condition variables are very useful to signal that something has finished,
for example, if you write a module that does asynchronous http requests,
then a condition variable would be the ideal candidate to signal the
availability of results. The user can either act when the callback is
called or can synchronously \f(CW\*(C`\->recv\*(C'\fR for the results.
.PP
You can also use them to simulate traditional event loops \- for example,
you can block your main program until an event occurs \- for example, you
could \f(CW\*(C`\->recv\*(C'\fR in your main program until the user clicks the Quit
button of your app, which would \f(CW\*(C`\->send\*(C'\fR the \*(L"quit\*(R" event.
.PP
Note that condition variables recurse into the event loop \- if you have
two pieces of code that call \f(CW\*(C`\->recv\*(C'\fR in a round-robin fashion, you
lose. Therefore, condition variables are good to export to your caller, but
you should avoid making a blocking wait yourself, at least in callbacks,
as this asks for trouble.
.PP
Condition variables are represented by hash refs in perl, and the keys
used by AnyEvent itself are all named \f(CW\*(C`_ae_XXX\*(C'\fR to make subclassing
easy (it is often useful to build your own transaction class on top of
AnyEvent). To subclass, use \f(CW\*(C`AnyEvent::CondVar\*(C'\fR as base class and call
its \f(CW\*(C`new\*(C'\fR method in your own \f(CW\*(C`new\*(C'\fR method.
.PP
There are two \*(L"sides\*(R" to a condition variable \- the \*(L"producer side\*(R" which
eventually calls \f(CW\*(C`\-> send\*(C'\fR, and the \*(L"consumer side\*(R", which waits
for the send to occur.
.PP
Example: wait for a timer.
.PP
.Vb 2
\&   # condition: "wait till the timer is fired"
\&   my $timer_fired = AnyEvent\->condvar;
\&
\&   # create the timer \- we could wait for, say
\&   # a handle becomign ready, or even an
\&   # AnyEvent::HTTP request to finish, but
\&   # in this case, we simply use a timer:
\&   my $w = AnyEvent\->timer (
\&      after => 1,
\&      cb    => sub { $timer_fired\->send },
\&   );
\&
\&   # this "blocks" (while handling events) till the callback
\&   # calls \->send
\&   $timer_fired\->recv;
.Ve
.PP
Example: wait for a timer, but take advantage of the fact that condition
variables are also callable directly.
.PP
.Vb 3
\&   my $done = AnyEvent\->condvar;
\&   my $delay = AnyEvent\->timer (after => 5, cb => $done);
\&   $done\->recv;
.Ve
.PP
Example: Imagine an \s-1API\s0 that returns a condvar and doesn't support
callbacks. This is how you make a synchronous call, for example from
the main program:
.PP
.Vb 1
\&   use AnyEvent::CouchDB;
\&
\&   ...
\&
\&   my @info = $couchdb\->info\->recv;
.Ve
.PP
And this is how you would just set a callback to be called whenever the
results are available:
.PP
.Vb 3
\&   $couchdb\->info\->cb (sub {
\&      my @info = $_[0]\->recv;
\&   });
.Ve
.PP
\fI\s-1METHODS\s0 \s-1FOR\s0 \s-1PRODUCERS\s0\fR
.IX Subsection "METHODS FOR PRODUCERS"
.PP
These methods should only be used by the producing side, i.e. the
code/module that eventually sends the signal. Note that it is also
the producer side which creates the condvar in most cases, but it isn't
uncommon for the consumer to create it as well.
.ie n .IP "$cv\->send (...)" 4
.el .IP "\f(CW$cv\fR\->send (...)" 4
.IX Item "$cv->send (...)"
Flag the condition as ready \- a running \f(CW\*(C`\->recv\*(C'\fR and all further
calls to \f(CW\*(C`recv\*(C'\fR will (eventually) return after this method has been
called. If nobody is waiting the send will be remembered.
.Sp
If a callback has been set on the condition variable, it is called
immediately from within send.
.Sp
Any arguments passed to the \f(CW\*(C`send\*(C'\fR call will be returned by all
future \f(CW\*(C`\->recv\*(C'\fR calls.
.Sp
Condition variables are overloaded so one can call them directly (as if
they were a code reference). Calling them directly is the same as calling
\&\f(CW\*(C`send\*(C'\fR.
.ie n .IP "$cv\->croak ($error)" 4
.el .IP "\f(CW$cv\fR\->croak ($error)" 4
.IX Item "$cv->croak ($error)"
Similar to send, but causes all calls to \f(CW\*(C`\->recv\*(C'\fR to invoke
\&\f(CW\*(C`Carp::croak\*(C'\fR with the given error message/object/scalar.
.Sp
This can be used to signal any errors to the condition variable
user/consumer. Doing it this way instead of calling \f(CW\*(C`croak\*(C'\fR directly
delays the error detection, but has the overwhelming advantage that it
diagnoses the error at the place where the result is expected, and not
deep in some event callback with no connection to the actual code causing
the problem.
.ie n .IP "$cv\->begin ([group callback])" 4
.el .IP "\f(CW$cv\fR\->begin ([group callback])" 4
.IX Item "$cv->begin ([group callback])"
.PD 0
.ie n .IP "$cv\->end" 4
.el .IP "\f(CW$cv\fR\->end" 4
.IX Item "$cv->end"
.PD
These two methods can be used to combine many transactions/events into
one. For example, a function that pings many hosts in parallel might want
to use a condition variable for the whole process.
.Sp
Every call to \f(CW\*(C`\->begin\*(C'\fR will increment a counter, and every call to
\&\f(CW\*(C`\->end\*(C'\fR will decrement it.  If the counter reaches \f(CW0\fR in \f(CW\*(C`\->end\*(C'\fR, the (last) callback passed to \f(CW\*(C`begin\*(C'\fR will be executed, passing the
condvar as first argument. That callback is \fIsupposed\fR to call \f(CW\*(C`\->send\*(C'\fR, but that is not required. If no group callback was set, \f(CW\*(C`send\*(C'\fR will
be called without any arguments.
.Sp
You can think of \f(CW\*(C`$cv\->send\*(C'\fR giving you an \s-1OR\s0 condition (one call
sends), while \f(CW\*(C`$cv\->begin\*(C'\fR and \f(CW\*(C`$cv\->end\*(C'\fR giving you an \s-1AND\s0
condition (all \f(CW\*(C`begin\*(C'\fR calls must be \f(CW\*(C`end\*(C'\fR'ed before the condvar sends).
.Sp
Let's start with a simple example: you have two I/O watchers (for example,
\&\s-1STDOUT\s0 and \s-1STDERR\s0 for a program), and you want to wait for both streams to
close before activating a condvar:
.Sp
.Vb 1
\&   my $cv = AnyEvent\->condvar;
\&
\&   $cv\->begin; # first watcher
\&   my $w1 = AnyEvent\->io (fh => $fh1, cb => sub {
\&      defined sysread $fh1, my $buf, 4096
\&         or $cv\->end;
\&   });
\&
\&   $cv\->begin; # second watcher
\&   my $w2 = AnyEvent\->io (fh => $fh2, cb => sub {
\&      defined sysread $fh2, my $buf, 4096
\&         or $cv\->end;
\&   });
\&
\&   $cv\->recv;
.Ve
.Sp
This works because for every event source (\s-1EOF\s0 on file handle), there is
one call to \f(CW\*(C`begin\*(C'\fR, so the condvar waits for all calls to \f(CW\*(C`end\*(C'\fR before
sending.
.Sp
The ping example mentioned above is slightly more complicated, as the
there are results to be passwd back, and the number of tasks that are
begun can potentially be zero:
.Sp
.Vb 1
\&   my $cv = AnyEvent\->condvar;
\&
\&   my %result;
\&   $cv\->begin (sub { shift\->send (\e%result) });
\&
\&   for my $host (@list_of_hosts) {
\&      $cv\->begin;
\&      ping_host_then_call_callback $host, sub {
\&         $result{$host} = ...;
\&         $cv\->end;
\&      };
\&   }
\&
\&   $cv\->end;
.Ve
.Sp
This code fragment supposedly pings a number of hosts and calls
\&\f(CW\*(C`send\*(C'\fR after results for all then have have been gathered \- in any
order. To achieve this, the code issues a call to \f(CW\*(C`begin\*(C'\fR when it starts
each ping request and calls \f(CW\*(C`end\*(C'\fR when it has received some result for
it. Since \f(CW\*(C`begin\*(C'\fR and \f(CW\*(C`end\*(C'\fR only maintain a counter, the order in which
results arrive is not relevant.
.Sp
There is an additional bracketing call to \f(CW\*(C`begin\*(C'\fR and \f(CW\*(C`end\*(C'\fR outside the
loop, which serves two important purposes: first, it sets the callback
to be called once the counter reaches \f(CW0\fR, and second, it ensures that
\&\f(CW\*(C`send\*(C'\fR is called even when \f(CW\*(C`no\*(C'\fR hosts are being pinged (the loop
doesn't execute once).
.Sp
This is the general pattern when you \*(L"fan out\*(R" into multiple (but
potentially zero) subrequests: use an outer \f(CW\*(C`begin\*(C'\fR/\f(CW\*(C`end\*(C'\fR pair to set
the callback and ensure \f(CW\*(C`end\*(C'\fR is called at least once, and then, for each
subrequest you start, call \f(CW\*(C`begin\*(C'\fR and for each subrequest you finish,
call \f(CW\*(C`end\*(C'\fR.
.PP
\fI\s-1METHODS\s0 \s-1FOR\s0 \s-1CONSUMERS\s0\fR
.IX Subsection "METHODS FOR CONSUMERS"
.PP
These methods should only be used by the consuming side, i.e. the
code awaits the condition.
.ie n .IP "$cv\->recv" 4
.el .IP "\f(CW$cv\fR\->recv" 4
.IX Item "$cv->recv"
Wait (blocking if necessary) until the \f(CW\*(C`\->send\*(C'\fR or \f(CW\*(C`\->croak\*(C'\fR methods have been called on \f(CW$cv\fR, while servicing other watchers
normally.
.Sp
You can only wait once on a condition \- additional calls are valid but
will return immediately.
.Sp
If an error condition has been set by calling \f(CW\*(C`\->croak\*(C'\fR, then this
function will call \f(CW\*(C`croak\*(C'\fR.
.Sp
In list context, all parameters passed to \f(CW\*(C`send\*(C'\fR will be returned,
in scalar context only the first one will be returned.
.Sp
Note that doing a blocking wait in a callback is not supported by any
event loop, that is, recursive invocation of a blocking \f(CW\*(C`\->recv\*(C'\fR is not allowed, and the \f(CW\*(C`recv\*(C'\fR call will \f(CW\*(C`croak\*(C'\fR if such a
condition is detected. This condition can be slightly loosened by using
Coro::AnyEvent, which allows you to do a blocking \f(CW\*(C`\->recv\*(C'\fR from
any thread that doesn't run the event loop itself.
.Sp
Not all event models support a blocking wait \- some die in that case
(programs might want to do that to stay interactive), so \fIif you are
using this from a module, never require a blocking wait\fR. Instead, let the
caller decide whether the call will block or not (for example, by coupling
condition variables with some kind of request results and supporting
callbacks so the caller knows that getting the result will not block,
while still supporting blocking waits if the caller so desires).
.Sp
You can ensure that \f(CW\*(C`\->recv\*(C'\fR never blocks by setting a callback and
only calling \f(CW\*(C`\->recv\*(C'\fR from within that callback (or at a later
time). This will work even when the event loop does not support blocking
waits otherwise.
.ie n .IP "$bool = $cv\->ready" 4
.el .IP "\f(CW$bool\fR = \f(CW$cv\fR\->ready" 4
.IX Item "$bool = $cv->ready"
Returns true when the condition is \*(L"true\*(R", i.e. whether \f(CW\*(C`send\*(C'\fR or
\&\f(CW\*(C`croak\*(C'\fR have been called.
.ie n .IP "$cb = $cv\->cb ($cb\->($cv))" 4
.el .IP "\f(CW$cb\fR = \f(CW$cv\fR\->cb ($cb\->($cv))" 4
.IX Item "$cb = $cv->cb ($cb->($cv))"
This is a mutator function that returns the callback set and optionally
replaces it before doing so.
.Sp
The callback will be called when the condition becomes \*(L"true\*(R", i.e. when
\&\f(CW\*(C`send\*(C'\fR or \f(CW\*(C`croak\*(C'\fR are called, with the only argument being the
condition variable itself. If the condition is already true, the
callback is called immediately when it is set. Calling \f(CW\*(C`recv\*(C'\fR inside
the callback or at any later time is guaranteed not to block.
.SH "SUPPORTED EVENT LOOPS/BACKENDS"
.IX Header "SUPPORTED EVENT LOOPS/BACKENDS"
The available backend classes are (every class has its own manpage):
.IP "Backends that are autoprobed when no other event loop can be found." 4
.IX Item "Backends that are autoprobed when no other event loop can be found."
\&\s-1EV\s0 is the preferred backend when no other event loop seems to be in
use. If \s-1EV\s0 is not installed, then AnyEvent will fall back to its own
pure-perl implementation, which is available everywhere as it comes with
AnyEvent itself.
.Sp
.Vb 2
\&   AnyEvent::Impl::EV        based on EV (interface to libev, best choice).
\&   AnyEvent::Impl::Perl      pure\-perl AnyEvent::Loop, fast and portable.
.Ve
.IP "Backends that are transparently being picked up when they are used." 4
.IX Item "Backends that are transparently being picked up when they are used."
These will be used if they are already loaded when the first watcher
is created, in which case it is assumed that the application is using
them. This means that AnyEvent will automatically pick the right backend
when the main program loads an event module before anything starts to
create watchers. Nothing special needs to be done by the main program.
.Sp
.Vb 9
\&   AnyEvent::Impl::Event     based on Event, very stable, few glitches.
\&   AnyEvent::Impl::Glib      based on Glib, slow but very stable.
\&   AnyEvent::Impl::Tk        based on Tk, very broken.
\&   AnyEvent::Impl::EventLib  based on Event::Lib, leaks memory and worse.
\&   AnyEvent::Impl::POE       based on POE, very slow, some limitations.
\&   AnyEvent::Impl::Irssi     used when running within irssi.
\&   AnyEvent::Impl::IOAsync   based on IO::Async.
\&   AnyEvent::Impl::Cocoa     based on Cocoa::EventLoop.
\&   AnyEvent::Impl::FLTK      based on FLTK (fltk 2 binding).
.Ve
.IP "Backends with special needs." 4
.IX Item "Backends with special needs."
Qt requires the Qt::Application to be instantiated first, but will
otherwise be picked up automatically. As long as the main program
instantiates the application before any AnyEvent watchers are created,
everything should just work.
.Sp
.Vb 1
\&   AnyEvent::Impl::Qt        based on Qt.
.Ve
.IP "Event loops that are indirectly supported via other backends." 4
.IX Item "Event loops that are indirectly supported via other backends."
Some event loops can be supported via other modules:
.Sp
There is no direct support for WxWidgets (Wx) or Prima.
.Sp
\&\fBWxWidgets\fR has no support for watching file handles. However, you can
use WxWidgets through the \s-1POE\s0 adaptor, as \s-1POE\s0 has a Wx backend that simply
polls 20 times per second, which was considered to be too horrible to even
consider for AnyEvent.
.Sp
\&\fBPrima\fR is not supported as nobody seems to be using it, but it has a \s-1POE\s0
backend, so it can be supported through \s-1POE\s0.
.Sp
AnyEvent knows about both Prima and Wx, however, and will try to
load \s-1POE\s0 when detecting them, in the hope that \s-1POE\s0 will pick them up,
in which case everything will be automatic.
.SH "GLOBAL VARIABLES AND FUNCTIONS"
.IX Header "GLOBAL VARIABLES AND FUNCTIONS"
These are not normally required to use AnyEvent, but can be useful to
write AnyEvent extension modules.
.ie n .IP "$AnyEvent::MODEL" 4
.el .IP "\f(CW$AnyEvent::MODEL\fR" 4
.IX Item "$AnyEvent::MODEL"
Contains \f(CW\*(C`undef\*(C'\fR until the first watcher is being created, before the
backend has been autodetected.
.Sp
Afterwards it contains the event model that is being used, which is the
name of the Perl class implementing the model. This class is usually one
of the \f(CW\*(C`AnyEvent::Impl::xxx\*(C'\fR modules, but can be any other class in the
case AnyEvent has been extended at runtime (e.g. in \fIrxvt-unicode\fR it
will be \f(CW\*(C`urxvt::anyevent\*(C'\fR).
.IP "AnyEvent::detect" 4
.IX Item "AnyEvent::detect"
Returns \f(CW$AnyEvent::MODEL\fR, forcing autodetection of the event model
if necessary. You should only call this function right before you would
have created an AnyEvent watcher anyway, that is, as late as possible at
runtime, and not e.g. during initialisation of your module.
.Sp
The effect of calling this function is as if a watcher had been created
(specifically, actions that happen \*(L"when the first watcher is created\*(R"
happen when calling detetc as well).
.Sp
If you need to do some initialisation before AnyEvent watchers are
created, use \f(CW\*(C`post_detect\*(C'\fR.
.ie n .IP "$guard = AnyEvent::post_detect { \s-1BLOCK\s0 }" 4
.el .IP "\f(CW$guard\fR = AnyEvent::post_detect { \s-1BLOCK\s0 }" 4
.IX Item "$guard = AnyEvent::post_detect { BLOCK }"
Arranges for the code block to be executed as soon as the event model is
autodetected (or immediately if that has already happened).
.Sp
The block will be executed \fIafter\fR the actual backend has been detected
(\f(CW$AnyEvent::MODEL\fR is set), but \fIbefore\fR any watchers have been
created, so it is possible to e.g. patch \f(CW@AnyEvent::ISA\fR or do
other initialisations \- see the sources of AnyEvent::Strict or
AnyEvent::AIO to see how this is used.
.Sp
The most common usage is to create some global watchers, without forcing
event module detection too early, for example, AnyEvent::AIO creates
and installs the global \s-1IO::AIO\s0 watcher in a \f(CW\*(C`post_detect\*(C'\fR block to
avoid autodetecting the event module at load time.
.Sp
If called in scalar or list context, then it creates and returns an object
that automatically removes the callback again when it is destroyed (or
\&\f(CW\*(C`undef\*(C'\fR when the hook was immediately executed). See AnyEvent::AIO for
a case where this is useful.
.Sp
Example: Create a watcher for the \s-1IO::AIO\s0 module and store it in
\&\f(CW$WATCHER\fR, but do so only do so after the event loop is initialised.
.Sp
.Vb 1
\&   our WATCHER;
\&
\&   my $guard = AnyEvent::post_detect {
\&      $WATCHER = AnyEvent\->io (fh => IO::AIO::poll_fileno, poll => \*(Aqr\*(Aq, cb => \e&IO::AIO::poll_cb);
\&   };
\&
\&   # the ||= is important in case post_detect immediately runs the block,
\&   # as to not clobber the newly\-created watcher. assigning both watcher and
\&   # post_detect guard to the same variable has the advantage of users being
\&   # able to just C<undef $WATCHER> if the watcher causes them grief.
\&
\&   $WATCHER ||= $guard;
.Ve
.ie n .IP "@AnyEvent::post_detect" 4
.el .IP "\f(CW@AnyEvent::post_detect\fR" 4
.IX Item "@AnyEvent::post_detect"
If there are any code references in this array (you can \f(CW\*(C`push\*(C'\fR to it
before or after loading AnyEvent), then they will be called directly
after the event loop has been chosen.
.Sp
You should check \f(CW$AnyEvent::MODEL\fR before adding to this array, though:
if it is defined then the event loop has already been detected, and the
array will be ignored.
.Sp
Best use \f(CW\*(C`AnyEvent::post_detect { BLOCK }\*(C'\fR when your application allows
it, as it takes care of these details.
.Sp
This variable is mainly useful for modules that can do something useful
when AnyEvent is used and thus want to know when it is initialised, but do
not need to even load it by default. This array provides the means to hook
into AnyEvent passively, without loading it.
.Sp
Example: To load Coro::AnyEvent whenever Coro and AnyEvent are used
together, you could put this into Coro (this is the actual code used by
Coro to accomplish this):
.Sp
.Vb 8
\&   if (defined $AnyEvent::MODEL) {
\&      # AnyEvent already initialised, so load Coro::AnyEvent
\&      require Coro::AnyEvent;
\&   } else {
\&      # AnyEvent not yet initialised, so make sure to load Coro::AnyEvent
\&      # as soon as it is
\&      push @AnyEvent::post_detect, sub { require Coro::AnyEvent };
\&   }
.Ve
.IP "AnyEvent::postpone { \s-1BLOCK\s0 }" 4
.IX Item "AnyEvent::postpone { BLOCK }"
Arranges for the block to be executed as soon as possible, but not before
the call itself returns. In practise, the block will be executed just
before the event loop polls for new events, or shortly afterwards.
.Sp
This function never returns anything (to make the \f(CW\*(C`return postpone { ...
}\*(C'\fR idiom more useful.
.Sp
To understand the usefulness of this function, consider a function that
asynchronously does something for you and returns some transaction
object or guard to let you cancel the operation. For example,
\&\f(CW\*(C`AnyEvent::Socket::tcp_connect\*(C'\fR:
.Sp
.Vb 5
\&   # start a conenction attempt unless one is active
\&   $self\->{connect_guard} ||= AnyEvent::Socket::tcp_connect "www.example.net", 80, sub {
\&      delete $self\->{connect_guard};
\&      ...
\&   };
.Ve
.Sp
Imagine that this function could instantly call the callback, for
example, because it detects an obvious error such as a negative port
number. Invoking the callback before the function returns causes problems
however: the callback will be called and will try to delete the guard
object. But since the function hasn't returned yet, there is nothing to
delete. When the function eventually returns it will assign the guard
object to \f(CW\*(C`$self\->{connect_guard}\*(C'\fR, where it will likely never be
deleted, so the program thinks it is still trying to connect.
.Sp
This is where \f(CW\*(C`AnyEvent::postpone\*(C'\fR should be used. Instead of calling the
callback directly on error:
.Sp
.Vb 2
\&   $cb\->(undef), return # signal error to callback, BAD!
\&      if $some_error_condition;
.Ve
.Sp
It should use \f(CW\*(C`postpone\*(C'\fR:
.Sp
.Vb 2
\&   AnyEvent::postpone { $cb\->(undef) }, return # signal error to callback, later
\&      if $some_error_condition;
.Ve
.ie n .IP "AnyEvent::log $level, $msg[, @args]" 4
.el .IP "AnyEvent::log \f(CW$level\fR, \f(CW$msg\fR[, \f(CW@args\fR]" 4
.IX Item "AnyEvent::log $level, $msg[, @args]"
Log the given \f(CW$msg\fR at the given \f(CW$level\fR.
.Sp
If AnyEvent::Log is not loaded then this function makes a simple test
to see whether the message will be logged. If the test succeeds it will
load AnyEvent::Log and call \f(CW\*(C`AnyEvent::Log::log\*(C'\fR \- consequently, look at
the AnyEvent::Log documentation for details.
.Sp
If the test fails it will simply return. Right now this happens when a
numerical loglevel is used and it is larger than the level specified via
\&\f(CW$ENV{PERL_ANYEVENT_VERBOSE}\fR.
.Sp
If you want to sprinkle loads of logging calls around your code, consider
creating a logger callback with the \f(CW\*(C`AnyEvent::Log::logger\*(C'\fR function,
which can reduce typing, codesize and can reduce the logging overhead
enourmously.
.SH "WHAT TO DO IN A MODULE"
.IX Header "WHAT TO DO IN A MODULE"
As a module author, you should \f(CW\*(C`use AnyEvent\*(C'\fR and call AnyEvent methods
freely, but you should not load a specific event module or rely on it.
.PP
Be careful when you create watchers in the module body \- AnyEvent will
decide which event module to use as soon as the first method is called, so
by calling AnyEvent in your module body you force the user of your module
to load the event module first.
.PP
Never call \f(CW\*(C`\->recv\*(C'\fR on a condition variable unless you \fIknow\fR that
the \f(CW\*(C`\->send\*(C'\fR method has been called on it already. This is
because it will stall the whole program, and the whole point of using
events is to stay interactive.
.PP
It is fine, however, to call \f(CW\*(C`\->recv\*(C'\fR when the user of your module
requests it (i.e. if you create a http request object ad have a method
called \f(CW\*(C`results\*(C'\fR that returns the results, it may call \f(CW\*(C`\->recv\*(C'\fR
freely, as the user of your module knows what she is doing. Always).
.SH "WHAT TO DO IN THE MAIN PROGRAM"
.IX Header "WHAT TO DO IN THE MAIN PROGRAM"
There will always be a single main program \- the only place that should
dictate which event model to use.
.PP
If the program is not event-based, it need not do anything special, even
when it depends on a module that uses an AnyEvent. If the program itself
uses AnyEvent, but does not care which event loop is used, all it needs
to do is \f(CW\*(C`use AnyEvent\*(C'\fR. In either case, AnyEvent will choose the best
available loop implementation.
.PP
If the main program relies on a specific event model \- for example, in
Gtk2 programs you have to rely on the Glib module \- you should load the
event module before loading AnyEvent or any module that uses it: generally
speaking, you should load it as early as possible. The reason is that
modules might create watchers when they are loaded, and AnyEvent will
decide on the event model to use as soon as it creates watchers, and it
might choose the wrong one unless you load the correct one yourself.
.PP
You can chose to use a pure-perl implementation by loading the
\&\f(CW\*(C`AnyEvent::Loop\*(C'\fR module, which gives you similar behaviour
everywhere, but letting AnyEvent chose the model is generally better.
.SS "\s-1MAINLOOP\s0 \s-1EMULATION\s0"
.IX Subsection "MAINLOOP EMULATION"
Sometimes (often for short test scripts, or even standalone programs who
only want to use AnyEvent), you do not want to run a specific event loop.
.PP
In that case, you can use a condition variable like this:
.PP
.Vb 1
\&   AnyEvent\->condvar\->recv;
.Ve
.PP
This has the effect of entering the event loop and looping forever.
.PP
Note that usually your program has some exit condition, in which case
it is better to use the \*(L"traditional\*(R" approach of storing a condition
variable somewhere, waiting for it, and sending it when the program should
exit cleanly.
.SH "OTHER MODULES"
.IX Header "OTHER MODULES"
The following is a non-exhaustive list of additional modules that use
AnyEvent as a client and can therefore be mixed easily with other
AnyEvent modules and other event loops in the same program. Some of the
modules come as part of AnyEvent, the others are available via \s-1CPAN\s0 (see
<http://search.cpan.org/search?m=module&q=anyevent%3A%3A*> for
a longer non-exhaustive list), and the list is heavily biased towards
modules of the AnyEvent author himself :)
.IP "AnyEvent::Util" 4
.IX Item "AnyEvent::Util"
Contains various utility functions that replace often-used blocking
functions such as \f(CW\*(C`inet_aton\*(C'\fR with event/callback\-based versions.
.IP "AnyEvent::Socket" 4
.IX Item "AnyEvent::Socket"
Provides various utility functions for (internet protocol) sockets,
addresses and name resolution. Also functions to create non-blocking tcp
connections or tcp servers, with IPv6 and \s-1SRV\s0 record support and more.
.IP "AnyEvent::Handle" 4
.IX Item "AnyEvent::Handle"
Provide read and write buffers, manages watchers for reads and writes,
supports raw and formatted I/O, I/O queued and fully transparent and
non-blocking \s-1SSL/TLS\s0 (via AnyEvent::TLS).
.IP "AnyEvent::DNS" 4
.IX Item "AnyEvent::DNS"
Provides rich asynchronous \s-1DNS\s0 resolver capabilities.
.IP "AnyEvent::HTTP, AnyEvent::IRC, AnyEvent::XMPP, AnyEvent::GPSD, AnyEvent::IGS, AnyEvent::FCP" 4
.IX Item "AnyEvent::HTTP, AnyEvent::IRC, AnyEvent::XMPP, AnyEvent::GPSD, AnyEvent::IGS, AnyEvent::FCP"
Implement event-based interfaces to the protocols of the same name (for
the curious, \s-1IGS\s0 is the International Go Server and \s-1FCP\s0 is the Freenet
Client Protocol).
.IP "AnyEvent::AIO" 4
.IX Item "AnyEvent::AIO"
Truly asynchronous (as opposed to non-blocking) I/O, should be in the
toolbox of every event programmer. AnyEvent::AIO transparently fuses
\&\s-1IO::AIO\s0 and AnyEvent together, giving AnyEvent access to event-based
file I/O, and much more.
.IP "AnyEvent::Filesys::Notify" 4
.IX Item "AnyEvent::Filesys::Notify"
AnyEvent is good for non-blocking stuff, but it can't detect file or
path changes (e.g. \*(L"watch this directory for new files\*(R", \*(L"watch this
file for changes\*(R"). The AnyEvent::Filesys::Notify module promises to
do just that in a portbale fashion, supporting inotify on GNU/Linux and
some weird, without doubt broken, stuff on \s-1OS\s0 X to monitor files. It can
fall back to blocking scans at regular intervals transparently on other
platforms, so it's about as portable as it gets.
.Sp
(I haven't used it myself, but I haven't heard anybody complaining about
it yet).
.IP "AnyEvent::DBI" 4
.IX Item "AnyEvent::DBI"
Executes \s-1DBI\s0 requests asynchronously in a proxy process for you,
notifying you in an event-based way when the operation is finished.
.IP "AnyEvent::HTTPD" 4
.IX Item "AnyEvent::HTTPD"
A simple embedded webserver.
.IP "AnyEvent::FastPing" 4
.IX Item "AnyEvent::FastPing"
The fastest ping in the west.
.IP "Coro" 4
.IX Item "Coro"
Has special support for AnyEvent via Coro::AnyEvent, which allows you
to simply invert the flow control \- don't call us, we will call you:
.Sp
.Vb 3
\&   async {
\&      Coro::AnyEvent::sleep 5; # creates a 5s timer and waits for it
\&      print "5 seconds later!\en";
\&
\&      Coro::AnyEvent::readable *STDIN; # uses an I/O watcher
\&      my $line = <STDIN>; # works for ttys
\&
\&      AnyEvent::HTTP::http_get "url", Coro::rouse_cb;
\&      my ($body, $hdr) = Coro::rouse_wait;
\&   };
.Ve
.SH "SIMPLIFIED AE API"
.IX Header "SIMPLIFIED AE API"
Starting with version 5.0, AnyEvent officially supports a second, much
simpler, \s-1API\s0 that is designed to reduce the calling, typing and memory
overhead by using function call syntax and a fixed number of parameters.
.PP
See the \s-1AE\s0 manpage for details.
.SH "ERROR AND EXCEPTION HANDLING"
.IX Header "ERROR AND EXCEPTION HANDLING"
In general, AnyEvent does not do any error handling \- it relies on the
caller to do that if required. The AnyEvent::Strict module (see also
the \f(CW\*(C`PERL_ANYEVENT_STRICT\*(C'\fR environment variable, below) provides strict
checking of all AnyEvent methods, however, which is highly useful during
development.
.PP
As for exception handling (i.e. runtime errors and exceptions thrown while
executing a callback), this is not only highly event-loop specific, but
also not in any way wrapped by this module, as this is the job of the main
program.
.PP
The pure perl event loop simply re-throws the exception (usually
within \f(CW\*(C`condvar\->recv\*(C'\fR), the Event and \s-1EV\s0 modules call \f(CW\*(C`$Event/EV::DIED\->()\*(C'\fR, Glib uses \f(CW\*(C`install_exception_handler\*(C'\fR and
so on.
.SH "ENVIRONMENT VARIABLES"
.IX Header "ENVIRONMENT VARIABLES"
AnyEvent supports a number of environment variables that tune the
runtime behaviour. They are usually evaluated when AnyEvent is
loaded, initialised, or a submodule that uses them is loaded. Many of
them also cause AnyEvent to load additional modules \- for example,
\&\f(CW\*(C`PERL_ANYEVENT_DEBUG_WRAP\*(C'\fR causes the AnyEvent::Debug module to be
loaded.
.PP
All the environment variables documented here start with
\&\f(CW\*(C`PERL_ANYEVENT_\*(C'\fR, which is what AnyEvent considers its own
namespace. Other modules are encouraged (but by no means required) to use
\&\f(CW\*(C`PERL_ANYEVENT_SUBMODULE\*(C'\fR if they have registered the AnyEvent::Submodule
namespace on \s-1CPAN\s0, for any submodule. For example, AnyEvent::HTTP could
be expected to use \f(CW\*(C`PERL_ANYEVENT_HTTP_PROXY\*(C'\fR (it should not access env
variables starting with \f(CW\*(C`AE_\*(C'\fR, see below).
.PP
All variables can also be set via the \f(CW\*(C`AE_\*(C'\fR prefix, that is, instead
of setting \f(CW\*(C`PERL_ANYEVENT_VERBOSE\*(C'\fR you can also set \f(CW\*(C`AE_VERBOSE\*(C'\fR. In
case there is a clash btween anyevent and another program that uses
\&\f(CW\*(C`AE_something\*(C'\fR you can set the corresponding \f(CW\*(C`PERL_ANYEVENT_something\*(C'\fR
variable to the empty string, as those variables take precedence.
.PP
When AnyEvent is first loaded, it copies all \f(CW\*(C`AE_xxx\*(C'\fR env variables
to their \f(CW\*(C`PERL_ANYEVENT_xxx\*(C'\fR counterpart unless that variable already
exists. If taint mode is on, then AnyEvent will remove \fIall\fR environment
variables starting with \f(CW\*(C`PERL_ANYEVENT_\*(C'\fR from \f(CW%ENV\fR (or replace them
with \f(CW\*(C`undef\*(C'\fR or the empty string, if the corresaponding \f(CW\*(C`AE_\*(C'\fR variable
is set).
.PP
The exact algorithm is currently:
.PP
.Vb 3
\&   1. if taint mode enabled, delete all PERL_ANYEVENT_xyz variables from %ENV
\&   2. copy over AE_xyz to PERL_ANYEVENT_xyz unless the latter alraedy exists
\&   3. if taint mode enabled, set all PERL_ANYEVENT_xyz variables to undef.
.Ve
.PP
This ensures that child processes will not see the \f(CW\*(C`AE_\*(C'\fR variables.
.PP
The following environment variables are currently known to AnyEvent:
.ie n .IP """PERL_ANYEVENT_VERBOSE""" 4
.el .IP "\f(CWPERL_ANYEVENT_VERBOSE\fR" 4
.IX Item "PERL_ANYEVENT_VERBOSE"
By default, AnyEvent will log messages with loglevel \f(CW4\fR (\f(CW\*(C`error\*(C'\fR) or
higher (see AnyEvent::Log). You can set this environment variable to a
numerical loglevel to make AnyEvent more (or less) talkative.
.Sp
If you want to do more than just set the global logging level
you should have a look at \f(CW\*(C`PERL_ANYEVENT_LOG\*(C'\fR, which allows much more
complex specifications.
.Sp
When set to \f(CW0\fR (\f(CW\*(C`off\*(C'\fR), then no messages whatsoever will be logged with
everything else at defaults.
.Sp
When set to \f(CW5\fR or higher (\f(CW\*(C`warn\*(C'\fR), AnyEvent warns about unexpected
conditions, such as not being able to load the event model specified by
\&\f(CW\*(C`PERL_ANYEVENT_MODEL\*(C'\fR, or a guard callback throwing an exception \- this
is the minimum recommended level for use during development.
.Sp
When set to \f(CW7\fR or higher (info), AnyEvent reports which event model it
chooses.
.Sp
When set to \f(CW8\fR or higher (debug), then AnyEvent will report extra
information on which optional modules it loads and how it implements
certain features.
.ie n .IP """PERL_ANYEVENT_LOG""" 4
.el .IP "\f(CWPERL_ANYEVENT_LOG\fR" 4
.IX Item "PERL_ANYEVENT_LOG"
Accepts rather complex logging specifications. For example, you could log
all \f(CW\*(C`debug\*(C'\fR messages of some module to stderr, warnings and above to
stderr, and errors and above to syslog, with:
.Sp
.Vb 1
\&   PERL_ANYEVENT_LOG=Some::Module=debug,+log:filter=warn,+%syslog:%syslog=error,syslog
.Ve
.Sp
For the rather extensive details, see AnyEvent::Log.
.Sp
This variable is evaluated when AnyEvent (or AnyEvent::Log) is loaded,
so will take effect even before AnyEvent has initialised itself.
.Sp
Note that specifying this environment variable causes the AnyEvent::Log
module to be loaded, while \f(CW\*(C`PERL_ANYEVENT_VERBOSE\*(C'\fR does not, so only
using the latter saves a few hundred kB of memory unless a module
explicitly needs the extra features of AnyEvent::Log.
.ie n .IP """PERL_ANYEVENT_STRICT""" 4
.el .IP "\f(CWPERL_ANYEVENT_STRICT\fR" 4
.IX Item "PERL_ANYEVENT_STRICT"
AnyEvent does not do much argument checking by default, as thorough
argument checking is very costly. Setting this variable to a true value
will cause AnyEvent to load \f(CW\*(C`AnyEvent::Strict\*(C'\fR and then to thoroughly
check the arguments passed to most method calls. If it finds any problems,
it will croak.
.Sp
In other words, enables \*(L"strict\*(R" mode.
.Sp
Unlike \f(CW\*(C`use strict\*(C'\fR (or its modern cousin, \f(CW\*(C`use common::sense\*(C'\fR, it is definitely recommended to keep it off in production. Keeping
\&\f(CW\*(C`PERL_ANYEVENT_STRICT=1\*(C'\fR in your environment while developing programs
can be very useful, however.
.ie n .IP """PERL_ANYEVENT_DEBUG_SHELL""" 4
.el .IP "\f(CWPERL_ANYEVENT_DEBUG_SHELL\fR" 4
.IX Item "PERL_ANYEVENT_DEBUG_SHELL"
If this env variable is nonempty, then its contents will be interpreted by
\&\f(CW\*(C`AnyEvent::Socket::parse_hostport\*(C'\fR and \f(CW\*(C`AnyEvent::Debug::shell\*(C'\fR (after
replacing every occurance of \f(CW$$\fR by the process pid). The shell object
is saved in \f(CW$AnyEvent::Debug::SHELL\fR.
.Sp
This happens when the first watcher is created.
.Sp
For example, to bind a debug shell on a unix domain socket in
\&\fI/tmp/debug<pid>.sock\fR, you could use this:
.Sp
.Vb 2
\&   PERL_ANYEVENT_DEBUG_SHELL=/tmp/debug\e$\e$.sock perlprog
\&   # connect with e.g.: socat readline /tmp/debug123.sock
.Ve
.Sp
Or to bind to tcp port 4545 on localhost:
.Sp
.Vb 2
\&   PERL_ANYEVENT_DEBUG_SHELL=127.0.0.1:4545 perlprog
\&   # connect with e.g.: telnet localhost 4545
.Ve
.Sp
Note that creating sockets in \fI/tmp\fR or on localhost is very unsafe on
multiuser systems.
.ie n .IP """PERL_ANYEVENT_DEBUG_WRAP""" 4
.el .IP "\f(CWPERL_ANYEVENT_DEBUG_WRAP\fR" 4
.IX Item "PERL_ANYEVENT_DEBUG_WRAP"
Can be set to \f(CW0\fR, \f(CW1\fR or \f(CW2\fR and enables wrapping of all watchers for
debugging purposes. See \f(CW\*(C`AnyEvent::Debug::wrap\*(C'\fR for details.
.ie n .IP """PERL_ANYEVENT_MODEL""" 4
.el .IP "\f(CWPERL_ANYEVENT_MODEL\fR" 4
.IX Item "PERL_ANYEVENT_MODEL"
This can be used to specify the event model to be used by AnyEvent, before
auto detection and \-probing kicks in.
.Sp
It normally is a string consisting entirely of \s-1ASCII\s0 letters (e.g. \f(CW\*(C`EV\*(C'\fR
or \f(CW\*(C`IOAsync\*(C'\fR). The string \f(CW\*(C`AnyEvent::Impl::\*(C'\fR gets prepended and the
resulting module name is loaded and \- if the load was successful \- used as
event model backend. If it fails to load then AnyEvent will proceed with
auto detection and \-probing.
.Sp
If the string ends with \f(CW\*(C`::\*(C'\fR instead (e.g. \f(CW\*(C`AnyEvent::Impl::EV::\*(C'\fR) then
nothing gets prepended and the module name is used as-is (hint: \f(CW\*(C`::\*(C'\fR at
the end of a string designates a module name and quotes it appropriately).
.Sp
For example, to force the pure perl model (AnyEvent::Loop::Perl) you
could start your program like this:
.Sp
.Vb 1
\&   PERL_ANYEVENT_MODEL=Perl perl ...
.Ve
.ie n .IP """PERL_ANYEVENT_IO_MODEL""" 4
.el .IP "\f(CWPERL_ANYEVENT_IO_MODEL\fR" 4
.IX Item "PERL_ANYEVENT_IO_MODEL"
The current file I/O model \- see AnyEvent::IO for more info.
.Sp
At the moment, only \f(CW\*(C`Perl\*(C'\fR (small, pure-perl, synchronous) and
\&\f(CW\*(C`IOAIO\*(C'\fR (truly asynchronous) are supported. The default is \f(CW\*(C`IOAIO\*(C'\fR if
AnyEvent::AIO can be loaded, otherwise it is \f(CW\*(C`Perl\*(C'\fR.
.ie n .IP """PERL_ANYEVENT_PROTOCOLS""" 4
.el .IP "\f(CWPERL_ANYEVENT_PROTOCOLS\fR" 4
.IX Item "PERL_ANYEVENT_PROTOCOLS"
Used by both AnyEvent::DNS and AnyEvent::Socket to determine preferences
for IPv4 or IPv6. The default is unspecified (and might change, or be the result
of auto probing).
.Sp
Must be set to a comma-separated list of protocols or address families,
current supported: \f(CW\*(C`ipv4\*(C'\fR and \f(CW\*(C`ipv6\*(C'\fR. Only protocols mentioned will be
used, and preference will be given to protocols mentioned earlier in the
list.
.Sp
This variable can effectively be used for denial-of-service attacks
against local programs (e.g. when setuid), although the impact is likely
small, as the program has to handle conenction and other failures anyways.
.Sp
Examples: \f(CW\*(C`PERL_ANYEVENT_PROTOCOLS=ipv4,ipv6\*(C'\fR \- prefer IPv4 over IPv6,
but support both and try to use both.  \f(CW\*(C`PERL_ANYEVENT_PROTOCOLS=ipv4\*(C'\fR
\&\- only support IPv4, never try to resolve or contact IPv6
addresses. \f(CW\*(C`PERL_ANYEVENT_PROTOCOLS=ipv6,ipv4\*(C'\fR support either IPv4 or
IPv6, but prefer IPv6 over IPv4.
.ie n .IP """PERL_ANYEVENT_HOSTS""" 4
.el .IP "\f(CWPERL_ANYEVENT_HOSTS\fR" 4
.IX Item "PERL_ANYEVENT_HOSTS"
This variable, if specified, overrides the \fI/etc/hosts\fR file used by
AnyEvent::Socket\f(CW\*(C`::resolve_sockaddr\*(C'\fR, i.e. hosts aliases will be read
from that file instead.
.ie n .IP """PERL_ANYEVENT_EDNS0""" 4
.el .IP "\f(CWPERL_ANYEVENT_EDNS0\fR" 4
.IX Item "PERL_ANYEVENT_EDNS0"
Used by AnyEvent::DNS to decide whether to use the \s-1EDNS0\s0 extension for
\&\s-1DNS\s0. This extension is generally useful to reduce \s-1DNS\s0 traffic, especially
when \s-1DNSSEC\s0 is involved, but some (broken) firewalls drop such \s-1DNS\s0
packets, which is why it is off by default.
.Sp
Setting this variable to \f(CW1\fR will cause AnyEvent::DNS to announce
\&\s-1EDNS0\s0 in its \s-1DNS\s0 requests.
.ie n .IP """PERL_ANYEVENT_MAX_FORKS""" 4
.el .IP "\f(CWPERL_ANYEVENT_MAX_FORKS\fR" 4
.IX Item "PERL_ANYEVENT_MAX_FORKS"
The maximum number of child processes that \f(CW\*(C`AnyEvent::Util::fork_call\*(C'\fR
will create in parallel.
.ie n .IP """PERL_ANYEVENT_MAX_OUTSTANDING_DNS""" 4
.el .IP "\f(CWPERL_ANYEVENT_MAX_OUTSTANDING_DNS\fR" 4
.IX Item "PERL_ANYEVENT_MAX_OUTSTANDING_DNS"
The default value for the \f(CW\*(C`max_outstanding\*(C'\fR parameter for the default \s-1DNS\s0
resolver \- this is the maximum number of parallel \s-1DNS\s0 requests that are
sent to the \s-1DNS\s0 server.
.ie n .IP """PERL_ANYEVENT_MAX_SIGNAL_LATENCY""" 4
.el .IP "\f(CWPERL_ANYEVENT_MAX_SIGNAL_LATENCY\fR" 4
.IX Item "PERL_ANYEVENT_MAX_SIGNAL_LATENCY"
Perl has inherently racy signal handling (you can basically choose between
losing signals and memory corruption) \- pure perl event loops (including
\&\f(CW\*(C`AnyEvent::Loop\*(C'\fR, when \f(CW\*(C`Async::Interrupt\*(C'\fR isn't available) therefore
have to poll regularly to avoid losing signals.
.Sp
Some event loops are racy, but don't poll regularly, and some event loops
are written in C but are still racy. For those event loops, AnyEvent
installs a timer that regularly wakes up the event loop.
.Sp
By default, the interval for this timer is \f(CW10\fR seconds, but you can
override this delay with this environment variable (or by setting
the \f(CW$AnyEvent::MAX_SIGNAL_LATENCY\fR variable before creating signal
watchers).
.Sp
Lower values increase \s-1CPU\s0 (and energy) usage, higher values can introduce
long delays when reaping children or waiting for signals.
.Sp
The AnyEvent::Async module, if available, will be used to avoid this
polling (with most event loops).
.ie n .IP """PERL_ANYEVENT_RESOLV_CONF""" 4
.el .IP "\f(CWPERL_ANYEVENT_RESOLV_CONF\fR" 4
.IX Item "PERL_ANYEVENT_RESOLV_CONF"
The absolute path to a \fIresolv.conf\fR\-style file to use instead of
\&\fI/etc/resolv.conf\fR (or the OS-specific configuration) in the default
resolver, or the empty string to select the default configuration.
.ie n .IP """PERL_ANYEVENT_CA_FILE"", ""PERL_ANYEVENT_CA_PATH""." 4
.el .IP "\f(CWPERL_ANYEVENT_CA_FILE\fR, \f(CWPERL_ANYEVENT_CA_PATH\fR." 4
.IX Item "PERL_ANYEVENT_CA_FILE, PERL_ANYEVENT_CA_PATH."
When neither \f(CW\*(C`ca_file\*(C'\fR nor \f(CW\*(C`ca_path\*(C'\fR was specified during
AnyEvent::TLS context creation, and either of these environment
variables are nonempty, they will be used to specify \s-1CA\s0 certificate
locations instead of a system-dependent default.
.ie n .IP """PERL_ANYEVENT_AVOID_GUARD"" and ""PERL_ANYEVENT_AVOID_ASYNC_INTERRUPT""" 4
.el .IP "\f(CWPERL_ANYEVENT_AVOID_GUARD\fR and \f(CWPERL_ANYEVENT_AVOID_ASYNC_INTERRUPT\fR" 4
.IX Item "PERL_ANYEVENT_AVOID_GUARD and PERL_ANYEVENT_AVOID_ASYNC_INTERRUPT"
When these are set to \f(CW1\fR, then the respective modules are not
loaded. Mostly good for testing AnyEvent itself.
.SH "SUPPLYING YOUR OWN EVENT MODEL INTERFACE"
.IX Header "SUPPLYING YOUR OWN EVENT MODEL INTERFACE"
This is an advanced topic that you do not normally need to use AnyEvent in
a module. This section is only of use to event loop authors who want to
provide AnyEvent compatibility.
.PP
If you need to support another event library which isn't directly
supported by AnyEvent, you can supply your own interface to it by
pushing, before the first watcher gets created, the package name of
the event module and the package name of the interface to use onto
\&\f(CW@AnyEvent::REGISTRY\fR. You can do that before and even without loading
AnyEvent, so it is reasonably cheap.
.PP
Example:
.PP
.Vb 1
\&   push @AnyEvent::REGISTRY, [urxvt => urxvt::anyevent::];
.Ve
.PP
This tells AnyEvent to (literally) use the \f(CW\*(C`urxvt::anyevent::\*(C'\fR
package/class when it finds the \f(CW\*(C`urxvt\*(C'\fR package/module is already loaded.
.PP
When AnyEvent is loaded and asked to find a suitable event model, it
will first check for the presence of urxvt by trying to \f(CW\*(C`use\*(C'\fR the
\&\f(CW\*(C`urxvt::anyevent\*(C'\fR module.
.PP
The class should provide implementations for all watcher types. See
AnyEvent::Impl::EV (source code), AnyEvent::Impl::Glib (Source code)
and so on for actual examples. Use \f(CW\*(C`perldoc \-m AnyEvent::Impl::Glib\*(C'\fR to
see the sources.
.PP
If you don't provide \f(CW\*(C`signal\*(C'\fR and \f(CW\*(C`child\*(C'\fR watchers than AnyEvent will
provide suitable (hopefully) replacements.
.PP
The above example isn't fictitious, the \fIrxvt-unicode\fR (a.k.a. urxvt)
terminal emulator uses the above line as-is. An interface isn't included
in AnyEvent because it doesn't make sense outside the embedded interpreter
inside \fIrxvt-unicode\fR, and it is updated and maintained as part of the
\&\fIrxvt-unicode\fR distribution.
.PP
\&\fIrxvt-unicode\fR also cheats a bit by not providing blocking access to
condition variables: code blocking while waiting for a condition will
\&\f(CW\*(C`die\*(C'\fR. This still works with most modules/usages, and blocking calls must
not be done in an interactive application, so it makes sense.
.SH "EXAMPLE PROGRAM"
.IX Header "EXAMPLE PROGRAM"
The following program uses an I/O watcher to read data from \s-1STDIN\s0, a timer
to display a message once per second, and a condition variable to quit the
program when the user enters quit:
.PP
.Vb 1
\&   use AnyEvent;
\&
\&   my $cv = AnyEvent\->condvar;
\&
\&   my $io_watcher = AnyEvent\->io (
\&      fh   => \e*STDIN,
\&      poll => \*(Aqr\*(Aq,
\&      cb   => sub {
\&         warn "io event <$_[0]>\en";   # will always output <r>
\&         chomp (my $input = <STDIN>); # read a line
\&         warn "read: $input\en";       # output what has been read
\&         $cv\->send if $input =~ /^q/i; # quit program if /^q/i
\&      },
\&   );
\&
\&   my $time_watcher = AnyEvent\->timer (after => 1, interval => 1, cb => sub {
\&      warn "timeout\en"; # print \*(Aqtimeout\*(Aq at most every second
\&   });
\&
\&   $cv\->recv; # wait until user enters /^q/i
.Ve
.SH "REAL-WORLD EXAMPLE"
.IX Header "REAL-WORLD EXAMPLE"
Consider the Net::FCP module. It features (among others) the following
\&\s-1API\s0 calls, which are to freenet what \s-1HTTP\s0 \s-1GET\s0 requests are to http:
.PP
.Vb 1
\&   my $data = $fcp\->client_get ($url); # blocks
\&
\&   my $transaction = $fcp\->txn_client_get ($url); # does not block
\&   $transaction\->cb ( sub { ... } ); # set optional result callback
\&   my $data = $transaction\->result; # possibly blocks
.Ve
.PP
The \f(CW\*(C`client_get\*(C'\fR method works like \f(CW\*(C`LWP::Simple::get\*(C'\fR: it requests the
given \s-1URL\s0 and waits till the data has arrived. It is defined to be:
.PP
.Vb 1
\&   sub client_get { $_[0]\->txn_client_get ($_[1])\->result }
.Ve
.PP
And in fact is automatically generated. This is the blocking \s-1API\s0 of
Net::FCP, and it works as simple as in any other, similar, module.
.PP
More complicated is \f(CW\*(C`txn_client_get\*(C'\fR: It only creates a transaction
(completion, result, ...) object and initiates the transaction.
.PP
.Vb 1
\&   my $txn = bless { }, Net::FCP::Txn::;
.Ve
.PP
It also creates a condition variable that is used to signal the completion
of the request:
.PP
.Vb 1
\&   $txn\->{finished} = AnyAvent\->condvar;
.Ve
.PP
It then creates a socket in non-blocking mode.
.PP
.Vb 6
\&   socket $txn\->{fh}, ...;
\&   fcntl $txn\->{fh}, F_SETFL, O_NONBLOCK;
\&   connect $txn\->{fh}, ...
\&      and !$!{EWOULDBLOCK}
\&      and !$!{EINPROGRESS}
\&      and Carp::croak "unable to connect: $!\en";
.Ve
.PP
Then it creates a write-watcher which gets called whenever an error occurs
or the connection succeeds:
.PP
.Vb 1
\&   $txn\->{w} = AnyEvent\->io (fh => $txn\->{fh}, poll => \*(Aqw\*(Aq, cb => sub { $txn\->fh_ready_w });
.Ve
.PP
And returns this transaction object. The \f(CW\*(C`fh_ready_w\*(C'\fR callback gets
called as soon as the event loop detects that the socket is ready for
writing.
.PP
The \f(CW\*(C`fh_ready_w\*(C'\fR method makes the socket blocking again, writes the
request data and replaces the watcher by a read watcher (waiting for reply
data). The actual code is more complicated, but that doesn't matter for
this example:
.PP
.Vb 4
\&   fcntl $txn\->{fh}, F_SETFL, 0;
\&   syswrite $txn\->{fh}, $txn\->{request}
\&      or die "connection or write error";
\&   $txn\->{w} = AnyEvent\->io (fh => $txn\->{fh}, poll => \*(Aqr\*(Aq, cb => sub { $txn\->fh_ready_r });
.Ve
.PP
Again, \f(CW\*(C`fh_ready_r\*(C'\fR waits till all data has arrived, and then stores the
result and signals any possible waiters that the request has finished:
.PP
.Vb 1
\&   sysread $txn\->{fh}, $txn\->{buf}, length $txn\->{$buf};
\&
\&   if (end\-of\-file or data complete) {
\&     $txn\->{result} = $txn\->{buf};
\&     $txn\->{finished}\->send;
\&     $txb\->{cb}\->($txn) of $txn\->{cb}; # also call callback
\&   }
.Ve
.PP
The \f(CW\*(C`result\*(C'\fR method, finally, just waits for the finished signal (if the
request was already finished, it doesn't wait, of course, and returns the
data:
.PP
.Vb 2
\&   $txn\->{finished}\->recv;
\&   return $txn\->{result};
.Ve
.PP
The actual code goes further and collects all errors (\f(CW\*(C`die\*(C'\fRs, exceptions)
that occurred during request processing. The \f(CW\*(C`result\*(C'\fR method detects
whether an exception as thrown (it is stored inside the \f(CW$txn\fR object)
and just throws the exception, which means connection errors and other
problems get reported to the code that tries to use the result, not in a
random callback.
.PP
All of this enables the following usage styles:
.PP
1. Blocking:
.PP
.Vb 1
\&   my $data = $fcp\->client_get ($url);
.Ve
.PP
2. Blocking, but running in parallel:
.PP
.Vb 3
\&   my @datas = map $_\->result,
\&                  map $fcp\->txn_client_get ($_),
\&                     @urls;
.Ve
.PP
Both blocking examples work without the module user having to know
anything about events.
.PP
3a. Event-based in a main program, using any supported event module:
.PP
.Vb 1
\&   use EV;
\&
\&   $fcp\->txn_client_get ($url)\->cb (sub {
\&      my $txn = shift;
\&      my $data = $txn\->result;
\&      ...
\&   });
\&
\&   EV::loop;
.Ve
.PP
3b. The module user could use AnyEvent, too:
.PP
.Vb 1
\&   use AnyEvent;
\&
\&   my $quit = AnyEvent\->condvar;
\&
\&   $fcp\->txn_client_get ($url)\->cb (sub {
\&      ...
\&      $quit\->send;
\&   });
\&
\&   $quit\->recv;
.Ve
.SH "BENCHMARKS"
.IX Header "BENCHMARKS"
To give you an idea of the performance and overheads that AnyEvent adds
over the event loops themselves and to give you an impression of the speed
of various event loops I prepared some benchmarks.
.SS "\s-1BENCHMARKING\s0 \s-1ANYEVENT\s0 \s-1OVERHEAD\s0"
.IX Subsection "BENCHMARKING ANYEVENT OVERHEAD"
Here is a benchmark of various supported event models used natively and
through AnyEvent. The benchmark creates a lot of timers (with a zero
timeout) and I/O watchers (watching \s-1STDOUT\s0, a pty, to become writable,
which it is), lets them fire exactly once and destroys them again.
.PP
Source code for this benchmark is found as \fIeg/bench\fR in the AnyEvent
distribution. It uses the \s-1AE\s0 interface, which makes a real difference
for the \s-1EV\s0 and Perl backends only.
.PP
\fIExplanation of the columns\fR
.IX Subsection "Explanation of the columns"
.PP
\&\fIwatcher\fR is the number of event watchers created/destroyed. Since
different event models feature vastly different performances, each event
loop was given a number of watchers so that overall runtime is acceptable
and similar between tested event loop (and keep them from crashing): Glib
would probably take thousands of years if asked to process the same number
of watchers as \s-1EV\s0 in this benchmark.
.PP
\&\fIbytes\fR is the number of bytes (as measured by the resident set size,
\&\s-1RSS\s0) consumed by each watcher. This method of measuring captures both C
and Perl-based overheads.
.PP
\&\fIcreate\fR is the time, in microseconds (millionths of seconds), that it
takes to create a single watcher. The callback is a closure shared between
all watchers, to avoid adding memory overhead. That means closure creation
and memory usage is not included in the figures.
.PP
\&\fIinvoke\fR is the time, in microseconds, used to invoke a simple
callback. The callback simply counts down a Perl variable and after it was
invoked \*(L"watcher\*(R" times, it would \f(CW\*(C`\->send\*(C'\fR a condvar once to
signal the end of this phase.
.PP
\&\fIdestroy\fR is the time, in microseconds, that it takes to destroy a single
watcher.
.PP
\fIResults\fR
.IX Subsection "Results"
.PP
.Vb 10
\&          name watchers bytes create invoke destroy comment
\&         EV/EV   100000   223   0.47   0.43    0.27 EV native interface
\&        EV/Any   100000   223   0.48   0.42    0.26 EV + AnyEvent watchers
\&  Coro::EV/Any   100000   223   0.47   0.42    0.26 coroutines + Coro::Signal
\&      Perl/Any   100000   431   2.70   0.74    0.92 pure perl implementation
\&   Event/Event    16000   516  31.16  31.84    0.82 Event native interface
\&     Event/Any    16000  1203  42.61  34.79    1.80 Event + AnyEvent watchers
\&   IOAsync/Any    16000  1911  41.92  27.45   16.81 via IO::Async::Loop::IO_Poll
\&   IOAsync/Any    16000  1726  40.69  26.37   15.25 via IO::Async::Loop::Epoll
\&      Glib/Any    16000  1118  89.00  12.57   51.17 quadratic behaviour
\&        Tk/Any     2000  1346  20.96  10.75    8.00 SEGV with >> 2000 watchers
\&       POE/Any     2000  6951 108.97 795.32   14.24 via POE::Loop::Event
\&       POE/Any     2000  6648  94.79 774.40  575.51 via POE::Loop::Select
.Ve
.PP
\fIDiscussion\fR
.IX Subsection "Discussion"
.PP
The benchmark does \fInot\fR measure scalability of the event loop very
well. For example, a select-based event loop (such as the pure perl one)
can never compete with an event loop that uses epoll when the number of
file descriptors grows high. In this benchmark, all events become ready at
the same time, so select/poll\-based implementations get an unnatural speed
boost.
.PP
Also, note that the number of watchers usually has a nonlinear effect on
overall speed, that is, creating twice as many watchers doesn't take twice
the time \- usually it takes longer. This puts event loops tested with a
higher number of watchers at a disadvantage.
.PP
To put the range of results into perspective, consider that on the
benchmark machine, handling an event takes roughly 1600 \s-1CPU\s0 cycles with
\&\s-1EV\s0, 3100 \s-1CPU\s0 cycles with AnyEvent's pure perl loop and almost 3000000 \s-1CPU\s0
cycles with \s-1POE\s0.
.PP
\&\f(CW\*(C`EV\*(C'\fR is the sole leader regarding speed and memory use, which are both
maximal/minimal, respectively. When using the \s-1AE\s0 \s-1API\s0 there is zero
overhead (when going through the AnyEvent \s-1API\s0 create is about 5\-6 times
slower, with other times being equal, so still uses far less memory than
any other event loop and is still faster than Event natively).
.PP
The pure perl implementation is hit in a few sweet spots (both the
constant timeout and the use of a single fd hit optimisations in the perl
interpreter and the backend itself). Nevertheless this shows that it
adds very little overhead in itself. Like any select-based backend its
performance becomes really bad with lots of file descriptors (and few of
them active), of course, but this was not subject of this benchmark.
.PP
The \f(CW\*(C`Event\*(C'\fR module has a relatively high setup and callback invocation
cost, but overall scores in on the third place.
.PP
\&\f(CW\*(C`IO::Async\*(C'\fR performs admirably well, about on par with \f(CW\*(C`Event\*(C'\fR, even
when using its pure perl backend.
.PP
\&\f(CW\*(C`Glib\*(C'\fR's memory usage is quite a bit higher, but it features a
faster callback invocation and overall ends up in the same class as
\&\f(CW\*(C`Event\*(C'\fR. However, Glib scales extremely badly, doubling the number of
watchers increases the processing time by more than a factor of four,
making it completely unusable when using larger numbers of watchers
(note that only a single file descriptor was used in the benchmark, so
inefficiencies of \f(CW\*(C`poll\*(C'\fR do not account for this).
.PP
The \f(CW\*(C`Tk\*(C'\fR adaptor works relatively well. The fact that it crashes with
more than 2000 watchers is a big setback, however, as correctness takes
precedence over speed. Nevertheless, its performance is surprising, as the
file descriptor is \fIdup()\fRed for each watcher. This shows that the \fIdup()\fR
employed by some adaptors is not a big performance issue (it does incur a
hidden memory cost inside the kernel which is not reflected in the figures
above).
.PP
\&\f(CW\*(C`POE\*(C'\fR, regardless of underlying event loop (whether using its pure perl
select-based backend or the Event module, the POE-EV backend couldn't
be tested because it wasn't working) shows abysmal performance and
memory usage with AnyEvent: Watchers use almost 30 times as much memory
as \s-1EV\s0 watchers, and 10 times as much memory as Event (the high memory
requirements are caused by requiring a session for each watcher). Watcher
invocation speed is almost 900 times slower than with AnyEvent's pure perl
implementation.
.PP
The design of the \s-1POE\s0 adaptor class in AnyEvent can not really account
for the performance issues, though, as session creation overhead is
small compared to execution of the state machine, which is coded pretty
optimally within AnyEvent::Impl::POE (and while everybody agrees that
using multiple sessions is not a good approach, especially regarding
memory usage, even the author of \s-1POE\s0 could not come up with a faster
design).
.PP
\fISummary\fR
.IX Subsection "Summary"
.IP "\(bu" 4
Using \s-1EV\s0 through AnyEvent is faster than any other event loop
(even when used without AnyEvent), but most event loops have acceptable
performance with or without AnyEvent.
.IP "\(bu" 4
The overhead AnyEvent adds is usually much smaller than the overhead of
the actual event loop, only with extremely fast event loops such as \s-1EV\s0
does AnyEvent add significant overhead.
.IP "\(bu" 4
You should avoid \s-1POE\s0 like the plague if you want performance or
reasonable memory usage.
.SS "\s-1BENCHMARKING\s0 \s-1THE\s0 \s-1LARGE\s0 \s-1SERVER\s0 \s-1CASE\s0"
.IX Subsection "BENCHMARKING THE LARGE SERVER CASE"
This benchmark actually benchmarks the event loop itself. It works by
creating a number of \*(L"servers\*(R": each server consists of a socket pair, a
timeout watcher that gets reset on activity (but never fires), and an I/O
watcher waiting for input on one side of the socket. Each time the socket
watcher reads a byte it will write that byte to a random other \*(L"server\*(R".
.PP
The effect is that there will be a lot of I/O watchers, only part of which
are active at any one point (so there is a constant number of active
fds for each loop iteration, but which fds these are is random). The
timeout is reset each time something is read because that reflects how
most timeouts work (and puts extra pressure on the event loops).
.PP
In this benchmark, we use 10000 socket pairs (20000 sockets), of which 100
(1%) are active. This mirrors the activity of large servers with many
connections, most of which are idle at any one point in time.
.PP
Source code for this benchmark is found as \fIeg/bench2\fR in the AnyEvent
distribution. It uses the \s-1AE\s0 interface, which makes a real difference
for the \s-1EV\s0 and Perl backends only.
.PP
\fIExplanation of the columns\fR
.IX Subsection "Explanation of the columns"
.PP
\&\fIsockets\fR is the number of sockets, and twice the number of \*(L"servers\*(R" (as
each server has a read and write socket end).
.PP
\&\fIcreate\fR is the time it takes to create a socket pair (which is
nontrivial) and two watchers: an I/O watcher and a timeout watcher.
.PP
\&\fIrequest\fR, the most important value, is the time it takes to handle a
single \*(L"request\*(R", that is, reading the token from the pipe and forwarding
it to another server. This includes deleting the old timeout and creating
a new one that moves the timeout into the future.
.PP
\fIResults\fR
.IX Subsection "Results"
.PP
.Vb 8
\&     name sockets create  request 
\&       EV   20000  62.66     7.99 
\&     Perl   20000  68.32    32.64 
\&  IOAsync   20000 174.06   101.15 epoll
\&  IOAsync   20000 174.67   610.84 poll
\&    Event   20000 202.69   242.91 
\&     Glib   20000 557.01  1689.52 
\&      POE   20000 341.54 12086.32 uses POE::Loop::Event
.Ve
.PP
\fIDiscussion\fR
.IX Subsection "Discussion"
.PP
This benchmark \fIdoes\fR measure scalability and overall performance of the
particular event loop.
.PP
\&\s-1EV\s0 is again fastest. Since it is using epoll on my system, the setup time
is relatively high, though.
.PP
Perl surprisingly comes second. It is much faster than the C\-based event
loops Event and Glib.
.PP
IO::Async performs very well when using its epoll backend, and still quite
good compared to Glib when using its pure perl backend.
.PP
Event suffers from high setup time as well (look at its code and you will
understand why). Callback invocation also has a high overhead compared to
the \f(CW\*(C`$_\->() for ..\*(C'\fR\-style loop that the Perl event loop uses. Event
uses select or poll in basically all documented configurations.
.PP
Glib is hit hard by its quadratic behaviour w.r.t. many watchers. It
clearly fails to perform with many filehandles or in busy servers.
.PP
\&\s-1POE\s0 is still completely out of the picture, taking over 1000 times as long
as \s-1EV\s0, and over 100 times as long as the Perl implementation, even though
it uses a C\-based event loop in this case.
.PP
\fISummary\fR
.IX Subsection "Summary"
.IP "\(bu" 4
The pure perl implementation performs extremely well.
.IP "\(bu" 4
Avoid Glib or \s-1POE\s0 in large projects where performance matters.
.SS "\s-1BENCHMARKING\s0 \s-1SMALL\s0 \s-1SERVERS\s0"
.IX Subsection "BENCHMARKING SMALL SERVERS"
While event loops should scale (and select-based ones do not...) even to
large servers, most programs we (or I :) actually write have only a few
I/O watchers.
.PP
In this benchmark, I use the same benchmark program as in the large server
case, but it uses only eight \*(L"servers\*(R", of which three are active at any
one time. This should reflect performance for a small server relatively
well.
.PP
The columns are identical to the previous table.
.PP
\fIResults\fR
.IX Subsection "Results"
.PP
.Vb 6
\&    name sockets create request 
\&      EV      16  20.00    6.54 
\&    Perl      16  25.75   12.62 
\&   Event      16  81.27   35.86 
\&    Glib      16  32.63   15.48 
\&     POE      16 261.87  276.28 uses POE::Loop::Event
.Ve
.PP
\fIDiscussion\fR
.IX Subsection "Discussion"
.PP
The benchmark tries to test the performance of a typical small
server. While knowing how various event loops perform is interesting, keep
in mind that their overhead in this case is usually not as important, due
to the small absolute number of watchers (that is, you need efficiency and
speed most when you have lots of watchers, not when you only have a few of
them).
.PP
\&\s-1EV\s0 is again fastest.
.PP
Perl again comes second. It is noticeably faster than the C\-based event
loops Event and Glib, although the difference is too small to really
matter.
.PP
\&\s-1POE\s0 also performs much better in this case, but is is still far behind the
others.
.PP
\fISummary\fR
.IX Subsection "Summary"
.IP "\(bu" 4
C\-based event loops perform very well with small number of
watchers, as the management overhead dominates.
.SS "\s-1THE\s0 IO::Lambda \s-1BENCHMARK\s0"
.IX Subsection "THE IO::Lambda BENCHMARK"
Recently I was told about the benchmark in the IO::Lambda manpage, which
could be misinterpreted to make AnyEvent look bad. In fact, the benchmark
simply compares IO::Lambda with \s-1POE\s0, and IO::Lambda looks better (which
shouldn't come as a surprise to anybody). As such, the benchmark is
fine, and mostly shows that the AnyEvent backend from IO::Lambda isn't
very optimal. But how would AnyEvent compare when used without the extra
baggage? To explore this, I wrote the equivalent benchmark for AnyEvent.
.PP
The benchmark itself creates an echo-server, and then, for 500 times,
connects to the echo server, sends a line, waits for the reply, and then
creates the next connection. This is a rather bad benchmark, as it doesn't
test the efficiency of the framework or much non-blocking I/O, but it is a
benchmark nevertheless.
.PP
.Vb 9
\&   name                    runtime
\&   Lambda/select           0.330 sec
\&      + optimized          0.122 sec
\&   Lambda/AnyEvent         0.327 sec
\&      + optimized          0.138 sec
\&   Raw sockets/select      0.077 sec
\&   POE/select, components  0.662 sec
\&   POE/select, raw sockets 0.226 sec
\&   POE/select, optimized   0.404 sec
\&
\&   AnyEvent/select/nb      0.085 sec
\&   AnyEvent/EV/nb          0.068 sec
\&      +state machine       0.134 sec
.Ve
.PP
The benchmark is also a bit unfair (my fault): the IO::Lambda/POE
benchmarks actually make blocking connects and use 100% blocking I/O,
defeating the purpose of an event-based solution. All of the newly
written AnyEvent benchmarks use 100% non-blocking connects (using
AnyEvent::Socket::tcp_connect and the asynchronous pure perl \s-1DNS\s0
resolver), so AnyEvent is at a disadvantage here, as non-blocking connects
generally require a lot more bookkeeping and event handling than blocking
connects (which involve a single syscall only).
.PP
The last AnyEvent benchmark additionally uses AnyEvent::Handle, which
offers similar expressive power as \s-1POE\s0 and IO::Lambda, using conventional
Perl syntax. This means that both the echo server and the client are 100%
non-blocking, further placing it at a disadvantage.
.PP
As you can see, the AnyEvent + \s-1EV\s0 combination even beats the
hand-optimised \*(L"raw sockets benchmark\*(R", while AnyEvent + its pure perl
backend easily beats IO::Lambda and \s-1POE\s0.
.PP
And even the 100% non-blocking version written using the high-level (and
slow :) AnyEvent::Handle abstraction beats both \s-1POE\s0 and IO::Lambda
higher level (\*(L"unoptimised\*(R") abstractions by a large margin, even though
it does all of \s-1DNS\s0, tcp-connect and socket I/O in a non-blocking way.
.PP
The two AnyEvent benchmarks programs can be found as \fIeg/ae0.pl\fR and
\&\fIeg/ae2.pl\fR in the AnyEvent distribution, the remaining benchmarks are
part of the IO::Lambda distribution and were used without any changes.
.SH "SIGNALS"
.IX Header "SIGNALS"
AnyEvent currently installs handlers for these signals:
.IP "\s-1SIGCHLD\s0" 4
.IX Item "SIGCHLD"
A handler for \f(CW\*(C`SIGCHLD\*(C'\fR is installed by AnyEvent's child watcher
emulation for event loops that do not support them natively. Also, some
event loops install a similar handler.
.Sp
Additionally, when AnyEvent is loaded and \s-1SIGCHLD\s0 is set to \s-1IGNORE\s0, then
AnyEvent will reset it to default, to avoid losing child exit statuses.
.IP "\s-1SIGPIPE\s0" 4
.IX Item "SIGPIPE"
A no-op handler is installed for \f(CW\*(C`SIGPIPE\*(C'\fR when \f(CW$SIG{PIPE}\fR is \f(CW\*(C`undef\*(C'\fR
when AnyEvent gets loaded.
.Sp
The rationale for this is that AnyEvent users usually do not really depend
on \s-1SIGPIPE\s0 delivery (which is purely an optimisation for shell use, or
badly-written programs), but \f(CW\*(C`SIGPIPE\*(C'\fR can cause spurious and rare
program exits as a lot of people do not expect \f(CW\*(C`SIGPIPE\*(C'\fR when writing to
some random socket.
.Sp
The rationale for installing a no-op handler as opposed to ignoring it is
that this way, the handler will be restored to defaults on exec.
.Sp
Feel free to install your own handler, or reset it to defaults.
.SH "RECOMMENDED/OPTIONAL MODULES"
.IX Header "RECOMMENDED/OPTIONAL MODULES"
One of AnyEvent's main goals is to be 100% Pure\-Perl(tm): only perl (and
its built-in modules) are required to use it.
.PP
That does not mean that AnyEvent won't take advantage of some additional
modules if they are installed.
.PP
This section explains which additional modules will be used, and how they
affect AnyEvent's operation.
.IP "Async::Interrupt" 4
.IX Item "Async::Interrupt"
This slightly arcane module is used to implement fast signal handling: To
my knowledge, there is no way to do completely race-free and quick
signal handling in pure perl. To ensure that signals still get
delivered, AnyEvent will start an interval timer to wake up perl (and
catch the signals) with some delay (default is 10 seconds, look for
\&\f(CW$AnyEvent::MAX_SIGNAL_LATENCY\fR).
.Sp
If this module is available, then it will be used to implement signal
catching, which means that signals will not be delayed, and the event loop
will not be interrupted regularly, which is more efficient (and good for
battery life on laptops).
.Sp
This affects not just the pure-perl event loop, but also other event loops
that have no signal handling on their own (e.g. Glib, Tk, Qt).
.Sp
Some event loops (\s-1POE\s0, Event, Event::Lib) offer signal watchers natively,
and either employ their own workarounds (\s-1POE\s0) or use AnyEvent's workaround
(using \f(CW$AnyEvent::MAX_SIGNAL_LATENCY\fR). Installing Async::Interrupt
does nothing for those backends.
.IP "\s-1EV\s0" 4
.IX Item "EV"
This module isn't really \*(L"optional\*(R", as it is simply one of the backend
event loops that AnyEvent can use. However, it is simply the best event
loop available in terms of features, speed and stability: It supports
the AnyEvent \s-1API\s0 optimally, implements all the watcher types in \s-1XS\s0, does
automatic timer adjustments even when no monotonic clock is available,
can take avdantage of advanced kernel interfaces such as \f(CW\*(C`epoll\*(C'\fR and
\&\f(CW\*(C`kqueue\*(C'\fR, and is the fastest backend \fIby far\fR. You can even embed
Glib/Gtk2 in it (or vice versa, see EV::Glib and Glib::EV).
.Sp
If you only use backends that rely on another event loop (e.g. \f(CW\*(C`Tk\*(C'\fR),
then this module will do nothing for you.
.IP "Guard" 4
.IX Item "Guard"
The guard module, when used, will be used to implement
\&\f(CW\*(C`AnyEvent::Util::guard\*(C'\fR. This speeds up guards considerably (and uses a
lot less memory), but otherwise doesn't affect guard operation much. It is
purely used for performance.
.IP "\s-1JSON\s0 and \s-1JSON::XS\s0" 4
.IX Item "JSON and JSON::XS"
One of these modules is required when you want to read or write \s-1JSON\s0 data
via AnyEvent::Handle. \s-1JSON\s0 is also written in pure-perl, but can take
advantage of the ultra-high-speed \s-1JSON::XS\s0 module when it is installed.
.IP "Net::SSLeay" 4
.IX Item "Net::SSLeay"
Implementing \s-1TLS/SSL\s0 in Perl is certainly interesting, but not very
worthwhile: If this module is installed, then AnyEvent::Handle (with
the help of AnyEvent::TLS), gains the ability to do \s-1TLS/SSL\s0.
.IP "Time::HiRes" 4
.IX Item "Time::HiRes"
This module is part of perl since release 5.008. It will be used when the
chosen event library does not come with a timing source of its own. The
pure-perl event loop (AnyEvent::Loop) will additionally load it to
try to use a monotonic clock for timing stability.
.SH "FORK"
.IX Header "FORK"
Most event libraries are not fork-safe. The ones who are usually are
because they rely on inefficient but fork-safe \f(CW\*(C`select\*(C'\fR or \f(CW\*(C`poll\*(C'\fR calls
\&\- higher performance APIs such as \s-1BSD\s0's kqueue or the dreaded Linux epoll
are usually badly thought-out hacks that are incompatible with fork in
one way or another. Only \s-1EV\s0 is fully fork-aware and ensures that you
continue event-processing in both parent and child (or both, if you know
what you are doing).
.PP
This means that, in general, you cannot fork and do event processing in
the child if the event library was initialised before the fork (which
usually happens when the first AnyEvent watcher is created, or the library
is loaded).
.PP
If you have to fork, you must either do so \fIbefore\fR creating your first
watcher \s-1OR\s0 you must not use AnyEvent at all in the child \s-1OR\s0 you must do
something completely out of the scope of AnyEvent.
.PP
The problem of doing event processing in the parent \fIand\fR the child
is much more complicated: even for backends that \fIare\fR fork-aware or
fork-safe, their behaviour is not usually what you want: fork clones all
watchers, that means all timers, I/O watchers etc. are active in both
parent and child, which is almost never what you want. USing \f(CW\*(C`exec\*(C'\fR
to start worker children from some kind of manage rprocess is usually
preferred, because it is much easier and cleaner, at the expense of having
to have another binary.
.SH "SECURITY CONSIDERATIONS"
.IX Header "SECURITY CONSIDERATIONS"
AnyEvent can be forced to load any event model via
\&\f(CW$ENV\fR{\s-1PERL_ANYEVENT_MODEL\s0}. While this cannot (to my knowledge) be used to
execute arbitrary code or directly gain access, it can easily be used to
make the program hang or malfunction in subtle ways, as AnyEvent watchers
will not be active when the program uses a different event model than
specified in the variable.
.PP
You can make AnyEvent completely ignore this variable by deleting it
before the first watcher gets created, e.g. with a \f(CW\*(C`BEGIN\*(C'\fR block:
.PP
.Vb 1
\&   BEGIN { delete $ENV{PERL_ANYEVENT_MODEL} }
\&  
\&   use AnyEvent;
.Ve
.PP
Similar considerations apply to \f(CW$ENV\fR{\s-1PERL_ANYEVENT_VERBOSE\s0}, as that can
be used to probe what backend is used and gain other information (which is
probably even less useful to an attacker than \s-1PERL_ANYEVENT_MODEL\s0), and
\&\f(CW$ENV\fR{\s-1PERL_ANYEVENT_STRICT\s0}.
.PP
Note that AnyEvent will remove \fIall\fR environment variables starting with
\&\f(CW\*(C`PERL_ANYEVENT_\*(C'\fR from \f(CW%ENV\fR when it is loaded while taint mode is
enabled.
.SH "BUGS"
.IX Header "BUGS"
Perl 5.8 has numerous memleaks that sometimes hit this module and are hard
to work around. If you suffer from memleaks, first upgrade to Perl 5.10
and check wether the leaks still show up. (Perl 5.10.0 has other annoying
memleaks, such as leaking on \f(CW\*(C`map\*(C'\fR and \f(CW\*(C`grep\*(C'\fR but it is usually not as
pronounced).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Tutorial/Introduction: AnyEvent::Intro.
.PP
\&\s-1FAQ:\s0 AnyEvent::FAQ.
.PP
Utility functions: AnyEvent::Util (misc. grab-bag), AnyEvent::Log
(simply logging).
.PP
Development/Debugging: AnyEvent::Strict (stricter checking),
AnyEvent::Debug (interactive shell, watcher tracing).
.PP
Supported event modules: AnyEvent::Loop, \s-1EV\s0, EV::Glib,
Glib::EV, Event, Glib::Event, Glib, Tk, Event::Lib,
Qt, \s-1POE\s0, \s-1FLTK\s0.
.PP
Implementations: AnyEvent::Impl::EV, AnyEvent::Impl::Event,
AnyEvent::Impl::Glib, AnyEvent::Impl::Tk, AnyEvent::Impl::Perl,
AnyEvent::Impl::EventLib, AnyEvent::Impl::Qt,
AnyEvent::Impl::POE, AnyEvent::Impl::IOAsync, Anyevent::Impl::Irssi,
AnyEvent::Impl::FLTK.
.PP
Non-blocking handles, pipes, stream sockets, \s-1TCP\s0 clients and
servers: AnyEvent::Handle, AnyEvent::Socket, AnyEvent::TLS.
.PP
Asynchronous File I/O: AnyEvent::IO.
.PP
Asynchronous \s-1DNS:\s0 AnyEvent::DNS.
.PP
Thread support: Coro, Coro::AnyEvent, Coro::EV, Coro::Event.
.PP
Nontrivial usage examples: AnyEvent::GPSD, AnyEvent::IRC,
AnyEvent::HTTP.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\&   Marc Lehmann <schmorp@schmorp.de>
\&   http://anyevent.schmorp.de
.Ve
