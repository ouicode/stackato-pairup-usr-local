.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent::Handle 3"
.TH AnyEvent::Handle 3 "2012-05-12" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::Handle \- non\-blocking I/O on streaming handles via AnyEvent
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   use AnyEvent;
\&   use AnyEvent::Handle;
\&
\&   my $cv = AnyEvent\->condvar;
\&
\&   my $hdl; $hdl = new AnyEvent::Handle
\&      fh => \e*STDIN,
\&      on_error => sub {
\&         my ($hdl, $fatal, $msg) = @_;
\&         AE::log error => $msg;
\&         $hdl\->destroy;
\&         $cv\->send;
\&      };
\&
\&   # send some request line
\&   $hdl\->push_write ("getinfo\e015\e012");
\&
\&   # read the response line
\&   $hdl\->push_read (line => sub {
\&      my ($hdl, $line) = @_;
\&      say "got line <$line>";
\&      $cv\->send;
\&   });
\&
\&   $cv\->recv;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a helper module to make it easier to do event-based I/O on
stream-based filehandles (sockets, pipes, and other stream things).
.PP
The AnyEvent::Intro tutorial contains some well-documented
AnyEvent::Handle examples.
.PP
In the following, where the documentation refers to \*(L"bytes\*(R", it means
characters. As sysread and syswrite are used for all I/O, their
treatment of characters applies to this module as well.
.PP
At the very minimum, you should specify \f(CW\*(C`fh\*(C'\fR or \f(CW\*(C`connect\*(C'\fR, and the
\&\f(CW\*(C`on_error\*(C'\fR callback.
.PP
All callbacks will be invoked with the handle object as their first
argument.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$handle = \fBnew\fR AnyEvent::Handle fh => $filehandle, key => value..." 4
.el .IP "\f(CW$handle\fR = \fBnew\fR AnyEvent::Handle fh => \f(CW$filehandle\fR, key => value..." 4
.IX Item "$handle = new AnyEvent::Handle fh => $filehandle, key => value..."
The constructor supports these arguments (all as \f(CW\*(C`key => value\*(C'\fR pairs).
.RS 4
.ie n .IP "fh => $filehandle     [""fh"" or ""connect"" \s-1MANDATORY\s0]" 4
.el .IP "fh => \f(CW$filehandle\fR     [\f(CWfh\fR or \f(CWconnect\fR \s-1MANDATORY\s0]" 4
.IX Item "fh => $filehandle     [fh or connect MANDATORY]"
The filehandle this AnyEvent::Handle object will operate on.
\&\s-1NOTE:\s0 The filehandle will be set to non-blocking mode (using
\&\f(CW\*(C`AnyEvent::Util::fh_nonblocking\*(C'\fR) by the constructor and needs to stay in
that mode.
.ie n .IP "connect => [$host, $service]      [""fh"" or ""connect"" \s-1MANDATORY\s0]" 4
.el .IP "connect => [$host, \f(CW$service\fR]      [\f(CWfh\fR or \f(CWconnect\fR \s-1MANDATORY\s0]" 4
.IX Item "connect => [$host, $service]      [fh or connect MANDATORY]"
Try to connect to the specified host and service (port), using
\&\f(CW\*(C`AnyEvent::Socket::tcp_connect\*(C'\fR. The \f(CW$host\fR additionally becomes the
default \f(CW\*(C`peername\*(C'\fR.
.Sp
You have to specify either this parameter, or \f(CW\*(C`fh\*(C'\fR, above.
.Sp
It is possible to push requests on the read and write queues, and modify
properties of the stream, even while AnyEvent::Handle is connecting.
.Sp
When this parameter is specified, then the \f(CW\*(C`on_prepare\*(C'\fR,
\&\f(CW\*(C`on_connect_error\*(C'\fR and \f(CW\*(C`on_connect\*(C'\fR callbacks will be called under the
appropriate circumstances:
.RS 4
.ie n .IP "on_prepare => $cb\->($handle)" 4
.el .IP "on_prepare => \f(CW$cb\fR\->($handle)" 4
.IX Item "on_prepare => $cb->($handle)"
This (rarely used) callback is called before a new connection is
attempted, but after the file handle has been created (you can access that
file handle via \f(CW\*(C`$handle\->{fh}\*(C'\fR). It could be used to prepare the
file handle with parameters required for the actual connect (as opposed to
settings that can be changed when the connection is already established).
.Sp
The return value of this callback should be the connect timeout value in
seconds (or \f(CW0\fR, or \f(CW\*(C`undef\*(C'\fR, or the empty list, to indicate that the
default timeout is to be used).
.ie n .IP "on_connect => $cb\->($handle, $host, $port, $retry\->())" 4
.el .IP "on_connect => \f(CW$cb\fR\->($handle, \f(CW$host\fR, \f(CW$port\fR, \f(CW$retry\fR\->())" 4
.IX Item "on_connect => $cb->($handle, $host, $port, $retry->())"
This callback is called when a connection has been successfully established.
.Sp
The peer's numeric host and port (the socket peername) are passed as
parameters, together with a retry callback. At the time it is called the
read and write queues, \s-1EOF\s0 status, \s-1TLS\s0 status and similar properties of
the handle will have been reset.
.Sp
It is not allowed to use the read or write queues while the handle object
is connecting.
.Sp
If, for some reason, the handle is not acceptable, calling \f(CW$retry\fR will
continue with the next connection target (in case of multi-homed hosts or
\&\s-1SRV\s0 records there can be multiple connection endpoints). The \f(CW$retry\fR
callback can be invoked after the connect callback returns, i.e. one can
start a handshake and then decide to retry with the next host if the
handshake fails.
.Sp
In most cases, you should ignore the \f(CW$retry\fR parameter.
.ie n .IP "on_connect_error => $cb\->($handle, $message)" 4
.el .IP "on_connect_error => \f(CW$cb\fR\->($handle, \f(CW$message\fR)" 4
.IX Item "on_connect_error => $cb->($handle, $message)"
This callback is called when the connection could not be
established. \f(CW$!\fR will contain the relevant error code, and \f(CW$message\fR a
message describing it (usually the same as \f(CW"$!"\fR).
.Sp
If this callback isn't specified, then \f(CW\*(C`on_error\*(C'\fR will be called with a
fatal error instead.
.RE
.RS 4
.RE
.ie n .IP "on_error => $cb\->($handle, $fatal, $message)" 4
.el .IP "on_error => \f(CW$cb\fR\->($handle, \f(CW$fatal\fR, \f(CW$message\fR)" 4
.IX Item "on_error => $cb->($handle, $fatal, $message)"
This is the error callback, which is called when, well, some error
occured, such as not being able to resolve the hostname, failure to
connect, or a read error.
.Sp
Some errors are fatal (which is indicated by \f(CW$fatal\fR being true). On
fatal errors the handle object will be destroyed (by a call to \f(CW\*(C`\->
destroy\*(C'\fR) after invoking the error callback (which means you are free to
examine the handle object). Examples of fatal errors are an \s-1EOF\s0 condition
with active (but unsatisfiable) read watchers (\f(CW\*(C`EPIPE\*(C'\fR) or I/O errors. In
cases where the other side can close the connection at will, it is
often easiest to not report \f(CW\*(C`EPIPE\*(C'\fR errors in this callback.
.Sp
AnyEvent::Handle tries to find an appropriate error code for you to check
against, but in some cases (\s-1TLS\s0 errors), this does not work well.
.Sp
If you report the error to the user, it is recommended to always output
the \f(CW$message\fR argument in human-readable error messages (you don't need
to report \f(CW"$!"\fR if you report \f(CW$message\fR).
.Sp
If you want to react programmatically to the error, then looking at \f(CW$!\fR
and comparing it against some of the documented \f(CW\*(C`Errno\*(C'\fR values is usually
better than looking at the \f(CW$message\fR.
.Sp
Non-fatal errors can be retried by returning, but it is recommended
to simply ignore this parameter and instead abondon the handle object
when this callback is invoked. Examples of non-fatal errors are timeouts
\&\f(CW\*(C`ETIMEDOUT\*(C'\fR) or badly-formatted data (\f(CW\*(C`EBADMSG\*(C'\fR).
.Sp
On entry to the callback, the value of \f(CW$!\fR contains the operating
system error code (or \f(CW\*(C`ENOSPC\*(C'\fR, \f(CW\*(C`EPIPE\*(C'\fR, \f(CW\*(C`ETIMEDOUT\*(C'\fR, \f(CW\*(C`EBADMSG\*(C'\fR or
\&\f(CW\*(C`EPROTO\*(C'\fR).
.Sp
While not mandatory, it is \fIhighly\fR recommended to set this callback, as
you will not be notified of errors otherwise. The default just calls
\&\f(CW\*(C`croak\*(C'\fR.
.ie n .IP "on_read => $cb\->($handle)" 4
.el .IP "on_read => \f(CW$cb\fR\->($handle)" 4
.IX Item "on_read => $cb->($handle)"
This sets the default read callback, which is called when data arrives
and no read request is in the queue (unlike read queue callbacks, this
callback will only be called when at least one octet of data is in the
read buffer).
.Sp
To access (and remove data from) the read buffer, use the \f(CW\*(C`\->rbuf\*(C'\fR
method or access the \f(CW\*(C`$handle\->{rbuf}\*(C'\fR member directly. Note that you
must not enlarge or modify the read buffer, you can only remove data at
the beginning from it.
.Sp
You can also call \f(CW\*(C`\->push_read (...)\*(C'\fR or any other function that
modifies the read queue. Or do both. Or ...
.Sp
When an \s-1EOF\s0 condition is detected, AnyEvent::Handle will first try to
feed all the remaining data to the queued callbacks and \f(CW\*(C`on_read\*(C'\fR before
calling the \f(CW\*(C`on_eof\*(C'\fR callback. If no progress can be made, then a fatal
error will be raised (with \f(CW$!\fR set to \f(CW\*(C`EPIPE\*(C'\fR).
.Sp
Note that, unlike requests in the read queue, an \f(CW\*(C`on_read\*(C'\fR callback
doesn't mean you \fIrequire\fR some data: if there is an \s-1EOF\s0 and there
are outstanding read requests then an error will be flagged. With an
\&\f(CW\*(C`on_read\*(C'\fR callback, the \f(CW\*(C`on_eof\*(C'\fR callback will be invoked.
.ie n .IP "on_eof => $cb\->($handle)" 4
.el .IP "on_eof => \f(CW$cb\fR\->($handle)" 4
.IX Item "on_eof => $cb->($handle)"
Set the callback to be called when an end-of-file condition is detected,
i.e. in the case of a socket, when the other side has closed the
connection cleanly, and there are no outstanding read requests in the
queue (if there are read requests, then an \s-1EOF\s0 counts as an unexpected
connection close and will be flagged as an error).
.Sp
For sockets, this just means that the other side has stopped sending data,
you can still try to write data, and, in fact, one can return from the \s-1EOF\s0
callback and continue writing data, as only the read part has been shut
down.
.Sp
If an \s-1EOF\s0 condition has been detected but no \f(CW\*(C`on_eof\*(C'\fR callback has been
set, then a fatal error will be raised with \f(CW$!\fR set to <0>.
.ie n .IP "on_drain => $cb\->($handle)" 4
.el .IP "on_drain => \f(CW$cb\fR\->($handle)" 4
.IX Item "on_drain => $cb->($handle)"
This sets the callback that is called once when the write buffer becomes
empty (and immediately when the handle object is created).
.Sp
To append to the write buffer, use the \f(CW\*(C`\->push_write\*(C'\fR method.
.Sp
This callback is useful when you don't want to put all of your write data
into the queue at once, for example, when you want to write the contents
of some file to the socket you might not want to read the whole file into
memory and push it into the queue, but instead only read more data from
the file when the write queue becomes empty.
.ie n .IP "timeout => $fractional_seconds" 4
.el .IP "timeout => \f(CW$fractional_seconds\fR" 4
.IX Item "timeout => $fractional_seconds"
.PD 0
.ie n .IP "rtimeout => $fractional_seconds" 4
.el .IP "rtimeout => \f(CW$fractional_seconds\fR" 4
.IX Item "rtimeout => $fractional_seconds"
.ie n .IP "wtimeout => $fractional_seconds" 4
.el .IP "wtimeout => \f(CW$fractional_seconds\fR" 4
.IX Item "wtimeout => $fractional_seconds"
.PD
If non-zero, then these enables an \*(L"inactivity\*(R" timeout: whenever this
many seconds pass without a successful read or write on the underlying
file handle (or a call to \f(CW\*(C`timeout_reset\*(C'\fR), the \f(CW\*(C`on_timeout\*(C'\fR callback
will be invoked (and if that one is missing, a non-fatal \f(CW\*(C`ETIMEDOUT\*(C'\fR
error will be raised).
.Sp
There are three variants of the timeouts that work independently of each
other, for both read and write (triggered when nothing was read \fI\s-1OR\s0\fR
written), just read (triggered when nothing was read), and just write:
\&\f(CW\*(C`timeout\*(C'\fR, \f(CW\*(C`rtimeout\*(C'\fR and \f(CW\*(C`wtimeout\*(C'\fR, with corresponding callbacks
\&\f(CW\*(C`on_timeout\*(C'\fR, \f(CW\*(C`on_rtimeout\*(C'\fR and \f(CW\*(C`on_wtimeout\*(C'\fR, and reset functions
\&\f(CW\*(C`timeout_reset\*(C'\fR, \f(CW\*(C`rtimeout_reset\*(C'\fR, and \f(CW\*(C`wtimeout_reset\*(C'\fR.
.Sp
Note that timeout processing is active even when you do not have any
outstanding read or write requests: If you plan to keep the connection
idle then you should disable the timeout temporarily or ignore the
timeout in the corresponding \f(CW\*(C`on_timeout\*(C'\fR callback, in which case
AnyEvent::Handle will simply restart the timeout.
.Sp
Zero (the default) disables the corresponding timeout.
.ie n .IP "on_timeout => $cb\->($handle)" 4
.el .IP "on_timeout => \f(CW$cb\fR\->($handle)" 4
.IX Item "on_timeout => $cb->($handle)"
.PD 0
.ie n .IP "on_rtimeout => $cb\->($handle)" 4
.el .IP "on_rtimeout => \f(CW$cb\fR\->($handle)" 4
.IX Item "on_rtimeout => $cb->($handle)"
.ie n .IP "on_wtimeout => $cb\->($handle)" 4
.el .IP "on_wtimeout => \f(CW$cb\fR\->($handle)" 4
.IX Item "on_wtimeout => $cb->($handle)"
.PD
Called whenever the inactivity timeout passes. If you return from this
callback, then the timeout will be reset as if some activity had happened,
so this condition is not fatal in any way.
.IP "rbuf_max => <bytes>" 4
.IX Item "rbuf_max => <bytes>"
If defined, then a fatal error will be raised (with \f(CW$!\fR set to \f(CW\*(C`ENOSPC\*(C'\fR)
when the read buffer ever (strictly) exceeds this size. This is useful to
avoid some forms of denial-of-service attacks.
.Sp
For example, a server accepting connections from untrusted sources should
be configured to accept only so-and-so much data that it cannot act on
(for example, when expecting a line, an attacker could send an unlimited
amount of data without a callback ever being called as long as the line
isn't finished).
.IP "wbuf_max => <bytes>" 4
.IX Item "wbuf_max => <bytes>"
If defined, then a fatal error will be raised (with \f(CW$!\fR set to \f(CW\*(C`ENOSPC\*(C'\fR)
when the write buffer ever (strictly) exceeds this size. This is useful to
avoid some forms of denial-of-service attacks.
.Sp
Although the units of this parameter is bytes, this is the \fIraw\fR number
of bytes not yet accepted by the kernel. This can make a difference when
you e.g. use \s-1TLS\s0, as \s-1TLS\s0 typically makes your write data larger (but it
can also make it smaller due to compression).
.Sp
As an example of when this limit is useful, take a chat server that sends
chat messages to a client. If the client does not read those in a timely
manner then the send buffer in the server would grow unbounded.
.IP "autocork => <boolean>" 4
.IX Item "autocork => <boolean>"
When disabled (the default), \f(CW\*(C`push_write\*(C'\fR will try to immediately
write the data to the handle if possible. This avoids having to register
a write watcher and wait for the next event loop iteration, but can
be inefficient if you write multiple small chunks (on the wire, this
disadvantage is usually avoided by your kernel's nagle algorithm, see
\&\f(CW\*(C`no_delay\*(C'\fR, but this option can save costly syscalls).
.Sp
When enabled, writes will always be queued till the next event loop
iteration. This is efficient when you do many small writes per iteration,
but less efficient when you do a single write only per iteration (or when
the write buffer often is full). It also increases write latency.
.IP "no_delay => <boolean>" 4
.IX Item "no_delay => <boolean>"
When doing small writes on sockets, your operating system kernel might
wait a bit for more data before actually sending it out. This is called
the Nagle algorithm, and usually it is beneficial.
.Sp
In some situations you want as low a delay as possible, which can be
accomplishd by setting this option to a true value.
.Sp
The default is your operating system's default behaviour (most likely
enabled). This option explicitly enables or disables it, if possible.
.IP "keepalive => <boolean>" 4
.IX Item "keepalive => <boolean>"
Enables (default disable) the \s-1SO_KEEPALIVE\s0 option on the stream socket:
normally, \s-1TCP\s0 connections have no time-out once established, so \s-1TCP\s0
connections, once established, can stay alive forever even when the other
side has long gone. \s-1TCP\s0 keepalives are a cheap way to take down long-lived
\&\s-1TCP\s0 connections when the other side becomes unreachable. While the default
is OS-dependent, \s-1TCP\s0 keepalives usually kick in after around two hours,
and, if the other side doesn't reply, take down the \s-1TCP\s0 connection some 10
to 15 minutes later.
.Sp
It is harmless to specify this option for file handles that do not support
keepalives, and enabling it on connections that are potentially long-lived
is usually a good idea.
.IP "oobinline => <boolean>" 4
.IX Item "oobinline => <boolean>"
\&\s-1BSD\s0 majorly fucked up the implementation of \s-1TCP\s0 urgent data. The result
is that almost no \s-1OS\s0 implements \s-1TCP\s0 according to the specs, and every \s-1OS\s0
implements it slightly differently.
.Sp
If you want to handle \s-1TCP\s0 urgent data, then setting this flag (the default
is enabled) gives you the most portable way of getting urgent data, by
putting it into the stream.
.Sp
Since \s-1BSD\s0 emulation of \s-1OOB\s0 data on top of \s-1TCP\s0's urgent data can have
security implications, AnyEvent::Handle sets this flag automatically
unless explicitly specified. Note that setting this flag after
establishing a connection \fImay\fR be a bit too late (data loss could
already have occured on \s-1BSD\s0 systems), but at least it will protect you
from most attacks.
.IP "read_size => <bytes>" 4
.IX Item "read_size => <bytes>"
The initial read block size, the number of bytes this module will try
to read during each loop iteration. Each handle object will consume
at least this amount of memory for the read buffer as well, so when
handling many connections watch out for memory requirements). See also
\&\f(CW\*(C`max_read_size\*(C'\fR. Default: \f(CW2048\fR.
.IP "max_read_size => <bytes>" 4
.IX Item "max_read_size => <bytes>"
The maximum read buffer size used by the dynamic adjustment
algorithm: Each time AnyEvent::Handle can read \f(CW\*(C`read_size\*(C'\fR bytes in
one go it will double \f(CW\*(C`read_size\*(C'\fR up to the maximum given by this
option. Default: \f(CW131072\fR or \f(CW\*(C`read_size\*(C'\fR, whichever is higher.
.IP "low_water_mark => <bytes>" 4
.IX Item "low_water_mark => <bytes>"
Sets the number of bytes (default: \f(CW0\fR) that make up an \*(L"empty\*(R" write
buffer: If the buffer reaches this size or gets even samller it is
considered empty.
.Sp
Sometimes it can be beneficial (for performance reasons) to add data to
the write buffer before it is fully drained, but this is a rare case, as
the operating system kernel usually buffers data as well, so the default
is good in almost all cases.
.IP "linger => <seconds>" 4
.IX Item "linger => <seconds>"
If this is non-zero (default: \f(CW3600\fR), the destructor of the
AnyEvent::Handle object will check whether there is still outstanding
write data and will install a watcher that will write this data to the
socket. No errors will be reported (this mostly matches how the operating
system treats outstanding data at socket close time).
.Sp
This will not work for partial \s-1TLS\s0 data that could not be encoded
yet. This data will be lost. Calling the \f(CW\*(C`stoptls\*(C'\fR method in time might
help.
.ie n .IP "peername => $string" 4
.el .IP "peername => \f(CW$string\fR" 4
.IX Item "peername => $string"
A string used to identify the remote site \- usually the \s-1DNS\s0 hostname
(\fInot\fR \s-1IDN\s0!) used to create the connection, rarely the \s-1IP\s0 address.
.Sp
Apart from being useful in error messages, this string is also used in \s-1TLS\s0
peername verification (see \f(CW\*(C`verify_peername\*(C'\fR in AnyEvent::TLS). This
verification will be skipped when \f(CW\*(C`peername\*(C'\fR is not specified or is
\&\f(CW\*(C`undef\*(C'\fR.
.ie n .IP "tls => ""accept"" | ""connect"" | Net::SSLeay::SSL object" 4
.el .IP "tls => ``accept'' | ``connect'' | Net::SSLeay::SSL object" 4
.IX Item "tls => accept | connect | Net::SSLeay::SSL object"
When this parameter is given, it enables \s-1TLS\s0 (\s-1SSL\s0) mode, that means
AnyEvent will start a \s-1TLS\s0 handshake as soon as the connection has been
established and will transparently encrypt/decrypt data afterwards.
.Sp
All \s-1TLS\s0 protocol errors will be signalled as \f(CW\*(C`EPROTO\*(C'\fR, with an
appropriate error message.
.Sp
\&\s-1TLS\s0 mode requires Net::SSLeay to be installed (it will be loaded
automatically when you try to create a \s-1TLS\s0 handle): this module doesn't
have a dependency on that module, so if your module requires it, you have
to add the dependency yourself. If Net::SSLeay cannot be loaded or is too
old, you get an \f(CW\*(C`EPROTO\*(C'\fR error.
.Sp
Unlike \s-1TCP\s0, \s-1TLS\s0 has a server and client side: for the \s-1TLS\s0 server side, use
\&\f(CW\*(C`accept\*(C'\fR, and for the \s-1TLS\s0 client side of a connection, use \f(CW\*(C`connect\*(C'\fR
mode.
.Sp
You can also provide your own \s-1TLS\s0 connection object, but you have
to make sure that you call either \f(CW\*(C`Net::SSLeay::set_connect_state\*(C'\fR
or \f(CW\*(C`Net::SSLeay::set_accept_state\*(C'\fR on it before you pass it to
AnyEvent::Handle. Also, this module will take ownership of this connection
object.
.Sp
At some future point, AnyEvent::Handle might switch to another \s-1TLS\s0
implementation, then the option to use your own session object will go
away.
.Sp
\&\fB\s-1IMPORTANT:\s0\fR since Net::SSLeay \*(L"objects\*(R" are really only integers,
passing in the wrong integer will lead to certain crash. This most often
happens when one uses a stylish \f(CW\*(C`tls => 1\*(C'\fR and is surprised about the
segmentation fault.
.Sp
Use the \f(CW\*(C`\->starttls\*(C'\fR method if you need to start \s-1TLS\s0 negotiation later.
.ie n .IP "tls_ctx => $anyevent_tls" 4
.el .IP "tls_ctx => \f(CW$anyevent_tls\fR" 4
.IX Item "tls_ctx => $anyevent_tls"
Use the given \f(CW\*(C`AnyEvent::TLS\*(C'\fR object to create the new \s-1TLS\s0 connection
(unless a connection object was specified directly). If this
parameter is missing (or \f(CW\*(C`undef\*(C'\fR), then AnyEvent::Handle will use
\&\f(CW\*(C`AnyEvent::Handle::TLS_CTX\*(C'\fR.
.Sp
Instead of an object, you can also specify a hash reference with \f(CW\*(C`key
=> value\*(C'\fR pairs. Those will be passed to AnyEvent::TLS to create a
new \s-1TLS\s0 context object.
.ie n .IP "on_starttls => $cb\->($handle, $success[, $error_message])" 4
.el .IP "on_starttls => \f(CW$cb\fR\->($handle, \f(CW$success\fR[, \f(CW$error_message\fR])" 4
.IX Item "on_starttls => $cb->($handle, $success[, $error_message])"
This callback will be invoked when the \s-1TLS/SSL\s0 handshake has finished. If
\&\f(CW$success\fR is true, then the \s-1TLS\s0 handshake succeeded, otherwise it failed
(\f(CW\*(C`on_stoptls\*(C'\fR will not be called in this case).
.Sp
The session in \f(CW\*(C`$handle\->{tls}\*(C'\fR can still be examined in this
callback, even when the handshake was not successful.
.Sp
\&\s-1TLS\s0 handshake failures will not cause \f(CW\*(C`on_error\*(C'\fR to be invoked when this
callback is in effect, instead, the error message will be passed to \f(CW\*(C`on_starttls\*(C'\fR.
.Sp
Without this callback, handshake failures lead to \f(CW\*(C`on_error\*(C'\fR being
called as usual.
.Sp
Note that you cannot just call \f(CW\*(C`starttls\*(C'\fR again in this callback. If you
need to do that, start an zero-second timer instead whose callback can
then call \f(CW\*(C`\->starttls\*(C'\fR again.
.ie n .IP "on_stoptls => $cb\->($handle)" 4
.el .IP "on_stoptls => \f(CW$cb\fR\->($handle)" 4
.IX Item "on_stoptls => $cb->($handle)"
When a SSLv3/TLS shutdown/close notify/EOF is detected and this callback is
set, then it will be invoked after freeing the \s-1TLS\s0 session. If it is not,
then a \s-1TLS\s0 shutdown condition will be treated like a normal \s-1EOF\s0 condition
on the handle.
.Sp
The session in \f(CW\*(C`$handle\->{tls}\*(C'\fR can still be examined in this
callback.
.Sp
This callback will only be called on \s-1TLS\s0 shutdowns, not when the
underlying handle signals \s-1EOF\s0.
.IP "json => \s-1JSON\s0 or \s-1JSON::XS\s0 object" 4
.IX Item "json => JSON or JSON::XS object"
This is the json coder object used by the \f(CW\*(C`json\*(C'\fR read and write types.
.Sp
If you don't supply it, then AnyEvent::Handle will create and use a
suitable one (on demand), which will write and expect \s-1UTF\-8\s0 encoded \s-1JSON\s0
texts.
.Sp
Note that you are responsible to depend on the \s-1JSON\s0 module if you want to
use this functionality, as AnyEvent does not have a dependency itself.
.RE
.RS 4
.RE
.ie n .IP "$fh = $handle\->fh" 4
.el .IP "\f(CW$fh\fR = \f(CW$handle\fR\->fh" 4
.IX Item "$fh = $handle->fh"
This method returns the file handle used to create the AnyEvent::Handle object.
.ie n .IP "$handle\->on_error ($cb)" 4
.el .IP "\f(CW$handle\fR\->on_error ($cb)" 4
.IX Item "$handle->on_error ($cb)"
Replace the current \f(CW\*(C`on_error\*(C'\fR callback (see the \f(CW\*(C`on_error\*(C'\fR constructor argument).
.ie n .IP "$handle\->on_eof ($cb)" 4
.el .IP "\f(CW$handle\fR\->on_eof ($cb)" 4
.IX Item "$handle->on_eof ($cb)"
Replace the current \f(CW\*(C`on_eof\*(C'\fR callback (see the \f(CW\*(C`on_eof\*(C'\fR constructor argument).
.ie n .IP "$handle\->on_timeout ($cb)" 4
.el .IP "\f(CW$handle\fR\->on_timeout ($cb)" 4
.IX Item "$handle->on_timeout ($cb)"
.PD 0
.ie n .IP "$handle\->on_rtimeout ($cb)" 4
.el .IP "\f(CW$handle\fR\->on_rtimeout ($cb)" 4
.IX Item "$handle->on_rtimeout ($cb)"
.ie n .IP "$handle\->on_wtimeout ($cb)" 4
.el .IP "\f(CW$handle\fR\->on_wtimeout ($cb)" 4
.IX Item "$handle->on_wtimeout ($cb)"
.PD
Replace the current \f(CW\*(C`on_timeout\*(C'\fR, \f(CW\*(C`on_rtimeout\*(C'\fR or \f(CW\*(C`on_wtimeout\*(C'\fR
callback, or disables the callback (but not the timeout) if \f(CW$cb\fR =
\&\f(CW\*(C`undef\*(C'\fR. See the \f(CW\*(C`timeout\*(C'\fR constructor argument and method.
.ie n .IP "$handle\->autocork ($boolean)" 4
.el .IP "\f(CW$handle\fR\->autocork ($boolean)" 4
.IX Item "$handle->autocork ($boolean)"
Enables or disables the current autocork behaviour (see \f(CW\*(C`autocork\*(C'\fR
constructor argument). Changes will only take effect on the next write.
.ie n .IP "$handle\->no_delay ($boolean)" 4
.el .IP "\f(CW$handle\fR\->no_delay ($boolean)" 4
.IX Item "$handle->no_delay ($boolean)"
Enables or disables the \f(CW\*(C`no_delay\*(C'\fR setting (see constructor argument of
the same name for details).
.ie n .IP "$handle\->keepalive ($boolean)" 4
.el .IP "\f(CW$handle\fR\->keepalive ($boolean)" 4
.IX Item "$handle->keepalive ($boolean)"
Enables or disables the \f(CW\*(C`keepalive\*(C'\fR setting (see constructor argument of
the same name for details).
.ie n .IP "$handle\->oobinline ($boolean)" 4
.el .IP "\f(CW$handle\fR\->oobinline ($boolean)" 4
.IX Item "$handle->oobinline ($boolean)"
Enables or disables the \f(CW\*(C`oobinline\*(C'\fR setting (see constructor argument of
the same name for details).
.ie n .IP "$handle\->keepalive ($boolean)" 4
.el .IP "\f(CW$handle\fR\->keepalive ($boolean)" 4
.IX Item "$handle->keepalive ($boolean)"
Enables or disables the \f(CW\*(C`keepalive\*(C'\fR setting (see constructor argument of
the same name for details).
.ie n .IP "$handle\->on_starttls ($cb)" 4
.el .IP "\f(CW$handle\fR\->on_starttls ($cb)" 4
.IX Item "$handle->on_starttls ($cb)"
Replace the current \f(CW\*(C`on_starttls\*(C'\fR callback (see the \f(CW\*(C`on_starttls\*(C'\fR constructor argument).
.ie n .IP "$handle\->on_stoptls ($cb)" 4
.el .IP "\f(CW$handle\fR\->on_stoptls ($cb)" 4
.IX Item "$handle->on_stoptls ($cb)"
Replace the current \f(CW\*(C`on_stoptls\*(C'\fR callback (see the \f(CW\*(C`on_stoptls\*(C'\fR constructor argument).
.ie n .IP "$handle\->rbuf_max ($max_octets)" 4
.el .IP "\f(CW$handle\fR\->rbuf_max ($max_octets)" 4
.IX Item "$handle->rbuf_max ($max_octets)"
Configures the \f(CW\*(C`rbuf_max\*(C'\fR setting (\f(CW\*(C`undef\*(C'\fR disables it).
.ie n .IP "$handle\->wbuf_max ($max_octets)" 4
.el .IP "\f(CW$handle\fR\->wbuf_max ($max_octets)" 4
.IX Item "$handle->wbuf_max ($max_octets)"
Configures the \f(CW\*(C`wbuf_max\*(C'\fR setting (\f(CW\*(C`undef\*(C'\fR disables it).
.ie n .IP "$handle\->timeout ($seconds)" 4
.el .IP "\f(CW$handle\fR\->timeout ($seconds)" 4
.IX Item "$handle->timeout ($seconds)"
.PD 0
.ie n .IP "$handle\->rtimeout ($seconds)" 4
.el .IP "\f(CW$handle\fR\->rtimeout ($seconds)" 4
.IX Item "$handle->rtimeout ($seconds)"
.ie n .IP "$handle\->wtimeout ($seconds)" 4
.el .IP "\f(CW$handle\fR\->wtimeout ($seconds)" 4
.IX Item "$handle->wtimeout ($seconds)"
.PD
Configures (or disables) the inactivity timeout.
.Sp
The timeout will be checked instantly, so this method might destroy the
handle before it returns.
.ie n .IP "$handle\->timeout_reset" 4
.el .IP "\f(CW$handle\fR\->timeout_reset" 4
.IX Item "$handle->timeout_reset"
.PD 0
.ie n .IP "$handle\->rtimeout_reset" 4
.el .IP "\f(CW$handle\fR\->rtimeout_reset" 4
.IX Item "$handle->rtimeout_reset"
.ie n .IP "$handle\->wtimeout_reset" 4
.el .IP "\f(CW$handle\fR\->wtimeout_reset" 4
.IX Item "$handle->wtimeout_reset"
.PD
Reset the activity timeout, as if data was received or sent.
.Sp
These methods are cheap to call.
.SS "\s-1WRITE\s0 \s-1QUEUE\s0"
.IX Subsection "WRITE QUEUE"
AnyEvent::Handle manages two queues per handle, one for writing and one
for reading.
.PP
The write queue is very simple: you can add data to its end, and
AnyEvent::Handle will automatically try to get rid of it for you.
.PP
When data could be written and the write buffer is shorter then the low
water mark, the \f(CW\*(C`on_drain\*(C'\fR callback will be invoked once.
.ie n .IP "$handle\->on_drain ($cb)" 4
.el .IP "\f(CW$handle\fR\->on_drain ($cb)" 4
.IX Item "$handle->on_drain ($cb)"
Sets the \f(CW\*(C`on_drain\*(C'\fR callback or clears it (see the description of
\&\f(CW\*(C`on_drain\*(C'\fR in the constructor).
.Sp
This method may invoke callbacks (and therefore the handle might be
destroyed after it returns).
.ie n .IP "$handle\->push_write ($data)" 4
.el .IP "\f(CW$handle\fR\->push_write ($data)" 4
.IX Item "$handle->push_write ($data)"
Queues the given scalar to be written. You can push as much data as
you want (only limited by the available memory and \f(CW\*(C`wbuf_max\*(C'\fR), as
\&\f(CW\*(C`AnyEvent::Handle\*(C'\fR buffers it independently of the kernel.
.Sp
This method may invoke callbacks (and therefore the handle might be
destroyed after it returns).
.ie n .IP "$handle\->push_write (type => @args)" 4
.el .IP "\f(CW$handle\fR\->push_write (type => \f(CW@args\fR)" 4
.IX Item "$handle->push_write (type => @args)"
Instead of formatting your data yourself, you can also let this module
do the job by specifying a type and type-specific arguments. You
can also specify the (fully qualified) name of a package, in which
case AnyEvent tries to load the package and then expects to find the
\&\f(CW\*(C`anyevent_write_type\*(C'\fR function inside (see \*(L"custom write types\*(R", below).
.Sp
Predefined types are (if you have ideas for additional types, feel free to
drop by and tell us):
.RS 4
.ie n .IP "netstring => $string" 4
.el .IP "netstring => \f(CW$string\fR" 4
.IX Item "netstring => $string"
Formats the given value as netstring
(http://cr.yp.to/proto/netstrings.txt, this is not a recommendation to use them).
.ie n .IP "packstring => $format, $data" 4
.el .IP "packstring => \f(CW$format\fR, \f(CW$data\fR" 4
.IX Item "packstring => $format, $data"
An octet string prefixed with an encoded length. The encoding \f(CW$format\fR
uses the same format as a Perl \f(CW\*(C`pack\*(C'\fR format, but must specify a single
integer only (only one of \f(CW\*(C`cCsSlLqQiInNvVjJw\*(C'\fR is allowed, plus an
optional \f(CW\*(C`!\*(C'\fR, \f(CW\*(C`<\*(C'\fR or \f(CW\*(C`>\*(C'\fR modifier).
.ie n .IP "json => $array_or_hashref" 4
.el .IP "json => \f(CW$array_or_hashref\fR" 4
.IX Item "json => $array_or_hashref"
Encodes the given hash or array reference into a \s-1JSON\s0 object. Unless you
provide your own \s-1JSON\s0 object, this means it will be encoded to \s-1JSON\s0 text
in \s-1UTF\-8\s0.
.Sp
\&\s-1JSON\s0 objects (and arrays) are self-delimiting, so you can write \s-1JSON\s0 at
one end of a handle and read them at the other end without using any
additional framing.
.Sp
The generated \s-1JSON\s0 text is guaranteed not to contain any newlines: While
this module doesn't need delimiters after or between \s-1JSON\s0 texts to be
able to read them, many other languages depend on that.
.Sp
A simple \s-1RPC\s0 protocol that interoperates easily with others is to send
\&\s-1JSON\s0 arrays (or objects, although arrays are usually the better choice as
they mimic how function argument passing works) and a newline after each
\&\s-1JSON\s0 text:
.Sp
.Vb 2
\&   $handle\->push_write (json => ["method", "arg1", "arg2"]); # whatever
\&   $handle\->push_write ("\e012");
.Ve
.Sp
An AnyEvent::Handle receiver would simply use the \f(CW\*(C`json\*(C'\fR read type and
rely on the fact that the newline will be skipped as leading whitespace:
.Sp
.Vb 1
\&   $handle\->push_read (json => sub { my $array = $_[1]; ... });
.Ve
.Sp
Other languages could read single lines terminated by a newline and pass
this line into their \s-1JSON\s0 decoder of choice.
.ie n .IP "storable => $reference" 4
.el .IP "storable => \f(CW$reference\fR" 4
.IX Item "storable => $reference"
Freezes the given reference using Storable and writes it to the
handle. Uses the \f(CW\*(C`nfreeze\*(C'\fR format.
.RE
.RS 4
.RE
.ie n .IP "$handle\->push_shutdown" 4
.el .IP "\f(CW$handle\fR\->push_shutdown" 4
.IX Item "$handle->push_shutdown"
Sometimes you know you want to close the socket after writing your data
before it was actually written. One way to do that is to replace your
\&\f(CW\*(C`on_drain\*(C'\fR handler by a callback that shuts down the socket (and set
\&\f(CW\*(C`low_water_mark\*(C'\fR to \f(CW0\fR). This method is a shorthand for just that, and
replaces the \f(CW\*(C`on_drain\*(C'\fR callback with:
.Sp
.Vb 1
\&   sub { shutdown $_[0]{fh}, 1 }
.Ve
.Sp
This simply shuts down the write side and signals an \s-1EOF\s0 condition to the
the peer.
.Sp
You can rely on the normal read queue and \f(CW\*(C`on_eof\*(C'\fR handling
afterwards. This is the cleanest way to close a connection.
.Sp
This method may invoke callbacks (and therefore the handle might be
destroyed after it returns).
.ie n .IP "custom write types \- Package::anyevent_write_type $handle, @args" 4
.el .IP "custom write types \- Package::anyevent_write_type \f(CW$handle\fR, \f(CW@args\fR" 4
.IX Item "custom write types - Package::anyevent_write_type $handle, @args"
Instead of one of the predefined types, you can also specify the name of
a package. AnyEvent will try to load the package and then expects to find
a function named \f(CW\*(C`anyevent_write_type\*(C'\fR inside. If it isn't found, it
progressively tries to load the parent package until it either finds the
function (good) or runs out of packages (bad).
.Sp
Whenever the given \f(CW\*(C`type\*(C'\fR is used, \f(CW\*(C`push_write\*(C'\fR will the function with
the handle object and the remaining arguments.
.Sp
The function is supposed to return a single octet string that will be
appended to the write buffer, so you can mentally treat this function as a
\&\*(L"arguments to on-the-wire-format\*(R" converter.
.Sp
Example: implement a custom write type \f(CW\*(C`join\*(C'\fR that joins the remaining
arguments using the first one.
.Sp
.Vb 1
\&   $handle\->push_write (My::Type => " ", 1,2,3);
\&
\&   # uses the following package, which can be defined in the "My::Type" or in
\&   # the "My" modules to be auto\-loaded, or just about anywhere when the
\&   # My::Type::anyevent_write_type is defined before invoking it.
\&
\&   package My::Type;
\&
\&   sub anyevent_write_type {
\&      my ($handle, $delim, @args) = @_;
\&
\&      join $delim, @args
\&   }
.Ve
.SS "\s-1READ\s0 \s-1QUEUE\s0"
.IX Subsection "READ QUEUE"
AnyEvent::Handle manages two queues per handle, one for writing and one
for reading.
.PP
The read queue is more complex than the write queue. It can be used in two
ways, the \*(L"simple\*(R" way, using only \f(CW\*(C`on_read\*(C'\fR and the \*(L"complex\*(R" way, using
a queue.
.PP
In the simple case, you just install an \f(CW\*(C`on_read\*(C'\fR callback and whenever
new data arrives, it will be called. You can then remove some data (if
enough is there) from the read buffer (\f(CW\*(C`$handle\->rbuf\*(C'\fR). Or you can
leave the data there if you want to accumulate more (e.g. when only a
partial message has been received so far), or change the read queue with
e.g. \f(CW\*(C`push_read\*(C'\fR.
.PP
In the more complex case, you want to queue multiple callbacks. In this
case, AnyEvent::Handle will call the first queued callback each time new
data arrives (also the first time it is queued) and remove it when it has
done its job (see \f(CW\*(C`push_read\*(C'\fR, below).
.PP
This way you can, for example, push three line-reads, followed by reading
a chunk of data, and AnyEvent::Handle will execute them in order.
.PP
Example 1: \s-1EPP\s0 protocol parser. \s-1EPP\s0 sends 4 byte length info, followed by
the specified number of bytes which give an \s-1XML\s0 datagram.
.PP
.Vb 6
\&   # in the default state, expect some header bytes
\&   $handle\->on_read (sub {
\&      # some data is here, now queue the length\-header\-read (4 octets)
\&      shift\->unshift_read (chunk => 4, sub {
\&         # header arrived, decode
\&         my $len = unpack "N", $_[1];
\&
\&         # now read the payload
\&         shift\->unshift_read (chunk => $len, sub {
\&            my $xml = $_[1];
\&            # handle xml
\&         });
\&      });
\&   });
.Ve
.PP
Example 2: Implement a client for a protocol that replies either with \*(L"\s-1OK\s0\*(R"
and another line or \*(L"\s-1ERROR\s0\*(R" for the first request that is sent, and 64
bytes for the second request. Due to the availability of a queue, we can
just pipeline sending both requests and manipulate the queue as necessary
in the callbacks.
.PP
When the first callback is called and sees an \*(L"\s-1OK\s0\*(R" response, it will
\&\f(CW\*(C`unshift\*(C'\fR another line-read. This line-read will be queued \fIbefore\fR the
64\-byte chunk callback.
.PP
.Vb 2
\&   # request one, returns either "OK + extra line" or "ERROR"
\&   $handle\->push_write ("request 1\e015\e012");
\&
\&   # we expect "ERROR" or "OK" as response, so push a line read
\&   $handle\->push_read (line => sub {
\&      # if we got an "OK", we have to _prepend_ another line,
\&      # so it will be read before the second request reads its 64 bytes
\&      # which are already in the queue when this callback is called
\&      # we don\*(Aqt do this in case we got an error
\&      if ($_[1] eq "OK") {
\&         $_[0]\->unshift_read (line => sub {
\&            my $response = $_[1];
\&            ...
\&         });
\&      }
\&   });
\&
\&   # request two, simply returns 64 octets
\&   $handle\->push_write ("request 2\e015\e012");
\&
\&   # simply read 64 bytes, always
\&   $handle\->push_read (chunk => 64, sub {
\&      my $response = $_[1];
\&      ...
\&   });
.Ve
.ie n .IP "$handle\->on_read ($cb)" 4
.el .IP "\f(CW$handle\fR\->on_read ($cb)" 4
.IX Item "$handle->on_read ($cb)"
This replaces the currently set \f(CW\*(C`on_read\*(C'\fR callback, or clears it (when
the new callback is \f(CW\*(C`undef\*(C'\fR). See the description of \f(CW\*(C`on_read\*(C'\fR in the
constructor.
.Sp
This method may invoke callbacks (and therefore the handle might be
destroyed after it returns).
.ie n .IP "$handle\->rbuf" 4
.el .IP "\f(CW$handle\fR\->rbuf" 4
.IX Item "$handle->rbuf"
Returns the read buffer (as a modifiable lvalue). You can also access the
read buffer directly as the \f(CW\*(C`\->{rbuf}\*(C'\fR member, if you want (this is
much faster, and no less clean).
.Sp
The only operation allowed on the read buffer (apart from looking at it)
is removing data from its beginning. Otherwise modifying or appending to
it is not allowed and will lead to hard-to-track-down bugs.
.Sp
\&\s-1NOTE:\s0 The read buffer should only be used or modified in the \f(CW\*(C`on_read\*(C'\fR
callback or when \f(CW\*(C`push_read\*(C'\fR or \f(CW\*(C`unshift_read\*(C'\fR are used with a single
callback (i.e. untyped). Typed \f(CW\*(C`push_read\*(C'\fR and \f(CW\*(C`unshift_read\*(C'\fR methods
will manage the read buffer on their own.
.ie n .IP "$handle\->push_read ($cb)" 4
.el .IP "\f(CW$handle\fR\->push_read ($cb)" 4
.IX Item "$handle->push_read ($cb)"
.PD 0
.ie n .IP "$handle\->unshift_read ($cb)" 4
.el .IP "\f(CW$handle\fR\->unshift_read ($cb)" 4
.IX Item "$handle->unshift_read ($cb)"
.PD
Append the given callback to the end of the queue (\f(CW\*(C`push_read\*(C'\fR) or
prepend it (\f(CW\*(C`unshift_read\*(C'\fR).
.Sp
The callback is called each time some additional read data arrives.
.Sp
It must check whether enough data is in the read buffer already.
.Sp
If not enough data is available, it must return the empty list or a false
value, in which case it will be called repeatedly until enough data is
available (or an error condition is detected).
.Sp
If enough data was available, then the callback must remove all data it is
interested in (which can be none at all) and return a true value. After returning
true, it will be removed from the queue.
.Sp
These methods may invoke callbacks (and therefore the handle might be
destroyed after it returns).
.ie n .IP "$handle\->push_read (type => @args, $cb)" 4
.el .IP "\f(CW$handle\fR\->push_read (type => \f(CW@args\fR, \f(CW$cb\fR)" 4
.IX Item "$handle->push_read (type => @args, $cb)"
.PD 0
.ie n .IP "$handle\->unshift_read (type => @args, $cb)" 4
.el .IP "\f(CW$handle\fR\->unshift_read (type => \f(CW@args\fR, \f(CW$cb\fR)" 4
.IX Item "$handle->unshift_read (type => @args, $cb)"
.PD
Instead of providing a callback that parses the data itself you can chose
between a number of predefined parsing formats, for chunks of data, lines
etc. You can also specify the (fully qualified) name of a package, in
which case AnyEvent tries to load the package and then expects to find the
\&\f(CW\*(C`anyevent_read_type\*(C'\fR function inside (see \*(L"custom read types\*(R", below).
.Sp
Predefined types are (if you have ideas for additional types, feel free to
drop by and tell us):
.RS 4
.ie n .IP "chunk => $octets, $cb\->($handle, $data)" 4
.el .IP "chunk => \f(CW$octets\fR, \f(CW$cb\fR\->($handle, \f(CW$data\fR)" 4
.IX Item "chunk => $octets, $cb->($handle, $data)"
Invoke the callback only once \f(CW$octets\fR bytes have been read. Pass the
data read to the callback. The callback will never be called with less
data.
.Sp
Example: read 2 bytes.
.Sp
.Vb 3
\&   $handle\->push_read (chunk => 2, sub {
\&      say "yay " . unpack "H*", $_[1];
\&   });
.Ve
.ie n .IP "line => [$eol, ]$cb\->($handle, $line, $eol)" 4
.el .IP "line => [$eol, ]$cb\->($handle, \f(CW$line\fR, \f(CW$eol\fR)" 4
.IX Item "line => [$eol, ]$cb->($handle, $line, $eol)"
The callback will be called only once a full line (including the end of
line marker, \f(CW$eol\fR) has been read. This line (excluding the end of line
marker) will be passed to the callback as second argument (\f(CW$line\fR), and
the end of line marker as the third argument (\f(CW$eol\fR).
.Sp
The end of line marker, \f(CW$eol\fR, can be either a string, in which case it
will be interpreted as a fixed record end marker, or it can be a regex
object (e.g. created by \f(CW\*(C`qr\*(C'\fR), in which case it is interpreted as a
regular expression.
.Sp
The end of line marker argument \f(CW$eol\fR is optional, if it is missing (\s-1NOT\s0
undef), then \f(CW\*(C`qr|\e015?\e012|\*(C'\fR is used (which is good for most internet
protocols).
.Sp
Partial lines at the end of the stream will never be returned, as they are
not marked by the end of line marker.
.ie n .IP "regex => $accept[, $reject[, $skip], $cb\->($handle, $data)" 4
.el .IP "regex => \f(CW$accept\fR[, \f(CW$reject\fR[, \f(CW$skip\fR], \f(CW$cb\fR\->($handle, \f(CW$data\fR)" 4
.IX Item "regex => $accept[, $reject[, $skip], $cb->($handle, $data)"
Makes a regex match against the regex object \f(CW$accept\fR and returns
everything up to and including the match.
.Sp
Example: read a single line terminated by '\en'.
.Sp
.Vb 1
\&   $handle\->push_read (regex => qr<\en>, sub { ... });
.Ve
.Sp
If \f(CW$reject\fR is given and not undef, then it determines when the data is
to be rejected: it is matched against the data when the \f(CW$accept\fR regex
does not match and generates an \f(CW\*(C`EBADMSG\*(C'\fR error when it matches. This is
useful to quickly reject wrong data (to avoid waiting for a timeout or a
receive buffer overflow).
.Sp
Example: expect a single decimal number followed by whitespace, reject
anything else (not the use of an anchor).
.Sp
.Vb 1
\&   $handle\->push_read (regex => qr<^[0\-9]+\es>, qr<[^0\-9]>, sub { ... });
.Ve
.Sp
If \f(CW$skip\fR is given and not \f(CW\*(C`undef\*(C'\fR, then it will be matched against
the receive buffer when neither \f(CW$accept\fR nor \f(CW$reject\fR match,
and everything preceding and including the match will be accepted
unconditionally. This is useful to skip large amounts of data that you
know cannot be matched, so that the \f(CW$accept\fR or \f(CW$reject\fR regex do not
have to start matching from the beginning. This is purely an optimisation
and is usually worth it only when you expect more than a few kilobytes.
.Sp
Example: expect a http header, which ends at \f(CW\*(C`\e015\e012\e015\e012\*(C'\fR. Since we
expect the header to be very large (it isn't in practice, but...), we use
a skip regex to skip initial portions. The skip regex is tricky in that
it only accepts something not ending in either \e015 or \e012, as these are
required for the accept regex.
.Sp
.Vb 5
\&   $handle\->push_read (regex =>
\&      qr<\e015\e012\e015\e012>,
\&      undef, # no reject
\&      qr<^.*[^\e015\e012]>,
\&      sub { ... });
.Ve
.ie n .IP "netstring => $cb\->($handle, $string)" 4
.el .IP "netstring => \f(CW$cb\fR\->($handle, \f(CW$string\fR)" 4
.IX Item "netstring => $cb->($handle, $string)"
A netstring (http://cr.yp.to/proto/netstrings.txt, this is not an endorsement).
.Sp
Throws an error with \f(CW$!\fR set to \s-1EBADMSG\s0 on format violations.
.ie n .IP "packstring => $format, $cb\->($handle, $string)" 4
.el .IP "packstring => \f(CW$format\fR, \f(CW$cb\fR\->($handle, \f(CW$string\fR)" 4
.IX Item "packstring => $format, $cb->($handle, $string)"
An octet string prefixed with an encoded length. The encoding \f(CW$format\fR
uses the same format as a Perl \f(CW\*(C`pack\*(C'\fR format, but must specify a single
integer only (only one of \f(CW\*(C`cCsSlLqQiInNvVjJw\*(C'\fR is allowed, plus an
optional \f(CW\*(C`!\*(C'\fR, \f(CW\*(C`<\*(C'\fR or \f(CW\*(C`>\*(C'\fR modifier).
.Sp
For example, \s-1DNS\s0 over \s-1TCP\s0 uses a prefix of \f(CW\*(C`n\*(C'\fR (2 octet network order),
\&\s-1EPP\s0 uses a prefix of \f(CW\*(C`N\*(C'\fR (4 octtes).
.Sp
Example: read a block of data prefixed by its length in BER-encoded
format (very efficient).
.Sp
.Vb 3
\&   $handle\->push_read (packstring => "w", sub {
\&      my ($handle, $data) = @_;
\&   });
.Ve
.ie n .IP "json => $cb\->($handle, $hash_or_arrayref)" 4
.el .IP "json => \f(CW$cb\fR\->($handle, \f(CW$hash_or_arrayref\fR)" 4
.IX Item "json => $cb->($handle, $hash_or_arrayref)"
Reads a \s-1JSON\s0 object or array, decodes it and passes it to the
callback. When a parse error occurs, an \f(CW\*(C`EBADMSG\*(C'\fR error will be raised.
.Sp
If a \f(CW\*(C`json\*(C'\fR object was passed to the constructor, then that will be used
for the final decode, otherwise it will create a \s-1JSON\s0 coder expecting \s-1UTF\-8\s0.
.Sp
This read type uses the incremental parser available with \s-1JSON\s0 version
2.09 (and \s-1JSON::XS\s0 version 2.2) and above. You have to provide a
dependency on your own: this module will load the \s-1JSON\s0 module, but
AnyEvent does not depend on it itself.
.Sp
Since \s-1JSON\s0 texts are fully self-delimiting, the \f(CW\*(C`json\*(C'\fR read and write
types are an ideal simple \s-1RPC\s0 protocol: just exchange \s-1JSON\s0 datagrams. See
the \f(CW\*(C`json\*(C'\fR write type description, above, for an actual example.
.ie n .IP "storable => $cb\->($handle, $ref)" 4
.el .IP "storable => \f(CW$cb\fR\->($handle, \f(CW$ref\fR)" 4
.IX Item "storable => $cb->($handle, $ref)"
Deserialises a Storable frozen representation as written by the
\&\f(CW\*(C`storable\*(C'\fR write type (BER-encoded length prefix followed by nfreeze'd
data).
.Sp
Raises \f(CW\*(C`EBADMSG\*(C'\fR error if the data could not be decoded.
.ie n .IP "tls_detect => $cb\->($handle, $detect, $major, $minor)" 4
.el .IP "tls_detect => \f(CW$cb\fR\->($handle, \f(CW$detect\fR, \f(CW$major\fR, \f(CW$minor\fR)" 4
.IX Item "tls_detect => $cb->($handle, $detect, $major, $minor)"
Checks the input stream for a valid \s-1SSL\s0 or \s-1TLS\s0 handshake TLSPaintext
record without consuming anything. Only \s-1SSL\s0 version 3 or higher
is handled, up to the fictituous protocol 4.x (but both \s-1SSL3+\s0 and
SSL2\-compatible framing is supported).
.Sp
If it detects that the input data is likely \s-1TLS\s0, it calls the callback
with a true value for \f(CW$detect\fR and the (on-wire) \s-1TLS\s0 version as second
and third argument (\f(CW$major\fR is \f(CW3\fR, and \f(CW$minor\fR is 0..3 for \s-1SSL\s0
3.0, \s-1TLS\s0 1.0, 1.1 and 1.2, respectively).  If it detects the input to
be definitely not \s-1TLS\s0, it calls the callback with a false value for
\&\f(CW$detect\fR.
.Sp
The callback could use this information to decide whether or not to start
\&\s-1TLS\s0 negotiation.
.Sp
In all cases the data read so far is passed to the following read
handlers.
.Sp
Usually you want to use the \f(CW\*(C`tls_autostart\*(C'\fR read type instead.
.Sp
If you want to design a protocol that works in the presence of \s-1TLS\s0
dtection, make sure that any non-TLS data doesn't start with the octet 22
(\s-1ASCII\s0 \s-1SYN\s0, 16 hex) or 128\-255 (i.e. highest bit set). The checks this
read type does are a bit more strict, but might losen in the future to
accomodate protocol changes.
.Sp
This read type does not rely on AnyEvent::TLS (and thus, not on
Net::SSLeay).
.ie n .IP "tls_autostart => $tls[, $tls_ctx]" 4
.el .IP "tls_autostart => \f(CW$tls\fR[, \f(CW$tls_ctx\fR]" 4
.IX Item "tls_autostart => $tls[, $tls_ctx]"
Tries to detect a valid \s-1SSL\s0 or \s-1TLS\s0 handshake. If one is detected, it tries
to start tls by calling \f(CW\*(C`starttls\*(C'\fR with the given arguments.
.Sp
In practise, \f(CW$tls\fR must be \f(CW\*(C`accept\*(C'\fR, or a Net::SSLeay context that has
been configured to accept, as servers do not normally send a handshake on
their own and ths cannot be detected in this way.
.Sp
See \f(CW\*(C`tls_detect\*(C'\fR above for more details.
.Sp
Example: give the client a chance to start \s-1TLS\s0 before accepting a text
line.
.Sp
.Vb 4
\&   $hdl\->push_read (tls_detect => "accept");
\&   $hdl\->push_read (line => sub {
\&      print "received ", ($_[0]{tls} ? "encrypted" : "cleartext"), " <$_[1]>\en";
\&   });
.Ve
.RE
.RS 4
.RE
.ie n .IP "custom read types \- Package::anyevent_read_type $handle, $cb, @args" 4
.el .IP "custom read types \- Package::anyevent_read_type \f(CW$handle\fR, \f(CW$cb\fR, \f(CW@args\fR" 4
.IX Item "custom read types - Package::anyevent_read_type $handle, $cb, @args"
Instead of one of the predefined types, you can also specify the name
of a package. AnyEvent will try to load the package and then expects to
find a function named \f(CW\*(C`anyevent_read_type\*(C'\fR inside. If it isn't found, it
progressively tries to load the parent package until it either finds the
function (good) or runs out of packages (bad).
.Sp
Whenever this type is used, \f(CW\*(C`push_read\*(C'\fR will invoke the function with the
handle object, the original callback and the remaining arguments.
.Sp
The function is supposed to return a callback (usually a closure) that
works as a plain read callback (see \f(CW\*(C`\->push_read ($cb)\*(C'\fR), so you can
mentally treat the function as a \*(L"configurable read type to read callback\*(R"
converter.
.Sp
It should invoke the original callback when it is done reading (remember
to pass \f(CW$handle\fR as first argument as all other callbacks do that,
although there is no strict requirement on this).
.Sp
For examples, see the source of this module (\fIperldoc \-m
AnyEvent::Handle\fR, search for \f(CW\*(C`register_read_type\*(C'\fR)).
.ie n .IP "$handle\->stop_read" 4
.el .IP "\f(CW$handle\fR\->stop_read" 4
.IX Item "$handle->stop_read"
.PD 0
.ie n .IP "$handle\->start_read" 4
.el .IP "\f(CW$handle\fR\->start_read" 4
.IX Item "$handle->start_read"
.PD
In rare cases you actually do not want to read anything from the
socket. In this case you can call \f(CW\*(C`stop_read\*(C'\fR. Neither \f(CW\*(C`on_read\*(C'\fR nor
any queued callbacks will be executed then. To start reading again, call
\&\f(CW\*(C`start_read\*(C'\fR.
.Sp
Note that AnyEvent::Handle will automatically \f(CW\*(C`start_read\*(C'\fR for you when
you change the \f(CW\*(C`on_read\*(C'\fR callback or push/unshift a read callback, and it
will automatically \f(CW\*(C`stop_read\*(C'\fR for you when neither \f(CW\*(C`on_read\*(C'\fR is set nor
there are any read requests in the queue.
.Sp
In older versions of this module (<= 5.3), these methods had no effect,
as \s-1TLS\s0 does not support half-duplex connections. In current versions they
work as expected, as this behaviour is required to avoid certain resource
attacks, where the program would be forced to read (and buffer) arbitrary
amounts of data before being able to send some data. The drawback is that
some readings of the the \s-1SSL/TLS\s0 specifications basically require this
attack to be working, as \s-1SSL/TLS\s0 implementations might stall sending data
during a rehandshake.
.Sp
As a guideline, during the initial handshake, you should not stop reading,
and as a client, it might cause problems, depending on your application.
.ie n .IP "$handle\->starttls ($tls[, $tls_ctx])" 4
.el .IP "\f(CW$handle\fR\->starttls ($tls[, \f(CW$tls_ctx\fR])" 4
.IX Item "$handle->starttls ($tls[, $tls_ctx])"
Instead of starting \s-1TLS\s0 negotiation immediately when the AnyEvent::Handle
object is created, you can also do that at a later time by calling
\&\f(CW\*(C`starttls\*(C'\fR. See the \f(CW\*(C`tls\*(C'\fR constructor argument for general info.
.Sp
Starting \s-1TLS\s0 is currently an asynchronous operation \- when you push some
write data and then call \f(CW\*(C`\->starttls\*(C'\fR then \s-1TLS\s0 negotiation will start
immediately, after which the queued write data is then sent. This might
change in future versions, so best make sure you have no outstanding write
data when calling this method.
.Sp
The first argument is the same as the \f(CW\*(C`tls\*(C'\fR constructor argument (either
\&\f(CW"connect"\fR, \f(CW"accept"\fR or an existing Net::SSLeay object).
.Sp
The second argument is the optional \f(CW\*(C`AnyEvent::TLS\*(C'\fR object that is used
when AnyEvent::Handle has to create its own \s-1TLS\s0 connection object, or
a hash reference with \f(CW\*(C`key => value\*(C'\fR pairs that will be used to
construct a new context.
.Sp
The \s-1TLS\s0 connection object will end up in \f(CW\*(C`$handle\->{tls}\*(C'\fR, the \s-1TLS\s0
context in \f(CW\*(C`$handle\->{tls_ctx}\*(C'\fR after this call and can be used or
changed to your liking. Note that the handshake might have already started
when this function returns.
.Sp
Due to bugs in OpenSSL, it might or might not be possible to do multiple
handshakes on the same stream. It is best to not attempt to use the
stream after stopping \s-1TLS\s0.
.Sp
This method may invoke callbacks (and therefore the handle might be
destroyed after it returns).
.ie n .IP "$handle\->stoptls" 4
.el .IP "\f(CW$handle\fR\->stoptls" 4
.IX Item "$handle->stoptls"
Shuts down the \s-1SSL\s0 connection \- this makes a proper \s-1EOF\s0 handshake by
sending a close notify to the other side, but since OpenSSL doesn't
support non-blocking shut downs, it is not guaranteed that you can re-use
the stream afterwards.
.Sp
This method may invoke callbacks (and therefore the handle might be
destroyed after it returns).
.ie n .IP "$handle\->resettls" 4
.el .IP "\f(CW$handle\fR\->resettls" 4
.IX Item "$handle->resettls"
This rarely-used method simply resets and \s-1TLS\s0 state on the handle, usually
causing data loss.
.Sp
One case where it may be useful is when you want to skip over the data in
the stream but you are not interested in interpreting it, so data loss is
no concern.
.ie n .IP "$handle\->destroy" 4
.el .IP "\f(CW$handle\fR\->destroy" 4
.IX Item "$handle->destroy"
Shuts down the handle object as much as possible \- this call ensures that
no further callbacks will be invoked and as many resources as possible
will be freed. Any method you will call on the handle object after
destroying it in this way will be silently ignored (and it will return the
empty list).
.Sp
Normally, you can just \*(L"forget\*(R" any references to an AnyEvent::Handle
object and it will simply shut down. This works in fatal error and \s-1EOF\s0
callbacks, as well as code outside. It does \fI\s-1NOT\s0\fR work in a read or write
callback, so when you want to destroy the AnyEvent::Handle object from
within such an callback. You \fI\s-1MUST\s0\fR call \f(CW\*(C`\->destroy\*(C'\fR explicitly in
that case.
.Sp
Destroying the handle object in this way has the advantage that callbacks
will be removed as well, so if those are the only reference holders (as
is common), then one doesn't need to do anything special to break any
reference cycles.
.Sp
The handle might still linger in the background and write out remaining
data, as specified by the \f(CW\*(C`linger\*(C'\fR option, however.
.ie n .IP "$handle\->destroyed" 4
.el .IP "\f(CW$handle\fR\->destroyed" 4
.IX Item "$handle->destroyed"
Returns false as long as the handle hasn't been destroyed by a call to \f(CW\*(C`\->destroy\*(C'\fR, true otherwise.
.Sp
Can be useful to decide whether the handle is still valid after some
callback possibly destroyed the handle. For example, \f(CW\*(C`\->push_write\*(C'\fR,
\&\f(CW\*(C`\->starttls\*(C'\fR and other methods can call user callbacks, which in turn
can destroy the handle, so work can be avoided by checking sometimes:
.Sp
.Vb 3
\&   $hdl\->starttls ("accept");
\&   return if $hdl\->destroyed;
\&   $hdl\->push_write (...
.Ve
.Sp
Note that the call to \f(CW\*(C`push_write\*(C'\fR will silently be ignored if the handle
has been destroyed, so often you can just ignore the possibility of the
handle being destroyed.
.IP "AnyEvent::Handle::TLS_CTX" 4
.IX Item "AnyEvent::Handle::TLS_CTX"
This function creates and returns the AnyEvent::TLS object used by default
for \s-1TLS\s0 mode.
.Sp
The context is created by calling AnyEvent::TLS without any arguments.
.SH "NONFREQUENTLY ASKED QUESTIONS"
.IX Header "NONFREQUENTLY ASKED QUESTIONS"
.ie n .IP "I ""undef"" the AnyEvent::Handle reference inside my callback and still get further invocations!" 4
.el .IP "I \f(CWundef\fR the AnyEvent::Handle reference inside my callback and still get further invocations!" 4
.IX Item "I undef the AnyEvent::Handle reference inside my callback and still get further invocations!"
That's because AnyEvent::Handle keeps a reference to itself when handling
read or write callbacks.
.Sp
It is only safe to \*(L"forget\*(R" the reference inside \s-1EOF\s0 or error callbacks,
from within all other callbacks, you need to explicitly call the \f(CW\*(C`\->destroy\*(C'\fR method.
.ie n .IP "Why is my ""on_eof"" callback never called?" 4
.el .IP "Why is my \f(CWon_eof\fR callback never called?" 4
.IX Item "Why is my on_eof callback never called?"
Probably because your \f(CW\*(C`on_error\*(C'\fR callback is being called instead: When
you have outstanding requests in your read queue, then an \s-1EOF\s0 is
considered an error as you clearly expected some data.
.Sp
To avoid this, make sure you have an empty read queue whenever your handle
is supposed to be \*(L"idle\*(R" (i.e. connection closes are O.K.). You can set
an \f(CW\*(C`on_read\*(C'\fR handler that simply pushes the first read requests in the
queue.
.Sp
See also the next question, which explains this in a bit more detail.
.IP "How can I serve requests in a loop?" 4
.IX Item "How can I serve requests in a loop?"
Most protocols consist of some setup phase (authentication for example)
followed by a request handling phase, where the server waits for requests
and handles them, in a loop.
.Sp
There are two important variants: The first (traditional, better) variant
handles requests until the server gets some \s-1QUIT\s0 command, causing it to
close the connection first (highly desirable for a busy \s-1TCP\s0 server). A
client dropping the connection is an error, which means this variant can
detect an unexpected detection close.
.Sp
To handle this case, always make sure you have a non-empty read queue, by
pushing the \*(L"read request start\*(R" handler on it:
.Sp
.Vb 3
\&   # we assume a request starts with a single line
\&   my @start_request; @start_request = (line => sub {
\&      my ($hdl, $line) = @_;
\&
\&      ... handle request
\&
\&      # push next request read, possibly from a nested callback
\&      $hdl\->push_read (@start_request);
\&   });
\&
\&   # auth done, now go into request handling loop
\&   # now push the first @start_request
\&   $hdl\->push_read (@start_request);
.Ve
.Sp
By always having an outstanding \f(CW\*(C`push_read\*(C'\fR, the handle always expects
some data and raises the \f(CW\*(C`EPIPE\*(C'\fR error when the connction is dropped
unexpectedly.
.Sp
The second variant is a protocol where the client can drop the connection
at any time. For \s-1TCP\s0, this means that the server machine may run out of
sockets easier, and in general, it means you cannot distinguish a protocl
failure/client crash from a normal connection close. Nevertheless, these
kinds of protocols are common (and sometimes even the best solution to the
problem).
.Sp
Having an outstanding read request at all times is possible if you ignore
\&\f(CW\*(C`EPIPE\*(C'\fR errors, but this doesn't help with when the client drops the
connection during a request, which would still be an error.
.Sp
A better solution is to push the initial request read in an \f(CW\*(C`on_read\*(C'\fR
callback. This avoids an error, as when the server doesn't expect data
(i.e. is idly waiting for the next request, an \s-1EOF\s0 will not raise an
error, but simply result in an \f(CW\*(C`on_eof\*(C'\fR callback. It is also a bit slower
and simpler:
.Sp
.Vb 3
\&   # auth done, now go into request handling loop
\&   $hdl\->on_read (sub {
\&      my ($hdl) = @_;
\&
\&      # called each time we receive data but the read queue is empty
\&      # simply start read the request
\&
\&      $hdl\->push_read (line => sub {
\&         my ($hdl, $line) = @_;
\&
\&         ... handle request
\&
\&         # do nothing special when the request has been handled, just
\&         # let the request queue go empty.
\&      });
\&   });
.Ve
.IP "I get different callback invocations in \s-1TLS\s0 mode/Why can't I pause reading?" 4
.IX Item "I get different callback invocations in TLS mode/Why can't I pause reading?"
Unlike, say, \s-1TCP\s0, \s-1TLS\s0 connections do not consist of two independent
communication channels, one for each direction. Or put differently, the
read and write directions are not independent of each other: you cannot
write data unless you are also prepared to read, and vice versa.
.Sp
This means that, in \s-1TLS\s0 mode, you might get \f(CW\*(C`on_error\*(C'\fR or \f(CW\*(C`on_eof\*(C'\fR
callback invocations when you are not expecting any read data \- the reason
is that AnyEvent::Handle always reads in \s-1TLS\s0 mode.
.Sp
During the connection, you have to make sure that you always have a
non-empty read-queue, or an \f(CW\*(C`on_read\*(C'\fR watcher. At the end of the
connection (or when you no longer want to use it) you can call the
\&\f(CW\*(C`destroy\*(C'\fR method.
.IP "How do I read data until the other side closes the connection?" 4
.IX Item "How do I read data until the other side closes the connection?"
If you just want to read your data into a perl scalar, the easiest way
to achieve this is by setting an \f(CW\*(C`on_read\*(C'\fR callback that does nothing,
clearing the \f(CW\*(C`on_eof\*(C'\fR callback and in the \f(CW\*(C`on_error\*(C'\fR callback, the data
will be in \f(CW\*(C`$_[0]{rbuf}\*(C'\fR:
.Sp
.Vb 5
\&   $handle\->on_read (sub { });
\&   $handle\->on_eof (undef);
\&   $handle\->on_error (sub {
\&      my $data = delete $_[0]{rbuf};
\&   });
.Ve
.Sp
Note that this example removes the \f(CW\*(C`rbuf\*(C'\fR member from the handle object,
which is not normally allowed by the \s-1API\s0. It is expressly permitted in
this case only, as the handle object needs to be destroyed afterwards.
.Sp
The reason to use \f(CW\*(C`on_error\*(C'\fR is that \s-1TCP\s0 connections, due to latencies
and packets loss, might get closed quite violently with an error, when in
fact all data has been received.
.Sp
It is usually better to use acknowledgements when transferring data,
to make sure the other side hasn't just died and you got the data
intact. This is also one reason why so many internet protocols have an
explicit \s-1QUIT\s0 command.
.IP "I don't want to destroy the handle too early \- how do I wait until all data has been written?" 4
.IX Item "I don't want to destroy the handle too early - how do I wait until all data has been written?"
After writing your last bits of data, set the \f(CW\*(C`on_drain\*(C'\fR callback
and destroy the handle in there \- with the default setting of
\&\f(CW\*(C`low_water_mark\*(C'\fR this will be called precisely when all data has been
written to the socket:
.Sp
.Vb 5
\&   $handle\->push_write (...);
\&   $handle\->on_drain (sub {
\&      AE::log debug => "All data submitted to the kernel.";
\&      undef $handle;
\&   });
.Ve
.Sp
If you just want to queue some data and then signal \s-1EOF\s0 to the other side,
consider using \f(CW\*(C`\->push_shutdown\*(C'\fR instead.
.IP "I want to contact a \s-1TLS/SSL\s0 server, I don't care about security." 4
.IX Item "I want to contact a TLS/SSL server, I don't care about security."
If your \s-1TLS\s0 server is a pure \s-1TLS\s0 server (e.g. \s-1HTTPS\s0) that only speaks \s-1TLS\s0,
connect to it and then create the AnyEvent::Handle with the \f(CW\*(C`tls\*(C'\fR
parameter:
.Sp
.Vb 2
\&   tcp_connect $host, $port, sub {
\&      my ($fh) = @_;
\&
\&      my $handle = new AnyEvent::Handle
\&         fh  => $fh,
\&         tls => "connect",
\&         on_error => sub { ... };
\&
\&      $handle\->push_write (...);
\&   };
.Ve
.IP "I want to contact a \s-1TLS/SSL\s0 server, I do care about security." 4
.IX Item "I want to contact a TLS/SSL server, I do care about security."
Then you should additionally enable certificate verification, including
peername verification, if the protocol you use supports it (see
AnyEvent::TLS, \f(CW\*(C`verify_peername\*(C'\fR).
.Sp
E.g. for \s-1HTTPS:\s0
.Sp
.Vb 2
\&   tcp_connect $host, $port, sub {
\&      my ($fh) = @_;
\&
\&       my $handle = new AnyEvent::Handle
\&          fh       => $fh,
\&          peername => $host,
\&          tls      => "connect",
\&          tls_ctx  => { verify => 1, verify_peername => "https" },
\&          ...
.Ve
.Sp
Note that you must specify the hostname you connected to (or whatever
\&\*(L"peername\*(R" the protocol needs) as the \f(CW\*(C`peername\*(C'\fR argument, otherwise no
peername verification will be done.
.Sp
The above will use the system-dependent default set of trusted \s-1CA\s0
certificates. If you want to check against a specific \s-1CA\s0, add the
\&\f(CW\*(C`ca_file\*(C'\fR (or \f(CW\*(C`ca_cert\*(C'\fR) arguments to \f(CW\*(C`tls_ctx\*(C'\fR:
.Sp
.Vb 5
\&       tls_ctx  => {
\&          verify          => 1,
\&          verify_peername => "https",
\&          ca_file         => "my\-ca\-cert.pem",
\&       },
.Ve
.IP "I want to create a \s-1TLS/SSL\s0 server, how do I do that?" 4
.IX Item "I want to create a TLS/SSL server, how do I do that?"
Well, you first need to get a server certificate and key. You have
three options: a) ask a \s-1CA\s0 (buy one, use cacert.org etc.) b) create a
self-signed certificate (cheap. check the search engine of your choice,
there are many tutorials on the net) or c) make your own \s-1CA\s0 (tinyca2 is a
nice program for that purpose).
.Sp
Then create a file with your private key (in \s-1PEM\s0 format, see
AnyEvent::TLS), followed by the certificate (also in \s-1PEM\s0 format). The
file should then look like this:
.Sp
.Vb 4
\&   \-\-\-\-\-BEGIN RSA PRIVATE KEY\-\-\-\-\-
\&   ...header data
\&   ... lots of base64\*(Aqy\-stuff
\&   \-\-\-\-\-END RSA PRIVATE KEY\-\-\-\-\-
\&
\&   \-\-\-\-\-BEGIN CERTIFICATE\-\-\-\-\-
\&   ... lots of base64\*(Aqy\-stuff
\&   \-\-\-\-\-END CERTIFICATE\-\-\-\-\-
.Ve
.Sp
The important bits are the \*(L"\s-1PRIVATE\s0 \s-1KEY\s0\*(R" and \*(L"\s-1CERTIFICATE\s0\*(R" parts.  Then
specify this file as \f(CW\*(C`cert_file\*(C'\fR:
.Sp
.Vb 2
\&   tcp_server undef, $port, sub {
\&      my ($fh) = @_;
\&
\&      my $handle = new AnyEvent::Handle
\&         fh       => $fh,
\&         tls      => "accept",
\&         tls_ctx  => { cert_file => "my\-server\-keycert.pem" },
\&         ...
.Ve
.Sp
When you have intermediate \s-1CA\s0 certificates that your clients might not
know about, just append them to the \f(CW\*(C`cert_file\*(C'\fR.
.SH "SUBCLASSING AnyEvent::Handle"
.IX Header "SUBCLASSING AnyEvent::Handle"
In many cases, you might want to subclass AnyEvent::Handle.
.PP
To make this easier, a given version of AnyEvent::Handle uses these
conventions:
.IP "\(bu" 4
all constructor arguments become object members.
.Sp
At least initially, when you pass a \f(CW\*(C`tls\*(C'\fR\-argument to the constructor it
will end up in \f(CW\*(C`$handle\->{tls}\*(C'\fR. Those members might be changed or
mutated later on (for example \f(CW\*(C`tls\*(C'\fR will hold the \s-1TLS\s0 connection object).
.IP "\(bu" 4
other object member names are prefixed with an \f(CW\*(C`_\*(C'\fR.
.Sp
All object members not explicitly documented (internal use) are prefixed
with an underscore character, so the remaining non\-\f(CW\*(C`_\*(C'\fR\-namespace is free
for use for subclasses.
.IP "\(bu" 4
all members not documented here and not prefixed with an underscore
are free to use in subclasses.
.Sp
Of course, new versions of AnyEvent::Handle may introduce more \*(L"public\*(R"
member variables, but that's just life. At least it is documented.
.SH "AUTHOR"
.IX Header "AUTHOR"
Robin Redeker \f(CW\*(C`<elmex at ta\-sa.org>\*(C'\fR, Marc Lehmann <schmorp@schmorp.de>.
