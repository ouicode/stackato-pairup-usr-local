.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent::Util 3"
.TH AnyEvent::Util 3 "2012-04-08" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::Util \- various utility functions.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use AnyEvent::Util;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements various utility functions, mostly replacing
well-known functions by event-ised counterparts.
.PP
All functions documented without \f(CW\*(C`AnyEvent::Util::\*(C'\fR prefix are exported
by default.
.ie n .IP "($r, $w) = portable_pipe" 4
.el .IP "($r, \f(CW$w\fR) = portable_pipe" 4
.IX Item "($r, $w) = portable_pipe"
Calling \f(CW\*(C`pipe\*(C'\fR in Perl is portable \- except it doesn't really work on
sucky windows platforms (at least not with most perls \- cygwin's perl
notably works fine): On windows, you actually get two file handles you
cannot use select on.
.Sp
This function gives you a pipe that actually works even on the broken
windows platform (by creating a pair of \s-1TCP\s0 sockets on windows, so do not
expect any speed from that) and using \f(CW\*(C`pipe\*(C'\fR everywhere else.
.Sp
See \f(CW\*(C`portable_socketpair\*(C'\fR, below, for a bidirectional \*(L"pipe\*(R".
.Sp
Returns the empty list on any errors.
.ie n .IP "($fh1, $fh2) = portable_socketpair" 4
.el .IP "($fh1, \f(CW$fh2\fR) = portable_socketpair" 4
.IX Item "($fh1, $fh2) = portable_socketpair"
Just like \f(CW\*(C`portable_pipe\*(C'\fR, above, but returns a bidirectional pipe
(usually by calling \f(CW\*(C`socketpair\*(C'\fR to create a local loopback socket pair,
except on windows, where it again returns two interconnected \s-1TCP\s0 sockets).
.Sp
Returns the empty list on any errors.
.ie n .IP "fork_call { \s-1CODE\s0 } @args, $cb\->(@res)" 4
.el .IP "fork_call { \s-1CODE\s0 } \f(CW@args\fR, \f(CW$cb\fR\->(@res)" 4
.IX Item "fork_call { CODE } @args, $cb->(@res)"
Executes the given code block asynchronously, by forking. Everything the
block returns will be transferred to the calling process (by serialising and
deserialising via Storable).
.Sp
If there are any errors, then the \f(CW$cb\fR will be called without any
arguments. In that case, either \f(CW$@\fR contains the exception (and \f(CW$!\fR is
irrelevant), or \f(CW$!\fR contains an error number. In all other cases, \f(CW$@\fR
will be \f(CW\*(C`undef\*(C'\fRined.
.Sp
The code block must not ever call an event-polling function or use
event-based programming that might cause any callbacks registered in the
parent to run.
.Sp
Win32 spoilers: Due to the endlessly sucky and broken native windows
perls (there is no way to cleanly exit a child process on that platform
that doesn't also kill the parent), you have to make sure that your main
program doesn't exit as long as any \f(CW\*(C`fork_calls\*(C'\fR are still in progress,
otherwise the program won't exit. Also, on most windows platforms some
memory will leak for every invocation. We are open for improvements that
don't require \s-1XS\s0 hackery.
.Sp
Note that forking can be expensive in large programs (\s-1RSS\s0 200MB+). On
windows, it is abysmally slow, do not expect more than 5..20 forks/s on
that sucky platform (note this uses perl's pseudo-threads, so avoid those
like the plague).
.Sp
Example: poor man's async disk I/O (better use \s-1IO::AIO\s0).
.Sp
.Vb 9
\&   fork_call {
\&      open my $fh, "</etc/passwd"
\&         or die "passwd: $!";
\&      local $/;
\&      <$fh>
\&   } sub {
\&      my ($passwd) = @_;
\&      ...
\&   };
.Ve
.ie n .IP "$AnyEvent::Util::MAX_FORKS [default: 10]" 4
.el .IP "\f(CW$AnyEvent::Util::MAX_FORKS\fR [default: 10]" 4
.IX Item "$AnyEvent::Util::MAX_FORKS [default: 10]"
The maximum number of child processes that \f(CW\*(C`fork_call\*(C'\fR will fork in
parallel. Any additional requests will be queued until a slot becomes free
again.
.Sp
The environment variable \f(CW\*(C`PERL_ANYEVENT_MAX_FORKS\*(C'\fR is used to initialise
this value.
.ie n .IP "fh_nonblocking $fh, $nonblocking" 4
.el .IP "fh_nonblocking \f(CW$fh\fR, \f(CW$nonblocking\fR" 4
.IX Item "fh_nonblocking $fh, $nonblocking"
Sets the blocking state of the given filehandle (true == nonblocking,
false == blocking). Uses fcntl on anything sensible and ioctl \s-1FIONBIO\s0 on
broken (i.e. windows) platforms.
.ie n .IP "$guard = guard { \s-1CODE\s0 }" 4
.el .IP "\f(CW$guard\fR = guard { \s-1CODE\s0 }" 4
.IX Item "$guard = guard { CODE }"
This function creates a special object that, when called, will execute
the code block.
.Sp
This is often handy in continuation-passing style code to clean up some
resource regardless of where you break out of a process.
.Sp
The Guard module will be used to implement this function, if it is
available. Otherwise a pure-perl implementation is used.
.Sp
While the code is allowed to throw exceptions in unusual conditions, it is
not defined whether this exception will be reported (at the moment, the
Guard module and AnyEvent's pure-perl implementation both try to report
the error and continue).
.Sp
You can call one method on the returned object:
.ie n .IP "$guard\->cancel" 4
.el .IP "\f(CW$guard\fR\->cancel" 4
.IX Item "$guard->cancel"
This simply causes the code block not to be invoked: it \*(L"cancels\*(R" the
guard.
.ie n .IP "AnyEvent::Util::close_all_fds_except @fds" 4
.el .IP "AnyEvent::Util::close_all_fds_except \f(CW@fds\fR" 4
.IX Item "AnyEvent::Util::close_all_fds_except @fds"
This rarely-used function simply closes all file descriptors (or tries to)
of the current process except the ones given as arguments.
.Sp
When you want to start a long-running background server, then it is often
beneficial to do this, as too many C\-libraries are too stupid to mark
their internal fd's as close-on-exec.
.Sp
The function expects to be called shortly before an \f(CW\*(C`exec\*(C'\fR call.
.Sp
Example: close all fds except 0, 1, 2.
.Sp
.Vb 1
\&   close_all_fds_except 0, 2, 1;
.Ve
.ie n .IP "$cv = run_cmd $cmd, key => value..." 4
.el .IP "\f(CW$cv\fR = run_cmd \f(CW$cmd\fR, key => value..." 4
.IX Item "$cv = run_cmd $cmd, key => value..."
Run a given external command, potentially redirecting file descriptors and
return a condition variable that gets sent the exit status (like \f(CW$?\fR)
when the program exits \fIand\fR all redirected file descriptors have been
exhausted.
.Sp
The \f(CW$cmd\fR is either a single string, which is then passed to a shell, or
an arrayref, which is passed to the \f(CW\*(C`execvp\*(C'\fR function.
.Sp
The key-value pairs can be:
.RS 4
.ie n .IP """>"" => $filename" 4
.el .IP "``>'' => \f(CW$filename\fR" 4
.IX Item "> => $filename"
Redirects program standard output into the specified filename, similar to \f(CW\*(C`>filename\*(C'\fR in the shell.
.ie n .IP """>"" => \e$data" 4
.el .IP "``>'' => \e$data" 4
.IX Item "> => $data"
Appends program standard output to the referenced scalar. The condvar will
not be signalled before \s-1EOF\s0 or an error is signalled.
.ie n .IP """>"" => $filehandle" 4
.el .IP "``>'' => \f(CW$filehandle\fR" 4
.IX Item "> => $filehandle"
Redirects program standard output to the given filehandle (or actually its
underlying file descriptor).
.ie n .IP """>"" => $callback\->($data)" 4
.el .IP "``>'' => \f(CW$callback\fR\->($data)" 4
.IX Item "> => $callback->($data)"
Calls the given callback each time standard output receives some data,
passing it the data received. On \s-1EOF\s0 or error, the callback will be
invoked once without any arguments.
.Sp
The condvar will not be signalled before \s-1EOF\s0 or an error is signalled.
.ie n .IP """fd>"" => $see_above" 4
.el .IP "``fd>'' => \f(CW$see_above\fR" 4
.IX Item "fd> => $see_above"
Like \*(L">\*(R", but redirects the specified fd number instead.
.ie n .IP """<"" => $see_above" 4
.el .IP "``<'' => \f(CW$see_above\fR" 4
.IX Item "< => $see_above"
The same, but redirects the program's standard input instead. The same
forms as for \*(L">\*(R" are allowed.
.Sp
In the callback form, the callback is supposed to return data to be
written, or the empty list or \f(CW\*(C`undef\*(C'\fR or a zero-length scalar to signal
\&\s-1EOF\s0.
.Sp
Similarly, either the write data must be exhausted or an error is to be
signalled before the condvar is signalled, for both string-reference and
callback forms.
.ie n .IP """fd<"" => $see_above" 4
.el .IP "``fd<'' => \f(CW$see_above\fR" 4
.IX Item "fd< => $see_above"
Like \*(L"<\*(R", but redirects the specified file descriptor instead.
.ie n .IP "on_prepare => $cb" 4
.el .IP "on_prepare => \f(CW$cb\fR" 4
.IX Item "on_prepare => $cb"
Specify a callback that is executed just before the command is \f(CW\*(C`exec\*(C'\fR'ed,
in the child process. Be careful not to use any event handling or other
services not available in the child.
.Sp
This can be useful to set up the environment in special ways, such as
changing the priority of the command or manipulating signal handlers (e.g.
setting \f(CW\*(C`SIGINT\*(C'\fR to \f(CW\*(C`IGNORE\*(C'\fR).
.ie n .IP "close_all => $boolean" 4
.el .IP "close_all => \f(CW$boolean\fR" 4
.IX Item "close_all => $boolean"
When \f(CW\*(C`close_all\*(C'\fR is enabled (default is disabled), then all extra file
descriptors will be closed, except the ones that were redirected and \f(CW0\fR,
\&\f(CW1\fR and \f(CW2\fR.
.Sp
See \f(CW\*(C`close_all_fds_except\*(C'\fR for more details.
.IP "'$$' => \e$pid" 4
.IX Item "'$$' => $pid"
A reference to a scalar which will receive the \s-1PID\s0 of the newly-created
subprocess after \f(CW\*(C`run_cmd\*(C'\fR returns.
.Sp
Note the the \s-1PID\s0 might already have been recycled and used by an unrelated
process at the time \f(CW\*(C`run_cmd\*(C'\fR returns, so it's not useful to send
signals, use a unique key in data structures and so on.
.RE
.RS 4
.Sp
Example: run \f(CW\*(C`rm \-rf /\*(C'\fR, redirecting standard input, output and error to
\&\fI/dev/null\fR.
.Sp
.Vb 5
\&   my $cv = run_cmd [qw(rm \-rf /)],
\&      "<", "/dev/null",
\&      ">", "/dev/null",
\&      "2>", "/dev/null";
\&   $cv\->recv and die "d\*(Aqoh! something survived!"
.Ve
.Sp
Example: run \fIopenssl\fR and create a self-signed certificate and key,
storing them in \f(CW$cert\fR and \f(CW$key\fR. When finished, check the exit status
in the callback and print key and certificate.
.Sp
.Vb 9
\&   my $cv = run_cmd [qw(openssl req 
\&                     \-new \-nodes \-x509 \-days 3650
\&                     \-newkey rsa:2048 \-keyout /dev/fd/3
\&                     \-batch \-subj /CN=AnyEvent
\&                    )],
\&      "<", "/dev/null",
\&      ">" , \emy $cert,
\&      "3>", \emy $key,
\&      "2>", "/dev/null";
\&
\&   $cv\->cb (sub {
\&      shift\->recv and die "openssl failed";
\&
\&      print "$key\en$cert\en";
\&   });
.Ve
.RE
.ie n .IP "AnyEvent::Util::punycode_encode $string" 4
.el .IP "AnyEvent::Util::punycode_encode \f(CW$string\fR" 4
.IX Item "AnyEvent::Util::punycode_encode $string"
Punycode-encodes the given \f(CW$string\fR and returns its punycode form. Note
that uppercase letters are \fInot\fR casefolded \- you have to do that
yourself.
.Sp
Croaks when it cannot encode the string.
.ie n .IP "AnyEvent::Util::punycode_decode $string" 4
.el .IP "AnyEvent::Util::punycode_decode \f(CW$string\fR" 4
.IX Item "AnyEvent::Util::punycode_decode $string"
Tries to punycode-decode the given \f(CW$string\fR and return its unicode
form. Again, uppercase letters are not casefoled, you have to do that
yourself.
.Sp
Croaks when it cannot decode the string.
.ie n .IP "AnyEvent::Util::idn_nameprep $idn[, $display]" 4
.el .IP "AnyEvent::Util::idn_nameprep \f(CW$idn\fR[, \f(CW$display\fR]" 4
.IX Item "AnyEvent::Util::idn_nameprep $idn[, $display]"
Implements the \s-1IDNA\s0 nameprep normalisation algorithm. Or actually the
UTS#46 algorithm. Or maybe something similar \- reality is complicated
between \s-1IDNA2003\s0, UTS#46 and \s-1IDNA2008\s0. If \f(CW$display\fR is true then the name
is prepared for display, otherwise it is prepared for lookup (default).
.Sp
If you have no clue what this means, look at \f(CW\*(C`idn_to_ascii\*(C'\fR instead.
.Sp
This function is designed to avoid using a lot of resources \- it uses
about 1MB of \s-1RAM\s0 (most of this due to Unicode::Normalize). Also, names
that are already \*(L"simple\*(R" will only be checked for basic validity, without
the overhead of full nameprep processing.
.ie n .IP "$domainname = AnyEvent::Util::idn_to_ascii $idn" 4
.el .IP "\f(CW$domainname\fR = AnyEvent::Util::idn_to_ascii \f(CW$idn\fR" 4
.IX Item "$domainname = AnyEvent::Util::idn_to_ascii $idn"
Converts the given unicode string (\f(CW$idn\fR, international domain name,
e.g. \*(aeXX\*(aeXXe\*`XXa\*~XXi\*:XXi\*:XX) to a pure-ASCII domain name (this is usually
called the \*(L"\s-1IDN\s0 ToAscii\*(R" transform). This transformation is idempotent,
which means you can call it just in case and it will do the right thing.
.Sp
Unlike some other \*(L"ToAscii\*(R" implementations, this one works on full domain
names and should never fail \- if it cannot convert the name, then it will
return it unchanged.
.Sp
This function is an amalgam of \s-1IDNA2003\s0, UTS#46 and \s-1IDNA2008\s0 \- it tries to
be reasonably compatible to other implementations, reasonably secure, as
much as IDNs can be secure, and reasonably efficient when confronted with
IDNs that are already valid \s-1DNS\s0 names.
.ie n .IP "$idn = AnyEvent::Util::idn_to_unicode $idn" 4
.el .IP "\f(CW$idn\fR = AnyEvent::Util::idn_to_unicode \f(CW$idn\fR" 4
.IX Item "$idn = AnyEvent::Util::idn_to_unicode $idn"
Converts the given unicode string (\f(CW$idn\fR, international domain name,
e.g. \*(aeXX\*(aeXXe\*`XXa\*~XXi\*:XXi\*:XX, www.deliantra.net, www.xn\*(--l\-0ga.de) to
unicode form (this is usually called the \*(L"\s-1IDN\s0 ToUnicode\*(R" transform). This
transformation is idempotent, which means you can call it just in case and
it will do the right thing.
.Sp
Unlike some other \*(L"ToUnicode\*(R" implementations, this one works on full
domain names and should never fail \- if it cannot convert the name, then
it will return it unchanged.
.Sp
This function is an amalgam of \s-1IDNA2003\s0, UTS#46 and \s-1IDNA2008\s0 \- it tries to
be reasonably compatible to other implementations, reasonably secure, as
much as IDNs can be secure, and reasonably efficient when confronted with
IDNs that are already valid \s-1DNS\s0 names.
.Sp
At the moment, this function simply calls \f(CW\*(C`idn_nameprep $idn, 1\*(C'\fR,
returning its argument when that function fails.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>
\& http://anyevent.schmorp.de
.Ve
