.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP 3"
.TH HTTP 3 "2012-04-22" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::HTTP \- simple but non\-blocking HTTP/HTTPS client
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use AnyEvent::HTTP;
\&
\&   http_get "http://www.nethype.de/", sub { print $_[1] };
\&
\&   # ... do something else here
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is an AnyEvent user, you need to make sure that you use and
run a supported event loop.
.PP
This module implements a simple, stateless and non-blocking \s-1HTTP\s0
client. It supports \s-1GET\s0, \s-1POST\s0 and other request methods, cookies and more,
all on a very low level. It can follow redirects, supports proxies, and
automatically limits the number of connections to the values specified in
the \s-1RFC\s0.
.PP
It should generally be a \*(L"good client\*(R" that is enough for most \s-1HTTP\s0
tasks. Simple tasks should be simple, but complex tasks should still be
possible as the user retains control over request and response headers.
.PP
The caller is responsible for authentication management, cookies (if
the simplistic implementation in this module doesn't suffice), referer
and other high-level protocol details for which this module offers only
limited support.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.ie n .IP "http_get $url, key => value..., $cb\->($data, $headers)" 4
.el .IP "http_get \f(CW$url\fR, key => value..., \f(CW$cb\fR\->($data, \f(CW$headers\fR)" 4
.IX Item "http_get $url, key => value..., $cb->($data, $headers)"
Executes an HTTP-GET request. See the http_request function for details on
additional parameters and the return value.
.ie n .IP "http_head $url, key => value..., $cb\->($data, $headers)" 4
.el .IP "http_head \f(CW$url\fR, key => value..., \f(CW$cb\fR\->($data, \f(CW$headers\fR)" 4
.IX Item "http_head $url, key => value..., $cb->($data, $headers)"
Executes an HTTP-HEAD request. See the http_request function for details
on additional parameters and the return value.
.ie n .IP "http_post $url, $body, key => value..., $cb\->($data, $headers)" 4
.el .IP "http_post \f(CW$url\fR, \f(CW$body\fR, key => value..., \f(CW$cb\fR\->($data, \f(CW$headers\fR)" 4
.IX Item "http_post $url, $body, key => value..., $cb->($data, $headers)"
Executes an HTTP-POST request with a request body of \f(CW$body\fR. See the
http_request function for details on additional parameters and the return
value.
.ie n .IP "http_request $method => $url, key => value..., $cb\->($data, $headers)" 4
.el .IP "http_request \f(CW$method\fR => \f(CW$url\fR, key => value..., \f(CW$cb\fR\->($data, \f(CW$headers\fR)" 4
.IX Item "http_request $method => $url, key => value..., $cb->($data, $headers)"
Executes a \s-1HTTP\s0 request of type \f(CW$method\fR (e.g. \f(CW\*(C`GET\*(C'\fR, \f(CW\*(C`POST\*(C'\fR). The \s-1URL\s0
must be an absolute http or https \s-1URL\s0.
.Sp
When called in void context, nothing is returned. In other contexts,
\&\f(CW\*(C`http_request\*(C'\fR returns a \*(L"cancellation guard\*(R" \- you have to keep the
object at least alive until the callback get called. If the object gets
destroyed before the callback is called, the request will be cancelled.
.Sp
The callback will be called with the response body data as first argument
(or \f(CW\*(C`undef\*(C'\fR if an error occured), and a hash-ref with response headers
(and trailers) as second argument.
.Sp
All the headers in that hash are lowercased. In addition to the response
headers, the \*(L"pseudo-headers\*(R" (uppercase to avoid clashing with possible
response headers) \f(CW\*(C`HTTPVersion\*(C'\fR, \f(CW\*(C`Status\*(C'\fR and \f(CW\*(C`Reason\*(C'\fR contain the
three parts of the \s-1HTTP\s0 Status-Line of the same name. If an error occurs
during the body phase of a request, then the original \f(CW\*(C`Status\*(C'\fR and
\&\f(CW\*(C`Reason\*(C'\fR values from the header are available as \f(CW\*(C`OrigStatus\*(C'\fR and
\&\f(CW\*(C`OrigReason\*(C'\fR.
.Sp
The pseudo-header \f(CW\*(C`URL\*(C'\fR contains the actual \s-1URL\s0 (which can differ from
the requested \s-1URL\s0 when following redirects \- for example, you might get
an error that your \s-1URL\s0 scheme is not supported even though your \s-1URL\s0 is a
valid http \s-1URL\s0 because it redirected to an ftp \s-1URL\s0, in which case you can
look at the \s-1URL\s0 pseudo header).
.Sp
The pseudo-header \f(CW\*(C`Redirect\*(C'\fR only exists when the request was a result
of an internal redirect. In that case it is an array reference with
the \f(CW\*(C`($data, $headers)\*(C'\fR from the redirect response. Note that this
response could in turn be the result of a redirect itself, and \f(CW\*(C`$headers\->{Redirect}[1]{Redirect}\*(C'\fR will then contain the original
response, and so on.
.Sp
If the server sends a header multiple times, then their contents will be
joined together with a comma (\f(CW\*(C`,\*(C'\fR), as per the \s-1HTTP\s0 spec.
.Sp
If an internal error occurs, such as not being able to resolve a hostname,
then \f(CW$data\fR will be \f(CW\*(C`undef\*(C'\fR, \f(CW\*(C`$headers\->{Status}\*(C'\fR will be
\&\f(CW590\fR\-\f(CW599\fR and the \f(CW\*(C`Reason\*(C'\fR pseudo-header will contain an error
message. Currently the following status codes are used:
.RS 4
.IP "595 \- errors during connection etsbalishment, proxy handshake." 4
.IX Item "595 - errors during connection etsbalishment, proxy handshake."
.PD 0
.IP "596 \- errors during \s-1TLS\s0 negotiation, request sending and header processing." 4
.IX Item "596 - errors during TLS negotiation, request sending and header processing."
.IP "597 \- errors during body receiving or processing." 4
.IX Item "597 - errors during body receiving or processing."
.ie n .IP "598 \- user aborted request via ""on_header"" or ""on_body""." 4
.el .IP "598 \- user aborted request via \f(CWon_header\fR or \f(CWon_body\fR." 4
.IX Item "598 - user aborted request via on_header or on_body."
.IP "599 \- other, usually nonretryable, errors (garbled \s-1URL\s0 etc.)." 4
.IX Item "599 - other, usually nonretryable, errors (garbled URL etc.)."
.RE
.RS 4
.PD
.Sp
A typical callback might look like this:
.Sp
.Vb 2
\&   sub {
\&      my ($body, $hdr) = @_;
\&
\&      if ($hdr\->{Status} =~ /^2/) {
\&         ... everything should be ok
\&      } else {
\&         print "error, $hdr\->{Status} $hdr\->{Reason}\en";
\&      }
\&   }
.Ve
.Sp
Additional parameters are key-value pairs, and are fully optional. They
include:
.ie n .IP "recurse => $count (default: $MAX_RECURSE)" 4
.el .IP "recurse => \f(CW$count\fR (default: \f(CW$MAX_RECURSE\fR)" 4
.IX Item "recurse => $count (default: $MAX_RECURSE)"
Whether to recurse requests or not, e.g. on redirects, authentication
retries and so on, and how often to do so.
.IP "headers => hashref" 4
.IX Item "headers => hashref"
The request headers to use. Currently, \f(CW\*(C`http_request\*(C'\fR may provide its own
\&\f(CW\*(C`Host:\*(C'\fR, \f(CW\*(C`Content\-Length:\*(C'\fR, \f(CW\*(C`Connection:\*(C'\fR and \f(CW\*(C`Cookie:\*(C'\fR headers and
will provide defaults at least for \f(CW\*(C`TE:\*(C'\fR, \f(CW\*(C`Referer:\*(C'\fR and \f(CW\*(C`User\-Agent:\*(C'\fR
(this can be suppressed by using \f(CW\*(C`undef\*(C'\fR for these headers in which case
they won't be sent at all).
.Sp
You really should provide your own \f(CW\*(C`User\-Agent:\*(C'\fR header value that is
appropriate for your program \- I wouldn't be surprised if the default
AnyEvent string gets blocked by webservers sooner or later.
.Sp
Also, make sure that your headers names and values do not contain any
embedded newlines.
.ie n .IP "timeout => $seconds" 4
.el .IP "timeout => \f(CW$seconds\fR" 4
.IX Item "timeout => $seconds"
The time-out to use for various stages \- each connect attempt will reset
the timeout, as will read or write activity, i.e. this is not an overall
timeout.
.Sp
Default timeout is 5 minutes.
.ie n .IP "proxy => [$host, $port[, $scheme]] or undef" 4
.el .IP "proxy => [$host, \f(CW$port\fR[, \f(CW$scheme\fR]] or undef" 4
.IX Item "proxy => [$host, $port[, $scheme]] or undef"
Use the given http proxy for all requests, or no proxy if \f(CW\*(C`undef\*(C'\fR is
used.
.Sp
\&\f(CW$scheme\fR must be either missing or must be \f(CW\*(C`http\*(C'\fR for \s-1HTTP\s0.
.Sp
If not specified, then the default proxy is used (see
\&\f(CW\*(C`AnyEvent::HTTP::set_proxy\*(C'\fR).
.ie n .IP "body => $string" 4
.el .IP "body => \f(CW$string\fR" 4
.IX Item "body => $string"
The request body, usually empty. Will be sent as-is (future versions of
this module might offer more options).
.ie n .IP "cookie_jar => $hash_ref" 4
.el .IP "cookie_jar => \f(CW$hash_ref\fR" 4
.IX Item "cookie_jar => $hash_ref"
Passing this parameter enables (simplified) cookie-processing, loosely
based on the original netscape specification.
.Sp
The \f(CW$hash_ref\fR must be an (initially empty) hash reference which
will get updated automatically. It is possible to save the cookie jar
to persistent storage with something like \s-1JSON\s0 or Storable \- see the
\&\f(CW\*(C`AnyEvent::HTTP::cookie_jar_expire\*(C'\fR function if you wish to remove
expired or session-only cookies, and also for documentation on the format
of the cookie jar.
.Sp
Note that this cookie implementation is not meant to be complete. If
you want complete cookie management you have to do that on your
own. \f(CW\*(C`cookie_jar\*(C'\fR is meant as a quick fix to get most cookie-using sites
working. Cookies are a privacy disaster, do not use them unless required
to.
.Sp
When cookie processing is enabled, the \f(CW\*(C`Cookie:\*(C'\fR and \f(CW\*(C`Set\-Cookie:\*(C'\fR
headers will be set and handled by this module, otherwise they will be
left untouched.
.ie n .IP "tls_ctx => $scheme | $tls_ctx" 4
.el .IP "tls_ctx => \f(CW$scheme\fR | \f(CW$tls_ctx\fR" 4
.IX Item "tls_ctx => $scheme | $tls_ctx"
Specifies the AnyEvent::TLS context to be used for https connections. This
parameter follows the same rules as the \f(CW\*(C`tls_ctx\*(C'\fR parameter to
AnyEvent::Handle, but additionally, the two strings \f(CW\*(C`low\*(C'\fR or
\&\f(CW\*(C`high\*(C'\fR can be specified, which give you a predefined low-security (no
verification, highest compatibility) and high-security (\s-1CA\s0 and common-name
verification) \s-1TLS\s0 context.
.Sp
The default for this option is \f(CW\*(C`low\*(C'\fR, which could be interpreted as \*(L"give
me the page, no matter what\*(R".
.Sp
See also the \f(CW\*(C`sessionid\*(C'\fR parameter.
.ie n .IP "session => $string" 4
.el .IP "session => \f(CW$string\fR" 4
.IX Item "session => $string"
The module might reuse connections to the same host internally. Sometimes
(e.g. when using \s-1TLS\s0), you do not want to reuse connections from other
sessions. This can be achieved by setting this parameter to some unique
\&\s-1ID\s0 (such as the address of an object storing your state data, or the \s-1TLS\s0
context) \- only connections using the same unique \s-1ID\s0 will be reused.
.ie n .IP "on_prepare => $callback\->($fh)" 4
.el .IP "on_prepare => \f(CW$callback\fR\->($fh)" 4
.IX Item "on_prepare => $callback->($fh)"
In rare cases you need to \*(L"tune\*(R" the socket before it is used to
connect (for exmaple, to bind it on a given \s-1IP\s0 address). This parameter
overrides the prepare callback passed to \f(CW\*(C`AnyEvent::Socket::tcp_connect\*(C'\fR
and behaves exactly the same way (e.g. it has to provide a
timeout). See the description for the \f(CW$prepare_cb\fR argument of
\&\f(CW\*(C`AnyEvent::Socket::tcp_connect\*(C'\fR for details.
.ie n .IP "tcp_connect => $callback\->($host, $service, $connect_cb, $prepare_cb)" 4
.el .IP "tcp_connect => \f(CW$callback\fR\->($host, \f(CW$service\fR, \f(CW$connect_cb\fR, \f(CW$prepare_cb\fR)" 4
.IX Item "tcp_connect => $callback->($host, $service, $connect_cb, $prepare_cb)"
In even rarer cases you want total control over how AnyEvent::HTTP
establishes connections. Normally it uses AnyEvent::Socket::tcp_connect
to do this, but you can provide your own \f(CW\*(C`tcp_connect\*(C'\fR function \-
obviously, it has to follow the same calling conventions, except that it
may always return a connection guard object.
.Sp
There are probably lots of weird uses for this function, starting from
tracing the hosts \f(CW\*(C`http_request\*(C'\fR actually tries to connect, to (inexact
but fast) host => \s-1IP\s0 address caching or even socks protocol support.
.ie n .IP "on_header => $callback\->($headers)" 4
.el .IP "on_header => \f(CW$callback\fR\->($headers)" 4
.IX Item "on_header => $callback->($headers)"
When specified, this callback will be called with the header hash as soon
as headers have been successfully received from the remote server (not on
locally-generated errors).
.Sp
It has to return either true (in which case AnyEvent::HTTP will continue),
or false, in which case AnyEvent::HTTP will cancel the download (and call
the finish callback with an error code of \f(CW598\fR).
.Sp
This callback is useful, among other things, to quickly reject unwanted
content, which, if it is supposed to be rare, can be faster than first
doing a \f(CW\*(C`HEAD\*(C'\fR request.
.Sp
The downside is that cancelling the request makes it impossible to re-use
the connection. Also, the \f(CW\*(C`on_header\*(C'\fR callback will not receive any
trailer (headers sent after the response body).
.Sp
Example: cancel the request unless the content-type is \*(L"text/html\*(R".
.Sp
.Vb 3
\&   on_header => sub {
\&      $_[0]{"content\-type"} =~ /^text\e/html\es*(?:;|$)/
\&   },
.Ve
.ie n .IP "on_body => $callback\->($partial_body, $headers)" 4
.el .IP "on_body => \f(CW$callback\fR\->($partial_body, \f(CW$headers\fR)" 4
.IX Item "on_body => $callback->($partial_body, $headers)"
When specified, all body data will be passed to this callback instead of
to the completion callback. The completion callback will get the empty
string instead of the body data.
.Sp
It has to return either true (in which case AnyEvent::HTTP will continue),
or false, in which case AnyEvent::HTTP will cancel the download (and call
the completion callback with an error code of \f(CW598\fR).
.Sp
The downside to cancelling the request is that it makes it impossible to
re-use the connection.
.Sp
This callback is useful when the data is too large to be held in memory
(so the callback writes it to a file) or when only some information should
be extracted, or when the body should be processed incrementally.
.Sp
It is usually preferred over doing your own body handling via
\&\f(CW\*(C`want_body_handle\*(C'\fR, but in case of streaming APIs, where \s-1HTTP\s0 is
only used to create a connection, \f(CW\*(C`want_body_handle\*(C'\fR is the better
alternative, as it allows you to install your own event handler, reducing
resource usage.
.ie n .IP "want_body_handle => $enable" 4
.el .IP "want_body_handle => \f(CW$enable\fR" 4
.IX Item "want_body_handle => $enable"
When enabled (default is disabled), the behaviour of AnyEvent::HTTP
changes considerably: after parsing the headers, and instead of
downloading the body (if any), the completion callback will be
called. Instead of the \f(CW$body\fR argument containing the body data, the
callback will receive the AnyEvent::Handle object associated with the
connection. In error cases, \f(CW\*(C`undef\*(C'\fR will be passed. When there is no body
(e.g. status \f(CW304\fR), the empty string will be passed.
.Sp
The handle object might or might not be in \s-1TLS\s0 mode, might be connected
to a proxy, be a persistent connection, use chunked transfer encoding
etc., and configured in unspecified ways. The user is responsible for this
handle (it will not be used by this module anymore).
.Sp
This is useful with some push-type services, where, after the initial
headers, an interactive protocol is used (typical example would be the
push-style twitter \s-1API\s0 which starts a \s-1JSON/XML\s0 stream).
.Sp
If you think you need this, first have a look at \f(CW\*(C`on_body\*(C'\fR, to see if
that doesn't solve your problem in a better way.
.ie n .IP "persistent => $boolean" 4
.el .IP "persistent => \f(CW$boolean\fR" 4
.IX Item "persistent => $boolean"
Try to create/reuse a persistent connection. When this flag is set
(default: true for idempotent requests, false for all others), then
\&\f(CW\*(C`http_request\*(C'\fR tries to re-use an existing (previously-created)
persistent connection to the host and, failing that, tries to create a new
one.
.Sp
Requests failing in certain ways will be automatically retried once, which
is dangerous for non-idempotent requests, which is why it defaults to off
for them. The reason for this is because the bozos who designed \s-1HTTP/1\s0.1
made it impossible to distinguish between a fatal error and a normal
connection timeout, so you never know whether there was a problem with
your request or not.
.Sp
When reusing an existent connection, many parameters (such as \s-1TLS\s0 context)
will be ignored. See the \f(CW\*(C`session\*(C'\fR parameter for a workaround.
.ie n .IP "keepalive => $boolean" 4
.el .IP "keepalive => \f(CW$boolean\fR" 4
.IX Item "keepalive => $boolean"
Only used when \f(CW\*(C`persistent\*(C'\fR is also true. This parameter decides whether
\&\f(CW\*(C`http_request\*(C'\fR tries to handshake a \s-1HTTP/1\s0.0\-style keep-alive connection
(as opposed to only a \s-1HTTP/1\s0.1 persistent connection).
.Sp
The default is true, except when using a proxy, in which case it defaults
to false, as \s-1HTTP/1\s0.0 proxies cannot support this in a meaningful way.
.IP "handle_params => { key => value ... }" 4
.IX Item "handle_params => { key => value ... }"
The key-value pairs in this hash will be passed to any AnyEvent::Handle
constructor that is called \- not all requests will create a handle, and
sometimes more than one is created, so this parameter is only good for
setting hints.
.Sp
Example: set the maximum read size to 4096, to potentially conserve memory
at the cost of speed.
.Sp
.Vb 3
\&   handle_params => {
\&      max_read_size => 4096,
\&   },
.Ve
.RE
.RS 4
.Sp
Example: do a simple \s-1HTTP\s0 \s-1GET\s0 request for http://www.nethype.de/ and print
the response body.
.Sp
.Vb 4
\&   http_request GET => "http://www.nethype.de/", sub {
\&      my ($body, $hdr) = @_;
\&      print "$body\en";
\&   };
.Ve
.Sp
Example: do a \s-1HTTP\s0 \s-1HEAD\s0 request on https://www.google.com/, use a
timeout of 30 seconds.
.Sp
.Vb 10
\&   http_request
\&      HEAD    => "https://www.google.com",
\&      headers => { "user\-agent" => "MySearchClient 1.0" },
\&      timeout => 30,
\&      sub {
\&         my ($body, $hdr) = @_;
\&         use Data::Dumper;
\&         print Dumper $hdr;
\&      }
\&   ;
.Ve
.Sp
Example: do another simple \s-1HTTP\s0 \s-1GET\s0 request, but immediately try to
cancel it.
.Sp
.Vb 4
\&   my $request = http_request GET => "http://www.nethype.de/", sub {
\&      my ($body, $hdr) = @_;
\&      print "$body\en";
\&   };
\&
\&   undef $request;
.Ve
.RE
.SS "\s-1DNS\s0 \s-1CACHING\s0"
.IX Subsection "DNS CACHING"
AnyEvent::HTTP uses the AnyEvent::Socket::tcp_connect function for
the actual connection, which in turn uses AnyEvent::DNS to resolve
hostnames. The latter is a simple stub resolver and does no caching
on its own. If you want \s-1DNS\s0 caching, you currently have to provide
your own default resolver (by storing a suitable resolver object in
\&\f(CW$AnyEvent::DNS::RESOLVER\fR) or your own \f(CW\*(C`tcp_connect\*(C'\fR callback.
.SS "\s-1GLOBAL\s0 \s-1FUNCTIONS\s0 \s-1AND\s0 \s-1VARIABLES\s0"
.IX Subsection "GLOBAL FUNCTIONS AND VARIABLES"
.ie n .IP "AnyEvent::HTTP::set_proxy ""proxy-url""" 4
.el .IP "AnyEvent::HTTP::set_proxy ``proxy-url''" 4
.IX Item "AnyEvent::HTTP::set_proxy proxy-url"
Sets the default proxy server to use. The proxy-url must begin with a
string of the form \f(CW\*(C`http://host:port\*(C'\fR, croaks otherwise.
.Sp
To clear an already-set proxy, use \f(CW\*(C`undef\*(C'\fR.
.Sp
When AnyEvent::HTTP is laoded for the first time it will query the
default proxy from the operating system, currently by looking at
\&\f(CW\*(C`$ENV{http_proxy\*(C'\fR}.
.ie n .IP "AnyEvent::HTTP::cookie_jar_expire $jar[, $session_end]" 4
.el .IP "AnyEvent::HTTP::cookie_jar_expire \f(CW$jar\fR[, \f(CW$session_end\fR]" 4
.IX Item "AnyEvent::HTTP::cookie_jar_expire $jar[, $session_end]"
Remove all cookies from the cookie jar that have been expired. If
\&\f(CW$session_end\fR is given and true, then additionally remove all session
cookies.
.Sp
You should call this function (with a true \f(CW$session_end\fR) before you
save cookies to disk, and you should call this function after loading them
again. If you have a long-running program you can additonally call this
function from time to time.
.Sp
A cookie jar is initially an empty hash-reference that is managed by this
module. It's format is subject to change, but currently it is like this:
.Sp
The key \f(CW\*(C`version\*(C'\fR has to contain \f(CW1\fR, otherwise the hash gets
emptied. All other keys are hostnames or \s-1IP\s0 addresses pointing to
hash-references. The key for these inner hash references is the
server path for which this cookie is meant, and the values are again
hash-references. The keys of those hash-references is the cookie name, and
the value, you guessed it, is another hash-reference, this time with the
key-value pairs from the cookie, except for \f(CW\*(C`expires\*(C'\fR and \f(CW\*(C`max\-age\*(C'\fR,
which have been replaced by a \f(CW\*(C`_expires\*(C'\fR key that contains the cookie
expiry timestamp.
.Sp
Here is an example of a cookie jar with a single cookie, so you have a
chance of understanding the above paragraph:
.Sp
.Vb 11
\&   {
\&      version    => 1,
\&      "10.0.0.1" => {
\&         "/" => {
\&            "mythweb_id" => {
\&              _expires => 1293917923,
\&              value    => "ooRung9dThee3ooyXooM1Ohm",
\&            },
\&         },
\&      },
\&   }
.Ve
.ie n .IP "$date = AnyEvent::HTTP::format_date $timestamp" 4
.el .IP "\f(CW$date\fR = AnyEvent::HTTP::format_date \f(CW$timestamp\fR" 4
.IX Item "$date = AnyEvent::HTTP::format_date $timestamp"
Takes a \s-1POSIX\s0 timestamp (seconds since the epoch) and formats it as a \s-1HTTP\s0
Date (\s-1RFC\s0 2616).
.ie n .IP "$timestamp = AnyEvent::HTTP::parse_date $date" 4
.el .IP "\f(CW$timestamp\fR = AnyEvent::HTTP::parse_date \f(CW$date\fR" 4
.IX Item "$timestamp = AnyEvent::HTTP::parse_date $date"
Takes a \s-1HTTP\s0 Date (\s-1RFC\s0 2616) or a Cookie date (netscape cookie spec) or a
bunch of minor variations of those, and returns the corresponding \s-1POSIX\s0
timestamp, or \f(CW\*(C`undef\*(C'\fR if the date cannot be parsed.
.ie n .IP "$AnyEvent::HTTP::MAX_RECURSE" 4
.el .IP "\f(CW$AnyEvent::HTTP::MAX_RECURSE\fR" 4
.IX Item "$AnyEvent::HTTP::MAX_RECURSE"
The default value for the \f(CW\*(C`recurse\*(C'\fR request parameter (default: \f(CW10\fR).
.ie n .IP "$AnyEvent::HTTP::TIMEOUT" 4
.el .IP "\f(CW$AnyEvent::HTTP::TIMEOUT\fR" 4
.IX Item "$AnyEvent::HTTP::TIMEOUT"
The default timeout for connection operations (default: \f(CW300\fR).
.ie n .IP "$AnyEvent::HTTP::USERAGENT" 4
.el .IP "\f(CW$AnyEvent::HTTP::USERAGENT\fR" 4
.IX Item "$AnyEvent::HTTP::USERAGENT"
The default value for the \f(CW\*(C`User\-Agent\*(C'\fR header (the default is
\&\f(CW\*(C`Mozilla/5.0 (compatible; U; AnyEvent\-HTTP/$VERSION; +http://software.schmorp.de/pkg/AnyEvent)\*(C'\fR).
.ie n .IP "$AnyEvent::HTTP::MAX_PER_HOST" 4
.el .IP "\f(CW$AnyEvent::HTTP::MAX_PER_HOST\fR" 4
.IX Item "$AnyEvent::HTTP::MAX_PER_HOST"
The maximum number of concurrent connections to the same host (identified
by the hostname). If the limit is exceeded, then the additional requests
are queued until previous connections are closed. Both persistent and
non-persistent connections are counted in this limit.
.Sp
The default value for this is \f(CW4\fR, and it is highly advisable to not
increase it much.
.Sp
For comparison: the \s-1RFC\s0's recommend 4 non-persistent or 2 persistent
connections, older browsers used 2, newers (such as firefox 3) typically
use 6, and Opera uses 8 because like, they have the fastest browser and
give a shit for everybody else on the planet.
.ie n .IP "$AnyEvent::HTTP::PERSISTENT_TIMEOUT" 4
.el .IP "\f(CW$AnyEvent::HTTP::PERSISTENT_TIMEOUT\fR" 4
.IX Item "$AnyEvent::HTTP::PERSISTENT_TIMEOUT"
The time after which idle persistent conenctions get closed by
AnyEvent::HTTP (default: \f(CW3\fR).
.ie n .IP "$AnyEvent::HTTP::ACTIVE" 4
.el .IP "\f(CW$AnyEvent::HTTP::ACTIVE\fR" 4
.IX Item "$AnyEvent::HTTP::ACTIVE"
The number of active connections. This is not the number of currently
running requests, but the number of currently open and non-idle \s-1TCP\s0
connections. This number can be useful for load-leveling.
.SS "\s-1SHOWCASE\s0"
.IX Subsection "SHOWCASE"
This section contaisn some more elaborate \*(L"real-world\*(R" examples or code
snippets.
.SS "\s-1HTTP/1\s0.1 \s-1FILE\s0 \s-1DOWNLOAD\s0"
.IX Subsection "HTTP/1.1 FILE DOWNLOAD"
Downloading files with \s-1HTTP\s0 can be quite tricky, especially when something
goes wrong and you want to resume.
.PP
Here is a function that initiates and resumes a download. It uses the
last modified time to check for file content changes, and works with many
\&\s-1HTTP/1\s0.0 servers as well, and usually falls back to a complete re-download
on older servers.
.PP
It calls the completion callback with either \f(CW\*(C`undef\*(C'\fR, which means a
nonretryable error occured, \f(CW0\fR when the download was partial and should
be retried, and \f(CW1\fR if it was successful.
.PP
.Vb 1
\&   use AnyEvent::HTTP;
\&
\&   sub download($$$) {
\&      my ($url, $file, $cb) = @_;
\&
\&      open my $fh, "+<", $file
\&         or die "$file: $!";
\&
\&      my %hdr;
\&      my $ofs = 0;
\&
\&      warn stat $fh;
\&      warn \-s _;
\&      if (stat $fh and \-s _) {
\&         $ofs = \-s _;
\&         warn "\-s is ", $ofs;
\&         $hdr{"if\-unmodified\-since"} = AnyEvent::HTTP::format_date +(stat _)[9];
\&         $hdr{"range"} = "bytes=$ofs\-";
\&      }
\&
\&      http_get $url,
\&         headers   => \e%hdr,
\&         on_header => sub {
\&            my ($hdr) = @_;
\&
\&            if ($hdr\->{Status} == 200 && $ofs) {
\&               # resume failed
\&               truncate $fh, $ofs = 0;
\&            }
\&
\&            sysseek $fh, $ofs, 0;
\&
\&            1
\&         },
\&         on_body   => sub {
\&            my ($data, $hdr) = @_;
\&
\&            if ($hdr\->{Status} =~ /^2/) {
\&               length $data == syswrite $fh, $data
\&                  or return; # abort on write errors
\&            }
\&
\&            1
\&         },
\&         sub {
\&            my (undef, $hdr) = @_;
\&
\&            my $status = $hdr\->{Status};
\&
\&            if (my $time = AnyEvent::HTTP::parse_date $hdr\->{"last\-modified"}) {
\&               utime $fh, $time, $time;
\&            }
\&
\&            if ($status == 200 || $status == 206 || $status == 416) {
\&               # download ok || resume ok || file already fully downloaded
\&               $cb\->(1, $hdr);
\&
\&            } elsif ($status == 412) {
\&               # file has changed while resuming, delete and retry
\&               unlink $file;
\&               $cb\->(0, $hdr);
\&
\&            } elsif ($status == 500 or $status == 503 or $status =~ /^59/) {
\&               # retry later
\&               $cb\->(0, $hdr);
\&
\&            } else {
\&               $cb\->(undef, $hdr);
\&            }
\&         }
\&      ;
\&   }
\&
\&   download "http://server/somelargefile", "/tmp/somelargefile", sub {
\&      if ($_[0]) {
\&         print "OK!\en";
\&      } elsif (defined $_[0]) {
\&         print "please retry later\en";
\&      } else {
\&         print "ERROR\en";
\&      }
\&   };
.Ve
.PP
\fI\s-1SOCKS\s0 \s-1PROXIES\s0\fR
.IX Subsection "SOCKS PROXIES"
.PP
Socks proxies are not directly supported by AnyEvent::HTTP. You can
compile your perl to support socks, or use an external program such as
\&\fIsocksify\fR (dante) or \fItsocks\fR to make your program use a socks proxy
transparently.
.PP
Alternatively, for AnyEvent::HTTP only, you can use your own
\&\f(CW\*(C`tcp_connect\*(C'\fR function that does the proxy handshake \- here is an example
that works with socks4a proxies:
.PP
.Vb 4
\&   use Errno;
\&   use AnyEvent::Util;
\&   use AnyEvent::Socket;
\&   use AnyEvent::Handle;
\&
\&   # host, port and username of/for your socks4a proxy
\&   my $socks_host = "10.0.0.23";
\&   my $socks_port = 9050;
\&   my $socks_user = "";
\&
\&   sub socks4a_connect {
\&      my ($host, $port, $connect_cb, $prepare_cb) = @_;
\&
\&      my $hdl = new AnyEvent::Handle
\&         connect    => [$socks_host, $socks_port],
\&         on_prepare => sub { $prepare_cb\->($_[0]{fh}) },
\&         on_error   => sub { $connect_cb\->() },
\&      ;
\&
\&      $hdl\->push_write (pack "CCnNZ*Z*", 4, 1, $port, 1, $socks_user, $host);
\&
\&      $hdl\->push_read (chunk => 8, sub {
\&         my ($hdl, $chunk) = @_;
\&         my ($status, $port, $ipn) = unpack "xCna4", $chunk;
\&
\&         if ($status == 0x5a) {
\&            $connect_cb\->($hdl\->{fh}, (format_address $ipn) . ":$port");
\&         } else {
\&            $! = Errno::ENXIO; $connect_cb\->();
\&         }
\&      });
\&
\&      $hdl
\&   }
.Ve
.PP
Use \f(CW\*(C`socks4a_connect\*(C'\fR instead of \f(CW\*(C`tcp_connect\*(C'\fR when doing \f(CW\*(C`http_request\*(C'\fRs,
possibly after switching off other proxy types:
.PP
.Vb 1
\&   AnyEvent::HTTP::set_proxy undef; # usually you do not want other proxies
\&
\&   http_get \*(Aqhttp://www.google.com\*(Aq, tcp_connect => \e&socks4a_connect, sub {
\&      my ($data, $headers) = @_;
\&      ...
\&   };
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
AnyEvent.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\&   Marc Lehmann <schmorp@schmorp.de>
\&   http://home.schmorp.de/
.Ve
.PP
With many thanks to \*(D-X\*(D-X\*(D-XN\*~XN\*~X\*(D-X\*(D-X \*(D-X\*(D-X\*(D-X\*(D-XN\*~X\*(D-X\*(D-X, who provided countless
testcases and bugreports.
