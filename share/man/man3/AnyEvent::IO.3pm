.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent::IO 3"
.TH AnyEvent::IO 3 "2012-04-13" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::IO \- the DBI of asynchronous I/O implementations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use AnyEvent::IO;
\&
\&   # load /etc/passwd, call clalback with the file data when done.
\&   aio_load "/etc/passwd", sub {
\&      my ($data) = @_
\&         or return AE::log error => "/etc/passwd: $!";
\&
\&      warn "/etc/passwd contains ", ($data =~ y/://) , " colons.\en";
\&   };
\&
\&   # the rest of the SYNOPSIS does the same, but with individual I/O calls
\&
\&   # also import O_XXX flags
\&   use AnyEvent::IO qw(:DEFAULT :flags);
\&
\&   my $filedata = AE::cv;
\&
\&   # first open the file
\&   aio_open "/etc/passwd", O_RDONLY, 0, sub {
\&      my ($fh) = @_
\&         or return AE::log error => "/etc/passwd: $!";
\&
\&      # now stat the file to get the size
\&      aio_stat $fh, sub {
\&         @_
\&            or return AE::log error => "/etc/passwd: $!";
\&
\&         my $size = \-s _;
\&
\&         # now read all the file data
\&         aio_read $fh, $size, sub {
\&            my ($data) = @_
\&               or return AE::log error => "/etc/passwd: $!";
\&
\&            $size == length $data
\&               or return AE::log error => "/etc/passwd: short read, file changed?";
\&
\&            # mostly the same as aio_load, above \- $data contains
\&            # the file contents now.
\&            $filedata\->($data);
\&         };
\&      };
\&   };
\&
\&   my $passwd = $filedata\->recv;
\&   warn length $passwd, " octets.\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides functions that do I/O in an asynchronous fashion. It
is to to I/O the same as AnyEvent is to event libraries \- it only
\&\fIinterfaces\fR to other implementations or to a portable pure-perl
implementation (that does not, however, do asynchronous I/O).
.PP
The only such implementation that is supported (or even known to the
author) is \s-1IO::AIO\s0, which is used automatically when it can be
loaded. If it is not available, AnyEvent::IO falls back to its
(synchronous) pure-perl implementation.
.PP
Unlike AnyEvent, which model to use is currently decided at module load
time, not at first use. Future releases might change this.
.SS "\s-1RATIONALE\s0"
.IX Subsection "RATIONALE"
While disk I/O often seems \*(L"instant\*(R" compared to, say, socket I/O, there
are many situations where your program can block for extended time periods
when doing disk I/O. For example, you access a disk on an \s-1NFS\s0 server and
it is gone \- can take ages to respond again, if ever.  \s-1OR\s0 your system is
extremely busy because it creates or restores a backup \- reading data from
disk can then take seconds. Or you use Linux, which for so many years has
a close-to-broken \s-1VM/IO\s0 subsystem that can often induce minutes or more of
delay for disk I/O, even under what I would consider light I/O loads.
.PP
Whatever the situation, some programs just can't afford to block for long
times (say, half a second or more), because they need to respond as fast
as possible.
.PP
For those cases, you need asynchronous I/O.
.PP
The problem is, AnyEvent itself sometimes reads disk files (for example,
when looking at \fI/etc/hosts\fR), and under the above situations, this can
bring your program to a complete halt even if your program otherwise
takes care to only use asynchronous I/O for everything (e.g. by using
\&\s-1IO::AIO\s0).
.PP
On the other hand, requiring \s-1IO::AIO\s0 for AnyEvent is clearly
impossible, as AnyEvent promises to stay pure-perl, and the overhead of
\&\s-1IO::AIO\s0 for small programs would be immense, especially when asynchronous
I/O isn't even needed.
.PP
Clearly, this calls for an abstraction layer, and that is what you are
looking at right now :\-)
.SS "\s-1ASYNCHRONOUS\s0 \s-1VS\s0. NON-BLOCKING"
.IX Subsection "ASYNCHRONOUS VS. NON-BLOCKING"
Many people are continuously confused on what the difference is between
asynchronous I/O and non-blocking I/O. In fact, those two terms are
not well defined, which often makes it hard to even talk about the
difference. Here is a short guideline that should leave you less
confused. It only talks about read operations, but the reasoning works
with other I/O operations as well.
.PP
Non-blocking I/O means that data is delivered by some external means,
automatically \- that is, something \fIpushes\fR data towards your file
handle, without you having to do anything. Non-blocking means that if
your operating system currently has no data (or \s-1EOF\s0, or some error)
available for you, it will not wait (\*(L"block\*(R") as it would normally do,
but immediately return with an error (e.g. \f(CW\*(C`EWOULDBLOCK\*(C'\fR \- \*(L"I would have
blocked, but you forbid it\*(R").
.PP
Your program can then wait for data to arrive by other means, for example,
an I/O watcher which tells you when to re-attempt the read, after which it
can try to read again, and so on.
.PP
Often, you would expect this to work for disk files as well \- if the data
isn't already in memory, one might want to wait for it and then re-attempt
the read for example. While this is sound reasoning, the \s-1POSIX\s0 \s-1API\s0 does
not support this, because disk drives and file systems do not send data
\&\*(L"on their own\*(R", and more so, the \s-1OS\s0 already knows that data is there, it
doesn't need to \*(L"wait\*(R" until it arrives from some external entity, it only
needs to transfer the data from disk to your memory buffer.
.PP
So basically, while the concept is sound, the existing \s-1OS\s0 APIs do not
support this. Therefore, it makes no sense to switch a disk file handle
into non-blocking mode \- it will behave exactly the same as in blocking
mode, namely it will block until the data has been read from the disk.
.PP
The alternative to non-blocking I/O that actually works with disk files
is usually called \fIasynchronous I/O\fR. Asynchronous, because the actual
I/O is done while your program does something else: there is no need to
call the read function to see if data is there, you only order the read
once, and it will notify you when the read has finished and the data is
your buffer \- all the work is done in the background.
.PP
This works with disk files, and even with sockets and other sources. It
is, however, not very efficient when used with sources that could be
driven in a non-blocking way, because it usually has higher overhead
in the \s-1OS\s0 than non-blocking I/O, because it ties memory buffers for a
potentially unlimited time and often only a limited number of operations
can be done in parallel.
.PP
That's why asynchronous I/O makes most sense when confronted with disk
files, and non-blocking I/O only makes sense with sockets, pipes and
similar streaming sources.
.SH "IMPORT TAGS"
.IX Header "IMPORT TAGS"
By default, this module exports all \f(CW\*(C`aio_\*(C'\fRxxx functions. In addition,
the following import tags can be used:
.PP
.Vb 2
\&   :aio       all aio_* functions, same as :DEFAULT
\&   :flags     the fcntl open flags (O_CREAT, O_RDONLY, ...)
.Ve
.SH "API NOTES"
.IX Header "API NOTES"
The functions in this module are not meant to be the most versatile or
the highest-performers (they are not very slow either, of course). They
are primarily meant to give users of your code the option to do the I/O
asynchronously (by installing \s-1IO::AIO\s0), without adding a dependency on
that module.
.SS "\s-1NAMING\s0"
.IX Subsection "NAMING"
All the functions in this module implement an I/O operation, usually with
the same or similar name as the Perl built-in that they mimic, but with
an \f(CW\*(C`aio_\*(C'\fR prefix. If you like you can think of the \f(CW\*(C`aio_\*(C'\fRxxx functions as
\&\*(L"AnyEvent I/O\*(R" or \*(L"Asynchronous I/O\*(R" variants of Perl built-ins.
.SS "\s-1CALLING\s0 \s-1CONVENTIONS\s0 \s-1AND\s0 \s-1ERROR\s0 \s-1REPORTING\s0"
.IX Subsection "CALLING CONVENTIONS AND ERROR REPORTING"
Each function expects a callback as their last argument. The callback is
usually called with the result data or result code. An error is usually
signalled by passing no arguments to the callback, which is then free to
look at \f(CW$!\fR for the error code.
.PP
This makes all of the following forms of error checking valid:
.PP
.Vb 3
\&   aio_open ...., sub {
\&      my $fh = shift   # scalar assignment \- will assign undef on error
\&         or return AE::log error => "...";
\&
\&      my ($fh) = @_    # list assignment \- will be 0 elements on error
\&         or return AE::log error => "...";
\&
\&      @_               # check the number of elements directly
\&         or return AE::log error => "...";
.Ve
.SS "\s-1CAVEAT:\s0 \s-1RELATIVE\s0 \s-1PATHS\s0"
.IX Subsection "CAVEAT: RELATIVE PATHS"
When a path is specified, this path \fImust be an absolute\fR path, unless
you make certain that nothing in your process calls \f(CW\*(C`chdir\*(C'\fR or an
equivalent function while the request executes.
.SS "\s-1CAVEAT:\s0 \s-1OTHER\s0 \s-1SHARED\s0 \s-1STATE\s0"
.IX Subsection "CAVEAT: OTHER SHARED STATE"
Changing the \f(CW\*(C`umask\*(C'\fR while any requests execute that create files (or
otherwise rely on the current umask) results in undefined behaviour \-
likewise changing anything else that would change the outcome, such as
your effective user or group \s-1ID\s0.
.SS "\s-1CALLBACKS\s0 \s-1MIGHT\s0 \s-1BE\s0 \s-1CALLED\s0 \s-1BEFORE\s0 \s-1FUNCTION\s0 \s-1RETURNS\s0 \s-1TO\s0 \s-1CALLER\s0"
.IX Subsection "CALLBACKS MIGHT BE CALLED BEFORE FUNCTION RETURNS TO CALLER"
Unlike other functions in the AnyEvent module family, these functions
\&\fImay\fR call your callback instantly, before returning. This should not be
a real problem, as these functions never return anything useful.
.SS "\s-1BEHAVIOUR\s0 \s-1AT\s0 \s-1PROGRAM\s0 \s-1EXIT\s0"
.IX Subsection "BEHAVIOUR AT PROGRAM EXIT"
Both AnyEvent::IO::Perl and AnyEvent::IO::IOAIO implementations
make sure that operations that have started will be finished on a clean
programs exit. That makes programs work that start some I/O operations and
then exit. For example this complete program:
.PP
.Vb 1
\&   use AnyEvent::IO;
\&
\&   aio_stat "path1", sub {
\&      aio_stat "path2", sub {
\&         warn "both stats done\en";
\&      };
\&   };
.Ve
.PP
Starts a \f(CW\*(C`stat\*(C'\fR operation and then exits by \*(L"falling off the end\*(R" of
the program. Nevertheless, \fIboth\fR \f(CW\*(C`stat\*(C'\fR operations will be executed,
as AnyEvent::IO waits for all outstanding requests to finish and you can
start new requests from request callbacks.
.PP
In fact, since AnyEvent::IO::Perl is currently synchronous, the
program will do both stats before falling off the end, but with
AnyEvent::IO::IOAIO, the program first falls of the end, then the stats
are executed.
.PP
While not guaranteed, this behaviour will be present in future versions,
if reasonably possible (which is extreemly likely :).
.SH "GLOBAL VARIABLES AND FUNCTIONS"
.IX Header "GLOBAL VARIABLES AND FUNCTIONS"
.ie n .IP "$AnyEvent::IO::MODEL" 4
.el .IP "\f(CW$AnyEvent::IO::MODEL\fR" 4
.IX Item "$AnyEvent::IO::MODEL"
Contains the package name of the backend I/O model in use \- at the moment,
this is usually \f(CW\*(C`AnyEvent::IO::Perl\*(C'\fR or \f(CW\*(C`AnyEvent::IO::IOAIO\*(C'\fR.
.ie n .IP "aio_load $path, $cb\->($data)" 4
.el .IP "aio_load \f(CW$path\fR, \f(CW$cb\fR\->($data)" 4
.IX Item "aio_load $path, $cb->($data)"
Tries to open \f(CW$path\fR and read its contents into memory (obviously,
should only be used on files that are \*(L"small enough\*(R"), then passes them to
the callback as a string.
.Sp
Example: load \fI/etc/hosts\fR.
.Sp
.Vb 3
\&   aio_load "/etc/hosts", sub {
\&      my ($hosts) = @_
\&         or return AE::log error => "/etc/hosts: $!";
\&
\&      AE::log info => "/etc/hosts contains ", ($hosts =~ y/\en/), " lines\en";
\&   };
.Ve
.ie n .IP "aio_open $path, $flags, $mode, $cb\->($fh)" 4
.el .IP "aio_open \f(CW$path\fR, \f(CW$flags\fR, \f(CW$mode\fR, \f(CW$cb\fR\->($fh)" 4
.IX Item "aio_open $path, $flags, $mode, $cb->($fh)"
Tries to open the file specified by \f(CW$path\fR with the O_XXX\-flags
\&\f(CW$flags\fR (from the Fcntl module, or see below) and the mode \f(CW$mode\fR (a
good value is 0666 for \f(CW\*(C`O_CREAT\*(C'\fR, and \f(CW0\fR otherwise).
.Sp
The (normal, standard, perl) file handle associated with the opened file
is then passed to the callback.
.Sp
This works very much like Perl's \f(CW\*(C`sysopen\*(C'\fR function.
.Sp
Changing the \f(CW\*(C`umask\*(C'\fR while this request executes results in undefined
behaviour \- likewise changing anything else that would change the outcome,
such as your effective user or group \s-1ID\s0.
.Sp
To avoid having to load Fcntl, this module provides constants
for \f(CW\*(C`O_RDONLY\*(C'\fR, \f(CW\*(C`O_WRONLY\*(C'\fR, \f(CW\*(C`O_RDWR\*(C'\fR, \f(CW\*(C`O_CREAT\*(C'\fR, \f(CW\*(C`O_EXCL\*(C'\fR,
\&\f(CW\*(C`O_TRUNC\*(C'\fR and \f(CW\*(C`O_APPEND\*(C'\fR \- you can either access them directly
(\f(CW\*(C`AnyEvent::IO::O_RDONLY\*(C'\fR) or import them by specifying the \f(CW\*(C`:flags\*(C'\fR
import tag (see \s-1SYNOPSIS\s0).
.Sp
Example: securely open a file in \fI/var/tmp\fR, fail if it exists or is a symlink.
.Sp
.Vb 1
\&   use AnyEvent::IO qw(:flags);
\&
\&   aio_open "/var/tmp/mytmp$$", O_CREAT | O_EXCL | O_RDWR, 0600, sub {
\&      my ($fh) = @_
\&         or return AE::log error => "$! \- denial of service attack?";
\&
\&      # now we have $fh
\&   };
.Ve
.ie n .IP "aio_close $fh, $cb\->($success)" 4
.el .IP "aio_close \f(CW$fh\fR, \f(CW$cb\fR\->($success)" 4
.IX Item "aio_close $fh, $cb->($success)"
Closes the file handle (yes, close can block your process indefinitely)
and passes a true value to the callback on success.
.Sp
Due to idiosyncrasies in perl, instead of calling \f(CW\*(C`close\*(C'\fR, the file
handle might get closed by \f(CW\*(C`dup2\*(C'\fR'ing another file descriptor over
it, that is, the \f(CW$fh\fR might still be open, but can be closed safely
afterwards and must not be used for anything.
.Sp
Example: close a file handle, and dirty as we are, do not even bother
to check for errors.
.Sp
.Vb 1
\&   aio_close $fh, sub { };
.Ve
.ie n .IP "aio_read $fh, $length, $cb\->($data)" 4
.el .IP "aio_read \f(CW$fh\fR, \f(CW$length\fR, \f(CW$cb\fR\->($data)" 4
.IX Item "aio_read $fh, $length, $cb->($data)"
Tries to read \f(CW$length\fR octets from the current position from \f(CW$fh\fR and
passes these bytes to \f(CW$cb\fR. Otherwise the semantics are very much like
those of Perl's \f(CW\*(C`sysread\*(C'\fR.
.Sp
If less than \f(CW$length\fR octets have been read, \f(CW$data\fR will contain
only those bytes actually read. At \s-1EOF\s0, \f(CW$data\fR will be a zero-length
string. If an error occurs, then nothing is passed to the callback.
.Sp
Obviously, multiple \f(CW\*(C`aio_read\*(C'\fR's or \f(CW\*(C`aio_write\*(C'\fR's at the same time on file
handles sharing the underlying open file description results in undefined
behaviour, due to sharing of the current file offset (and less obviously
so, because \s-1OS\s0 X is not thread safe and corrupts data when you try).
.Sp
Example: read 128 octets from a file.
.Sp
.Vb 3
\&   aio_read $fh, 128, sub {
\&      my ($data) = @_
\&         or return AE::log error "read from fh: $!";
\&  
\&      if (length $data) {
\&         print "read ", length $data, " octets.\en";
\&      } else {
\&         print "EOF\en";
\&      }
\&   };
.Ve
.ie n .IP "aio_seek $fh, $offset, $whence, $callback\->($offs)" 4
.el .IP "aio_seek \f(CW$fh\fR, \f(CW$offset\fR, \f(CW$whence\fR, \f(CW$callback\fR\->($offs)" 4
.IX Item "aio_seek $fh, $offset, $whence, $callback->($offs)"
Seeks the filehandle to the new \f(CW$offset\fR, similarly to Perl's
\&\f(CW\*(C`sysseek\*(C'\fR. The \f(CW$whence\fR are the traditional values (\f(CW0\fR to count from
start, \f(CW1\fR to count from the current position and \f(CW2\fR to count from the
end).
.Sp
The resulting absolute offset will be passed to the callback on success.
.Sp
Example: measure the size of the file in the old-fashioned way using seek.
.Sp
.Vb 3
\&   aio_seek $fh, 0, 2, sub {
\&      my ($size) = @_
\&         or return AE::log error => "seek to end failed: $!";
\&
\&      # maybe we need to seek to the beginning again?
\&      aio_seek $fh, 0, 0, sub {
\&         # now we are hopefully at the beginning
\&      };
\&   };
.Ve
.ie n .IP "aio_write $fh, $data, $cb\->($length)" 4
.el .IP "aio_write \f(CW$fh\fR, \f(CW$data\fR, \f(CW$cb\fR\->($length)" 4
.IX Item "aio_write $fh, $data, $cb->($length)"
Tries to write the octets in \f(CW$data\fR to the current position of \f(CW$fh\fR
and passes the actual number of bytes written to the \f(CW$cb\fR. Otherwise the
semantics are very much like those of Perl's \f(CW\*(C`syswrite\*(C'\fR.
.Sp
If less than \f(CW\*(C`length $data\*(C'\fR octets have been written, \f(CW$length\fR will
reflect that. If an error occurs, then nothing is passed to the callback.
.Sp
Obviously, multiple \f(CW\*(C`aio_read\*(C'\fR's or \f(CW\*(C`aio_write\*(C'\fR's at the same time on file
handles sharing the underlying open file description results in undefined
behaviour, due to sharing of the current file offset (and less obviously
so, because \s-1OS\s0 X is not thread safe and corrupts data when you try).
.ie n .IP "aio_truncate $fh_or_path, $new_length, $cb\->($success)" 4
.el .IP "aio_truncate \f(CW$fh_or_path\fR, \f(CW$new_length\fR, \f(CW$cb\fR\->($success)" 4
.IX Item "aio_truncate $fh_or_path, $new_length, $cb->($success)"
Calls \f(CW\*(C`truncate\*(C'\fR on the path or perl file handle and passes a true value
to the callback on success.
.Sp
Example: truncate \fI/etc/passwd\fR to zero length \- this only works on
systems that support \f(CW\*(C`truncate\*(C'\fR, should not be tried out for obvious
reasons and debian will probably open yte another security bug about this
example.
.Sp
.Vb 4
\&   aio_truncate "/etc/passwd", sub {
\&      @_
\&         or return AE::log error => "/etc/passwd: $! \- are you root enough?";
\&   };
.Ve
.ie n .IP "aio_utime $fh_or_path, $atime, $mtime, $cb\->($success)" 4
.el .IP "aio_utime \f(CW$fh_or_path\fR, \f(CW$atime\fR, \f(CW$mtime\fR, \f(CW$cb\fR\->($success)" 4
.IX Item "aio_utime $fh_or_path, $atime, $mtime, $cb->($success)"
Calls \f(CW\*(C`utime\*(C'\fR on the path or perl file handle and passes a true value to
the callback on success.
.Sp
The special case of both \f(CW$atime\fR and \f(CW$mtime\fR being \f(CW\*(C`undef\*(C'\fR sets the
times to the current time, on systems that support this.
.Sp
Example: try to touch \fIfile\fR.
.Sp
.Vb 1
\&   aio_utime "file", undef, undef, sub { };
.Ve
.ie n .IP "aio_chown $fh_or_path, $uid, $gid, $cb\->($success)" 4
.el .IP "aio_chown \f(CW$fh_or_path\fR, \f(CW$uid\fR, \f(CW$gid\fR, \f(CW$cb\fR\->($success)" 4
.IX Item "aio_chown $fh_or_path, $uid, $gid, $cb->($success)"
Calls \f(CW\*(C`chown\*(C'\fR on the path or perl file handle and passes a true value to
the callback on success.
.Sp
If \f(CW$uid\fR or \f(CW$gid\fR can be specified as \f(CW\*(C`undef\*(C'\fR, in which case the
uid or gid of the file is not changed. This differs from Perl's \f(CW\*(C`chown\*(C'\fR
built-in, which wants \f(CW\*(C`\-1\*(C'\fR for this.
.Sp
Example: update the group of \fIfile\fR to 0 (root), but leave the owner alone.
.Sp
.Vb 4
\&   aio_chown "file", undef, 0, sub {
\&      @_
\&         or return AE::log error => "chown \*(Aqfile\*(Aq: $!";
\&   };
.Ve
.ie n .IP "aio_chmod $fh_or_path, $perms, $cb\->($success)" 4
.el .IP "aio_chmod \f(CW$fh_or_path\fR, \f(CW$perms\fR, \f(CW$cb\fR\->($success)" 4
.IX Item "aio_chmod $fh_or_path, $perms, $cb->($success)"
Calls \f(CW\*(C`chmod\*(C'\fR on the path or perl file handle and passes a true value to
the callback on success.
.Sp
Example: change \fIfile\fR to be user/group/world\-readable, but leave the other flags
alone.
.Sp
.Vb 3
\&   aio_stat "file", sub {
\&      @_
\&         or return AE::log error => "file: $!";
\&
\&      aio_chmod "file", (stat _)[2] & 07777 | 00444, sub { };
\&   };
.Ve
.ie n .IP "aio_stat $fh_or_path, $cb\->($success)" 4
.el .IP "aio_stat \f(CW$fh_or_path\fR, \f(CW$cb\fR\->($success)" 4
.IX Item "aio_stat $fh_or_path, $cb->($success)"
.PD 0
.ie n .IP "aio_lstat $path, $cb\->($success)" 4
.el .IP "aio_lstat \f(CW$path\fR, \f(CW$cb\fR\->($success)" 4
.IX Item "aio_lstat $path, $cb->($success)"
.PD
Calls \f(CW\*(C`stat\*(C'\fR or \f(CW\*(C`lstat\*(C'\fR on the path or perl file handle and passes a
true value to the callback on success.
.Sp
The stat data will be available by \f(CW\*(C`stat\*(C'\fR'ing the \f(CW\*(C`_\*(C'\fR file handle
(e.g. \f(CW\*(C`\-x _\*(C'\fR, \f(CW\*(C`stat _\*(C'\fR and so on).
.Sp
Example: see if we can find the number of subdirectories of \fI/etc\fR.
.Sp
.Vb 3
\&   aio_stat "/etc", sub {
\&      @_
\&         or return AE::log error => "/etc: $!";
\&
\&      (stat _)[3] >= 2
\&         or return AE::log warn => "/etc has low link count \- non\-POSIX filesystem?";
\&
\&      print "/etc has ", (stat _)[3] \- 2, " subdirectories.\en";
\&   };
.Ve
.ie n .IP "aio_link $oldpath, $newpath, $cb\->($success)" 4
.el .IP "aio_link \f(CW$oldpath\fR, \f(CW$newpath\fR, \f(CW$cb\fR\->($success)" 4
.IX Item "aio_link $oldpath, $newpath, $cb->($success)"
Calls \f(CW\*(C`link\*(C'\fR on the paths and passes a true value to the callback on
success.
.Sp
Example: link "\fIfile\fR to \fIfile.bak\fR, then rename \fIfile.new\fR over \fIfile\fR,
to atomically replace it.
.Sp
.Vb 3
\&   aio_link "file", "file.bak", sub {
\&      @_
\&         or return AE::log error => "file: $!";
\&
\&      aio_rename "file.new", "file", sub {
\&         @_
\&            or return AE::log error => "file.new: $!";
\&
\&         print "file atomically replaced by file.new, backup file.bak\en";
\&      };
\&   };
.Ve
.ie n .IP "aio_symlink $oldpath, $newpath, $cb\->($success)" 4
.el .IP "aio_symlink \f(CW$oldpath\fR, \f(CW$newpath\fR, \f(CW$cb\fR\->($success)" 4
.IX Item "aio_symlink $oldpath, $newpath, $cb->($success)"
Calls \f(CW\*(C`symlink\*(C'\fR on the paths and passes a true value to the callback on
success.
.Sp
Example: create a symlink "\fIslink\fR containing \*(L"random data\*(R".
.Sp
.Vb 4
\&   aio_symlink "random data", "slink", sub {
\&      @_
\&         or return AE::log error => "slink: $!";
\&   };
.Ve
.ie n .IP "aio_readlink $path, $cb\->($target)" 4
.el .IP "aio_readlink \f(CW$path\fR, \f(CW$cb\fR\->($target)" 4
.IX Item "aio_readlink $path, $cb->($target)"
Calls \f(CW\*(C`readlink\*(C'\fR on the paths and passes the link target string to the
callback.
.Sp
Example: read the symlink called Fyslink> and verify that it contains \*(L"random data\*(R".
.Sp
.Vb 3
\&  aio_readlink "slink", sub {
\&     my ($target) = @_
\&        or return AE::log error => "slink: $!";
\&
\&     $target eq "random data"
\&        or AE::log critical => "omg, the world will end!";
\&  };
.Ve
.ie n .IP "aio_rename $oldpath, $newpath, $cb\->($success)" 4
.el .IP "aio_rename \f(CW$oldpath\fR, \f(CW$newpath\fR, \f(CW$cb\fR\->($success)" 4
.IX Item "aio_rename $oldpath, $newpath, $cb->($success)"
Calls \f(CW\*(C`rename\*(C'\fR on the paths and passes a true value to the callback on
success.
.Sp
See \f(CW\*(C`aio_link\*(C'\fR for an example.
.ie n .IP "aio_unlink $path, $cb\->($success)" 4
.el .IP "aio_unlink \f(CW$path\fR, \f(CW$cb\fR\->($success)" 4
.IX Item "aio_unlink $path, $cb->($success)"
Tries to unlink the object at \f(CW$path\fR and passes a true value to the
callback on success.
.Sp
Example: try to delete the file \fItmpfile.dat~\fR.
.Sp
.Vb 1
\&   aio_unlink "tmpfile.dat~", sub { };
.Ve
.ie n .IP "aio_mkdir $path, $perms, $cb\->($success)" 4
.el .IP "aio_mkdir \f(CW$path\fR, \f(CW$perms\fR, \f(CW$cb\fR\->($success)" 4
.IX Item "aio_mkdir $path, $perms, $cb->($success)"
Calls \f(CW\*(C`mkdir\*(C'\fR on the path with the given permissions \f(CW$perms\fR (when in
doubt, \f(CW0777\fR is a good value) and passes a true value to the callback on
success.
.Sp
Example: try to create the directory \fIsubdir\fR and leave it to whoeveer
comes after us to check whether it worked.
.Sp
.Vb 1
\&   aio_mkdir "subdir", 0777, sub { };
.Ve
.ie n .IP "aio_rmdir $path, $cb\->($success)" 4
.el .IP "aio_rmdir \f(CW$path\fR, \f(CW$cb\fR\->($success)" 4
.IX Item "aio_rmdir $path, $cb->($success)"
Tries to remove the directory at \f(CW$path\fR and passes a true value to the
callback on success.
.Sp
Example: try to remove the directory \fIsubdir\fR and don't give a damn if
that fails.
.Sp
.Vb 1
\&   aio_rmdir "subdir", sub { };
.Ve
.ie n .IP "aio_readdir $path, $cb\->(\e@names)" 4
.el .IP "aio_readdir \f(CW$path\fR, \f(CW$cb\fR\->(\e@names)" 4
.IX Item "aio_readdir $path, $cb->(@names)"
Reads all filenames from the directory specified by \f(CW$path\fR and passes
them to the callback, as an array reference with the names (without a path
prefix). The \fI.\fR and \fI..\fR names will be filtered out first.
.Sp
The ordering of the file names is undefined \- backends that are capable
of it (e.g. \s-1IO::AIO\s0) will return the ordering that most likely is
fastest to \f(CW\*(C`stat\*(C'\fR through, and furthermore put entries that likely are
directories first in the array.
.Sp
If you need best performance in recursive directory traversal or when
looking at really big directories, you are advised to use \s-1IO::AIO\s0
directly, specifically the \f(CW\*(C`aio_readdirx\*(C'\fR and \f(CW\*(C`aio_scandir\*(C'\fR functions,
which have more options to tune performance.
.Sp
Example: recursively scan a directory hierarchy, silently skip diretcories
we couldn't read and print all others.
.Sp
.Vb 3
\&   sub scan($); # visibility\-in\-next statement is not so useful these days
\&   sub scan($) {
\&      my ($path) = @_;
\&
\&      aio_readdir $path, sub {
\&         my ($names) = @_
\&            or return;
\&
\&         print "$path\en";
\&
\&         for my $name (@$names) {
\&            aio_lstat "$path/$name", sub {
\&               scan "$path/$name"
\&                  if \-d _;
\&            };
\&         }
\&      };
\&   }
\&
\&   scan "/etc";
.Ve
.SH "ENVIRONMENT VARIABLES"
.IX Header "ENVIRONMENT VARIABLES"
See the description of \f(CW\*(C`PERL_ANYEVENT_IO_MODEL\*(C'\fR in the AnyEvent
manpage.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>
\& http://anyevent.schmorp.de
.Ve
