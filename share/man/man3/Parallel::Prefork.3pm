.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parallel::Prefork 3"
.TH Parallel::Prefork 3 "2011-10-27" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parallel::Prefork \- A simple prefork server framework
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Parallel::Prefork;
\&  
\&  my $pm = Parallel::Prefork\->new({
\&    max_workers  => 10,
\&    trap_signals => {
\&      TERM => \*(AqTERM\*(Aq,
\&      HUP  => \*(AqTERM\*(Aq,
\&      USR1 => undef,
\&    }
\&  });
\&  
\&  while ($pm\->signal_received ne \*(AqTERM\*(Aq) {
\&    load_config();
\&    $pm\->start(sub {
\&        ... do some work within the child process ...
\&    });
\&  }
\&  
\&  $pm\->wait_all_children();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Parallel::Prefork\*(C'\fR is much like \f(CW\*(C`Parallel::ForkManager\*(C'\fR, but supports graceful shutdown and run-time reconfiguration.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
instantiation.  Takes a hashref as an argument.  Recognized attributes are as follows.
.PP
\fImax_workers\fR
.IX Subsection "max_workers"
.PP
number of worker processes (default: 10)
.PP
\fIspawn_interval\fR
.IX Subsection "spawn_interval"
.PP
interval in seconds between spawning child processes unless a child process exits abnormally (default: 0)
.PP
\fIerr_respawn_interval\fR
.IX Subsection "err_respawn_interval"
.PP
number of seconds to deter spawning of child processes after a worker exits abnormally (default: 1)
.PP
\fItrap_signals\fR
.IX Subsection "trap_signals"
.PP
hashref of signals to be trapped.  Manager process will trap the signals listed in the keys of the hash, and send the signal specified in the associated value (if any) to all worker processes.  If the associated value is a scalar then it is treated as the name of the signal to be sent immediately to all the worker processes.  If the value is an arrayref the first value is treated the name of the signal and the second value is treated as the interval (in seconds) between sending the signal to each worker process.
.PP
\fIon_child_reap\fR
.IX Subsection "on_child_reap"
.PP
coderef that is called when a child is reaped. Receives the instance to
the current Paralle::Prefork, the child's pid, and its exit status.
.PP
\fIbefore_fork\fR
.IX Subsection "before_fork"
.PP
\fIafter_fork\fR
.IX Subsection "after_fork"
.PP
coderefs that are called in the manager process before and after fork, if being set
.SS "start"
.IX Subsection "start"
The main routine.  There are two ways to use the function.
.PP
If given a subref as an argument, forks child processes and executes that subref within the child processes.  The processes will exit with 0 status when the subref returns.
.PP
The other way is to not give any arguments to the function.  The function returns undef in child processes.  Caller should execute the application logic and then call \f(CW\*(C`finish\*(C'\fR to terminate the process.
.PP
The \f(CW\*(C`start\*(C'\fR function returns true within manager process upon receiving a signal specified in the \f(CW\*(C`trap_signals\*(C'\fR hashref.
.SS "finish"
.IX Subsection "finish"
Child processes (when executed by a zero-argument call to \f(CW\*(C`start\*(C'\fR) should call this function for termination.  Takes exit code as an optional argument.  Only usable from child processes.
.SS "signal_all_children"
.IX Subsection "signal_all_children"
Sends signal to all worker processes.  Only usable from manager process.
.SS "wait_all_children"
.IX Subsection "wait_all_children"
Blocks until all worker processes exit.  Only usable from manager process.
.SH "AUTHOR"
.IX Header "AUTHOR"
Kazuho Oku
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
.PP
See http://www.perl.com/perl/misc/Artistic.html
