.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mouse 3pm"
.TH Mouse 3pm "2011-10-09" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mouse \- Moose minus the antlers
.SH "VERSION"
.IX Header "VERSION"
This document describes Mouse version 0.97
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    package Point;
\&    use Mouse; # automatically turns on strict and warnings
\&
\&    has \*(Aqx\*(Aq => (is => \*(Aqrw\*(Aq, isa => \*(AqInt\*(Aq);
\&    has \*(Aqy\*(Aq => (is => \*(Aqrw\*(Aq, isa => \*(AqInt\*(Aq);
\&
\&    sub clear {
\&        my $self = shift;
\&        $self\->x(0);
\&        $self\->y(0);
\&    }
\&
\&
\&    _\|_PACKAGE_\|_\->meta\->make_immutable();
\&
\&    package Point3D;
\&    use Mouse;
\&
\&    extends \*(AqPoint\*(Aq;
\&
\&    has \*(Aqz\*(Aq => (is => \*(Aqrw\*(Aq, isa => \*(AqInt\*(Aq);
\&
\&    after \*(Aqclear\*(Aq => sub {
\&        my $self = shift;
\&        $self\->z(0);
\&    };
\&
\&    _\|_PACKAGE_\|_\->meta\->make_immutable();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Moose is a postmodern object system for Perl5. Moose is wonderful.
.PP
Unfortunately, Moose has a compile-time penalty. Though significant progress
has been made over the years, the compile time penalty is a non-starter for
some very specific applications. If you are writing a command-line application
or \s-1CGI\s0 script where startup time is essential, you may not be able to use
Moose (we recommend that you instead use persistent Perl executing environments
like \f(CW\*(C`FastCGI\*(C'\fR for the latter, if possible).
.PP
Mouse is a Moose compatible object system, which aims to alleviate this penalty
by providing a subset of Moose's functionality.
.PP
We're also going as light on dependencies as possible. Mouse currently has
\&\fBno dependencies\fR except for building/testing modules. Mouse also works
without \s-1XS\s0, although it has an \s-1XS\s0 backend to make it much faster.
.SS "Moose Compatibility"
.IX Subsection "Moose Compatibility"
Compatibility with Moose has been the utmost concern. The sugary interface is
highly compatible with Moose. Even the error messages are taken from Moose.
The Mouse code just runs its test suite 4x faster.
.PP
The idea is that, if you need the extra power, you should be able to run
\&\f(CW\*(C`s/Mouse/Moose/g\*(C'\fR on your codebase and have nothing break. To that end,
we have written Any::Moose which will act as Mouse unless Moose is loaded,
in which case it will act as Moose. Since Mouse is a little sloppier than
Moose, if you run into weird errors, it would be worth running:
.PP
.Vb 1
\&    ANY_MOOSE=Moose perl your\-script.pl
.Ve
.PP
to see if the bug is caused by Mouse. Moose's diagnostics and validation are
also better.
.PP
See also Mouse::Spec for compatibility and incompatibility with Moose.
.SS "Mouse Extentions"
.IX Subsection "Mouse Extentions"
Please don't copy MooseX code to MouseX. If you need extensions, you really
should upgrade to Moose. We don't need two parallel sets of extensions!
.PP
If you really must write a Mouse extension, please contact the Moose mailing
list or #moose on \s-1IRC\s0 beforehand.
.SH "KEYWORDS"
.IX Header "KEYWORDS"
.ie n .SS """$object\->meta \-> Mouse::Meta::Class"""
.el .SS "\f(CW$object\->meta \-> Mouse::Meta::Class\fP"
.IX Subsection "$object->meta -> Mouse::Meta::Class"
Returns this class' metaclass instance.
.ie n .SS """extends superclasses"""
.el .SS "\f(CWextends superclasses\fP"
.IX Subsection "extends superclasses"
Sets this class' superclasses.
.ie n .SS """before (method|methods|regexp) => CodeRef"""
.el .SS "\f(CWbefore (method|methods|regexp) => CodeRef\fP"
.IX Subsection "before (method|methods|regexp) => CodeRef"
Installs a \*(L"before\*(R" method modifier. See \*(L"before\*(R" in Moose.
.ie n .SS """after (method|methods|regexp) => CodeRef"""
.el .SS "\f(CWafter (method|methods|regexp) => CodeRef\fP"
.IX Subsection "after (method|methods|regexp) => CodeRef"
Installs an \*(L"after\*(R" method modifier. See \*(L"after\*(R" in Moose.
.ie n .SS """around (method|methods|regexp) => CodeRef"""
.el .SS "\f(CWaround (method|methods|regexp) => CodeRef\fP"
.IX Subsection "around (method|methods|regexp) => CodeRef"
Installs an \*(L"around\*(R" method modifier. See \*(L"around\*(R" in Moose.
.ie n .SS """has (name|names) => parameters"""
.el .SS "\f(CWhas (name|names) => parameters\fP"
.IX Subsection "has (name|names) => parameters"
Adds an attribute (or if passed an arrayref of names, multiple attributes) to
this class. Options:
.ie n .IP """is => ro|rw|bare""" 4
.el .IP "\f(CWis => ro|rw|bare\fR" 4
.IX Item "is => ro|rw|bare"
The \fIis\fR option accepts either \fIrw\fR (for read/write), \fIro\fR (for read
only) or \fIbare\fR (for nothing). These will create either a read/write accessor
or a read-only accessor respectively, using the same name as the \f(CW$name\fR of
the attribute.
.Sp
If you need more control over how your accessors are named, you can
use the \f(CW\*(C`reader\*(C'\fR, \f(CW\*(C`writer\*(C'\fR and \f(CW\*(C`accessor\*(C'\fR options, however if you
use those, you won't need the \fIis\fR option.
.ie n .IP """isa => TypeName | ClassName""" 4
.el .IP "\f(CWisa => TypeName | ClassName\fR" 4
.IX Item "isa => TypeName | ClassName"
Provides type checking in the constructor and accessor. The following types are
supported. Any unknown type is taken to be a class check
(e.g. \f(CW\*(C`isa => \*(AqDateTime\*(Aq\*(C'\fR would accept only DateTime objects).
.Sp
.Vb 3
\&    Any Item Bool Undef Defined Value Num Int Str ClassName
\&    Ref ScalarRef ArrayRef HashRef CodeRef RegexpRef GlobRef
\&    FileHandle Object
.Ve
.Sp
For more documentation on type constraints, see Mouse::Util::TypeConstraints.
.ie n .IP """does => RoleName""" 4
.el .IP "\f(CWdoes => RoleName\fR" 4
.IX Item "does => RoleName"
This will accept the name of a role which the value stored in this attribute
is expected to have consumed.
.ie n .IP """coerce => Bool""" 4
.el .IP "\f(CWcoerce => Bool\fR" 4
.IX Item "coerce => Bool"
This will attempt to use coercion with the supplied type constraint to change
the value passed into any accessors or constructors. You \fBmust\fR have supplied
a type constraint in order for this to work. See Moose::Cookbook::Basics::Recipe5
for an example.
.ie n .IP """required => Bool""" 4
.el .IP "\f(CWrequired => Bool\fR" 4
.IX Item "required => Bool"
Whether this attribute is required to have a value. If the attribute is lazy or
has a builder, then providing a value for the attribute in the constructor is
optional.
.ie n .IP """init_arg => Str | Undef""" 4
.el .IP "\f(CWinit_arg => Str | Undef\fR" 4
.IX Item "init_arg => Str | Undef"
Allows you to use a different key name in the constructor.  If undef, the
attribute can't be passed to the constructor.
.ie n .IP """default => Value | CodeRef""" 4
.el .IP "\f(CWdefault => Value | CodeRef\fR" 4
.IX Item "default => Value | CodeRef"
Sets the default value of the attribute. If the default is a coderef, it will
be invoked to get the default value. Due to quirks of Perl, any bare reference
is forbidden, you must wrap the reference in a coderef. Otherwise, all
instances will share the same reference.
.ie n .IP """lazy => Bool""" 4
.el .IP "\f(CWlazy => Bool\fR" 4
.IX Item "lazy => Bool"
If specified, the default is calculated on demand instead of in the
constructor.
.ie n .IP """predicate => Str""" 4
.el .IP "\f(CWpredicate => Str\fR" 4
.IX Item "predicate => Str"
Lets you specify a method name for installing a predicate method, which checks
that the attribute has a value. It will not invoke a lazy default or builder
method.
.ie n .IP """clearer => Str""" 4
.el .IP "\f(CWclearer => Str\fR" 4
.IX Item "clearer => Str"
Lets you specify a method name for installing a clearer method, which clears
the attribute's value from the instance. On the next read, lazy or builder will
be invoked.
.ie n .IP """handles => HashRef|ArrayRef|Regexp""" 4
.el .IP "\f(CWhandles => HashRef|ArrayRef|Regexp\fR" 4
.IX Item "handles => HashRef|ArrayRef|Regexp"
Lets you specify methods to delegate to the attribute. ArrayRef forwards the
given method names to method calls on the attribute. HashRef maps local method
names to remote method names called on the attribute. Other forms of
\&\*(L"handles\*(R", such as RoleName and CodeRef, are not yet supported.
.ie n .IP """weak_ref => Bool""" 4
.el .IP "\f(CWweak_ref => Bool\fR" 4
.IX Item "weak_ref => Bool"
Lets you automatically weaken any reference stored in the attribute.
.Sp
Use of this feature requires Scalar::Util!
.ie n .IP """trigger => CodeRef""" 4
.el .IP "\f(CWtrigger => CodeRef\fR" 4
.IX Item "trigger => CodeRef"
Any time the attribute's value is set (either through the accessor or the constructor), the trigger is called on it. The trigger receives as arguments the instance, the new value, and the attribute instance.
.ie n .IP """builder => Str""" 4
.el .IP "\f(CWbuilder => Str\fR" 4
.IX Item "builder => Str"
Defines a method name to be called to provide the default value of the
attribute. \f(CW\*(C`builder => \*(Aqbuild_foo\*(Aq\*(C'\fR is mostly equivalent to
\&\f(CW\*(C`default => sub { $_[0]\->build_foo }\*(C'\fR.
.ie n .IP """auto_deref => Bool""" 4
.el .IP "\f(CWauto_deref => Bool\fR" 4
.IX Item "auto_deref => Bool"
Allows you to automatically dereference ArrayRef and HashRef attributes in list
context. In scalar context, the reference is returned (\s-1NOT\s0 the list length or
bucket status). You must specify an appropriate type constraint to use
auto_deref.
.ie n .IP """lazy_build => Bool""" 4
.el .IP "\f(CWlazy_build => Bool\fR" 4
.IX Item "lazy_build => Bool"
Automatically define the following options:
.Sp
.Vb 7
\&    has $attr => (
\&        # ...
\&        lazy      => 1
\&        builder   => "_build_$attr",
\&        clearer   => "clear_$attr",
\&        predicate => "has_$attr",
\&    );
.Ve
.ie n .SS """confess(message) \-> BOOM"""
.el .SS "\f(CWconfess(message) \-> BOOM\fP"
.IX Subsection "confess(message) -> BOOM"
\&\*(L"confess\*(R" in Carp for your convenience.
.ie n .SS """blessed(value) \-> ClassName | undef"""
.el .SS "\f(CWblessed(value) \-> ClassName | undef\fP"
.IX Subsection "blessed(value) -> ClassName | undef"
\&\*(L"blessed\*(R" in Scalar::Util for your convenience.
.SH "MISC"
.IX Header "MISC"
.SS "import"
.IX Subsection "import"
Importing Mouse will default your class' superclass list to Mouse::Object.
You may use \*(L"extends\*(R" to replace the superclass list.
.SS "unimport"
.IX Subsection "unimport"
Please unimport Mouse (\f(CW\*(C`no Mouse\*(C'\fR) so that if someone calls one of the
keywords (such as \*(L"extends\*(R") it will break loudly instead breaking subtly.
.SH "SOURCE CODE ACCESS"
.IX Header "SOURCE CODE ACCESS"
We have a public git repository:
.PP
.Vb 1
\& git clone git://git.moose.perl.org/Mouse.git
.Ve
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
Perl 5.6.2 or later.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mouse::Role
.PP
Mouse::Spec
.PP
Moose
.PP
Moose::Manual
.PP
Moose::Cookbook
.PP
Class::MOP
.SH "AUTHORS"
.IX Header "AUTHORS"
Shawn M Moore <sartak at gmail.com>
.PP
Yuval Kogman <nothingmuch at woobling.org>
.PP
tokuhirom
.PP
Yappo
.PP
wu-lee
.PP
Goro Fuji (gfx) <gfuji at cpan.org>
.PP
with plenty of code borrowed from Class::MOP and Moose
.SH "BUGS"
.IX Header "BUGS"
All complex software has bugs lurking in it, and this module is no exception.
Please report any bugs to \f(CW\*(C`bug\-mouse at rt.cpan.org\*(C'\fR, or through the web
interface at <http://rt.cpan.org/Public/Dist/Display.html?Name=Mouse>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 2008\-2010 Infinity Interactive, Inc.
.PP
http://www.iinteractive.com/
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
