.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AE 3"
.TH AE 3 "2012-04-08" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
AE \- simpler/faster/newer/cooler AnyEvent API
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use AnyEvent; # not AE
\&
\&  # file handle or descriptor readable
\&  my $w = AE::io $fh, 0, sub { ...  };
\&
\&  # one\-shot or repeating timers
\&  my $w = AE::timer $seconds,         0, sub { ... }; # once
\&  my $w = AE::timer $seconds, $interval, sub { ... }; # repeated
\&
\&  print AE::now;  # prints current event loop time
\&  print AE::time; # think Time::HiRes::time or simply CORE::time.
\&
\&  # POSIX signal
\&  my $w = AE::signal TERM => sub { ... };
\&
\&  # child process exit
\&  my $w = AE::child $pid, sub {
\&     my ($pid, $status) = @_;
\&     ...
\&  };
\&
\&  # called when event loop idle (if applicable)
\&  my $w = AE::idle sub { ... };
\&
\&  my $cv = AE::cv; # stores whether a condition was flagged
\&  $cv\->send; # wake up current and all future recv\*(Aqs
\&  $cv\->recv; # enters "main loop" till $condvar gets \->send
\&  # use a condvar in callback mode:
\&  $cv\->cb (sub { $_[0]\->recv });
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module documents the new simpler AnyEvent \s-1API\s0.
.PP
The rationale for the new \s-1API\s0 is that experience with \s-1EV\s0 shows that
this \s-1API\s0 actually \*(L"works\*(R", despite its lack of extensibility, leading to
a shorter, easier and faster \s-1API\s0.
.PP
The main differences from AnyEvent is that function calls are used
instead of method calls, and that no named arguments are used.
.PP
This makes calls to watcher creation functions really short, which can
make a program more readable despite the lack of named parameters.
Function calls also allow more static type checking than method calls, so
many mistakes are caught at compile-time with this \s-1API\s0.
.PP
Also, some backends (Perl and \s-1EV\s0) are so fast that the method call
overhead is very noticeable (with \s-1EV\s0 it increases the execution time five\-
to six-fold, with Perl the method call overhead is about a factor of two).
.PP
Note that the \f(CW\*(C`AE\*(C'\fR \s-1API\s0 is an alternative to, not the future version of,
the AnyEvent \s-1API\s0. Both APIs can be used interchangeably and there are
no plans to \*(L"switch\*(R", so if in doubt, feel free to use the AnyEvent
\&\s-1API\s0 in new code.
.PP
As the \s-1AE\s0 \s-1API\s0 is complementary, not everything in the AnyEvent \s-1API\s0 is
available, and you still need to use AnyEvent for the finer stuff. Also,
you should not \f(CW\*(C`use AE\*(C'\fR directly, \f(CW\*(C`use AnyEvent\*(C'\fR will provide the \s-1AE\s0
namespace.
.PP
At the moment, these functions will become slower then their method-call
counterparts when using AnyEvent::Strict or AnyEvent::Debug::wrap.
.SS "\s-1FUNCTIONS\s0"
.IX Subsection "FUNCTIONS"
This section briefly describes the alternative watcher constructors and
other functions available inside the \f(CW\*(C`AE\*(C'\fR namespace. Semantics are not
described here; please refer to the description of the function or method
with the same name in the AnyEvent manpage for the details.
.ie n .IP "$w = AE::io $fh_or_fd, $watch_write, $cb" 4
.el .IP "\f(CW$w\fR = AE::io \f(CW$fh_or_fd\fR, \f(CW$watch_write\fR, \f(CW$cb\fR" 4
.IX Item "$w = AE::io $fh_or_fd, $watch_write, $cb"
Creates an I/O watcher that listens for read events (\f(CW$watch_write\fR
false) or write events (\f(CW$watch_write\fR is true) on the file handle or
file descriptor \f(CW$fh_or_fd\fR.
.Sp
The callback \f(CW$cb\fR is invoked as soon and as long as I/O of the type
specified by \f(CW$watch_write\fR) can be done on the file handle/descriptor.
.Sp
Example: wait until \s-1STDIN\s0 becomes readable.
.Sp
.Vb 1
\&  $stdin_ready = AE::io *STDIN, 0, sub { scalar <STDIN> };
.Ve
.Sp
Example: wait until \s-1STDOUT\s0 becomes writable and print something.
.Sp
.Vb 1
\&  $stdout_ready = AE::io *STDOUT, 1, sub { print STDOUT "woaw\en" };
.Ve
.ie n .IP "$w = AE::timer $after, $interval, $cb" 4
.el .IP "\f(CW$w\fR = AE::timer \f(CW$after\fR, \f(CW$interval\fR, \f(CW$cb\fR" 4
.IX Item "$w = AE::timer $after, $interval, $cb"
Creates a timer watcher that invokes the callback \f(CW$cb\fR after at least
\&\f(CW$after\fR second have passed (\f(CW$after\fR can be negative or \f(CW0\fR).
.Sp
If \f(CW$interval\fR is \f(CW0\fR, then the callback will only be invoked once,
otherwise it must be a positive number of seconds that specifies the
interval between successive invocations of the callback.
.Sp
Example: print \*(L"too late\*(R" after at least one second has passed.
.Sp
.Vb 1
\&  $timer_once = AE::timer 1, 0, sub { print "too late\en" };
.Ve
.Sp
Example: print \*(L"blubb\*(R" once a second, starting as soon as possible.
.Sp
.Vb 1
\&  $timer_repeated = AE::timer 0, 1, sub { print "blubb\en" };
.Ve
.ie n .IP "$w = AE::signal $signame, $cb" 4
.el .IP "\f(CW$w\fR = AE::signal \f(CW$signame\fR, \f(CW$cb\fR" 4
.IX Item "$w = AE::signal $signame, $cb"
Invoke the callback \f(CW$cb\fR each time one or more occurrences of the
named signal \f(CW$signame\fR are detected.
.ie n .IP "$w = AE::child $pid, $cb" 4
.el .IP "\f(CW$w\fR = AE::child \f(CW$pid\fR, \f(CW$cb\fR" 4
.IX Item "$w = AE::child $pid, $cb"
Invokes the callback \f(CW$cb\fR when the child with the given \f(CW$pid\fR exits
(or all children, when \f(CW$pid\fR is zero).
.Sp
The callback will get the actual pid and exit status as arguments.
.ie n .IP "$w = AE::idle $cb" 4
.el .IP "\f(CW$w\fR = AE::idle \f(CW$cb\fR" 4
.IX Item "$w = AE::idle $cb"
Invoke the callback \f(CW$cb\fR each time the event loop is \*(L"idle\*(R" (has no
events outstanding), but do not prevent the event loop from polling for
more events.
.ie n .IP "$cv = AE::cv" 4
.el .IP "\f(CW$cv\fR = AE::cv" 4
.IX Item "$cv = AE::cv"
.PD 0
.ie n .IP "$cv = AE::cv { \s-1BLOCK\s0 }" 4
.el .IP "\f(CW$cv\fR = AE::cv { \s-1BLOCK\s0 }" 4
.IX Item "$cv = AE::cv { BLOCK }"
.PD
Create a new condition variable. The first form is identical to \f(CW\*(C`AnyEvent\->condvar\*(C'\fR, the second form additionally sets the callback (as
if the \f(CW\*(C`cb\*(C'\fR method is called on the condition variable).
.IP "AE::now" 4
.IX Item "AE::now"
Returns the current event loop time (may be cached by the event loop).
.IP "AE::now_update" 4
.IX Item "AE::now_update"
Ensures that the current event loop time is up to date.
.IP "AE::time" 4
.IX Item "AE::time"
Return the current time (not cached, always consults a hardware clock).
.IP "AE::postpone { \s-1BLOCK\s0 }" 4
.IX Item "AE::postpone { BLOCK }"
Exactly the same as \f(CW\*(C`AnyEvent:::postpone\*(C'\fR.
.ie n .IP "AE::log $level, $msg[, @args]" 4
.el .IP "AE::log \f(CW$level\fR, \f(CW$msg\fR[, \f(CW@args\fR]" 4
.IX Item "AE::log $level, $msg[, @args]"
Exactly the same as \f(CW\*(C`AnyEvent::log\*(C'\fR (or \f(CW\*(C`AnyEvent::Log::log\*(C'\fR).
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>
\& http://anyevent.schmorp.de
.Ve
