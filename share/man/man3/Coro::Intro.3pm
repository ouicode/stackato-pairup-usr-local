.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Intro 3"
.TH Intro 3 "2011-12-12" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Introduction to Coro"
.IX Header "Introduction to Coro"
This tutorial will introduce you to the main features of the Coro module
family.
.PP
It first introduces some basic concepts, and later gives a short overview
of the module family.
.SH "What is Coro?"
.IX Header "What is Coro?"
Coro started as a simple module that implemented a specific form of
first class continuations called Coroutines. These basically allow you
to capture the current point execution and jump to another point, while
allowing you to return at any time, as kind of non-local jump, not unlike
C's \f(CW\*(C`setjmp\*(C'\fR/\f(CW\*(C`longjmp\*(C'\fR. This is nowadays known as a Coro::State.
.PP
One natural application for these is to include a scheduler, resulting in
cooperative threads, which is the main use case for Coro today. Still,
much of the documentation and custom refers to these threads as
\&\*(L"coroutines\*(R" or often just \*(L"coros\*(R".
.PP
A thread is very much like a stripped-down perl interpreter, or a
process: Unlike a full interpreter process, a thread doesn't have its own
variable or code namespaces \- everything is shared. That means that when
one thread modifies a variable (or any value, e.g. through a reference),
then other threads immediately see this change when they look at the same
variable or location.
.PP
Cooperative means that these threads must cooperate with each other, when
it comes to \s-1CPU\s0 usage \- only one thread ever has the \s-1CPU\s0, and if another
thread wants the \s-1CPU\s0, the running thread has to give it up. The latter
is either explicitly, by calling a function to do so, or implicity, when
waiting on a resource (such as a Semaphore, or the completion of some I/O
request). This threading model is popular in scripting languages (such as
python or ruby), and this implementation is typically far more efficient
than threads implemented in other languages.
.PP
Perl itself uses rather confusing terminilogy \- what perl calls a \*(L"thread\*(R"
(or \*(L"ithread\*(R") is actually called a \*(L"process\*(R" everywhere else: The
so-called \*(L"perl threads\*(R" are actually artifacts of the unix process
emulation code used on Windows, which is consequently why they are
actually processes and not threads. The biggest difference is that neither
variables (nor code) are shared between processes or ithreads.
.SH "Cooperative Threads"
.IX Header "Cooperative Threads"
Cooperative threads is what the Coro module gives you. Obviously, you have
to \f(CW\*(C`use\*(C'\fR it first:
.PP
.Vb 1
\&   use Coro;
.Ve
.PP
To create a thread, you can use the \f(CW\*(C`async\*(C'\fR function that automatically
gets exported from that module:
.PP
.Vb 3
\&   async {
\&      print "hello\en";
\&   };
.Ve
.PP
Async expects a code block as first argument (in indirect object
notation). You can actually pass it extra arguments, and these will end up
in \f(CW@_\fR when executing the codeblock, but since it is a closure, you can
also just refer to any lexical variables that are currently visible.
.PP
The above lines create a thread, but if you save them in a file and
execute it as a perl program, you will not get any output.
.PP
The reasons is that, although you created a thread, and the thread is
ready to execute (because \f(CW\*(C`async\*(C'\fR puts it into the so-called \fIready
queue\fR), it never gets any \s-1CPU\s0 time to actually execute, as the main
program \- which also is a thread almost like any other \- never gives up
the \s-1CPU\s0 but instead exits the whole program, by running off the end of
the file. Since Coro threads are cooperative, the main thread has to
cooperate, and give up the \s-1CPU\s0.
.PP
To explicitly give up the \s-1CPU\s0, use the \f(CW\*(C`cede\*(C'\fR function (which is often
called \f(CW\*(C`yield\*(C'\fR in other thread implementations):
.PP
.Vb 1
\&   use Coro;
\&
\&   async {
\&      print "hello\en";
\&   };
\&
\&   cede;
.Ve
.PP
Running the above prints \f(CW\*(C`hello\*(C'\fR and exits.
.PP
Now, this is not very interesting, so let's try a slightly more
interesting program:
.PP
.Vb 1
\&   use Coro;
\&
\&   async {
\&      print "async 1\en";
\&      cede;
\&      print "async 2\en";
\&   };
\&
\&   print "main 1\en";
\&   cede;
\&   print "main 2\en";
\&   cede;
.Ve
.PP
Running this program prints:
.PP
.Vb 4
\&   main 1
\&   async 1
\&   main 2
\&   async 2
.Ve
.PP
This nicely illustrates the non-local jump ability: the main program
prints the first line, and then yields the \s-1CPU\s0 to whatever other
threads there are. And there is one other, which runs and prints
\&\*(L"async 1\*(R", and itself yields the \s-1CPU\s0. Since the only other thread
available is the main program, it continues running and so on.
.PP
Let's look at the example in more detail: \f(CW\*(C`async\*(C'\fR first creates a new
thread. All new threads start in a suspended state. To make them run,
they need to be put into the ready queue, which is the second thing that
\&\f(CW\*(C`async\*(C'\fR does. Each time a thread gives up the \s-1CPU\s0, Coro runs a so-called
\&\fIscheduler\fR. The scheduler selects the next thread from the ready queue,
removes it from the queue, and runs it.
.PP
\&\f(CW\*(C`cede\*(C'\fR also does two things: first it puts the running thread into the
ready queue, and then it jumps into the scheduler. This has the effect of
giving up the \s-1CPU\s0, but also ensures that, eventually, the thread gets run
again.
.PP
In fact, \f(CW\*(C`cede\*(C'\fR could be implemented like this:
.PP
.Vb 4
\&   sub my_cede {
\&      $Coro::current\->ready;
\&      schedule;
\&   }
.Ve
.PP
This works because \f(CW$Coro::current\fR always contains the currently
running thread, and the scheduler itself can be called directly via
\&\f(CW\*(C`Coro::schedule\*(C'\fR.
.PP
What is the effect of just calling \f(CW\*(C`schedule\*(C'\fR without putting the current
thread into the ready queue first? Simple: the scheduler selects the
next ready thread and runs it. And the current thread, as it hasn't been
put into the ready queue, will go to sleep until something wakes it
up. If. Ever.
.PP
The following example remembers the current thread in a variable,
creates a thread and then puts the main program to sleep.
.PP
The newly created thread uses rand to wake up the main thread by
calling its \f(CW\*(C`ready\*(C'\fR method \- or not.
.PP
.Vb 1
\&   use Coro;
\&
\&   my $wakeme = $Coro::current;
\&
\&   async {
\&      $wakeme\->ready if 0.5 > rand;
\&   };
\&
\&   schedule;
.Ve
.PP
Now, when you run it, one of two things happen: Either the \f(CW\*(C`async\*(C'\fR thread
wakes up the main thread again, in which case the program silently exits,
or it doesn't, in which case you get something like this:
.PP
.Vb 6
\&   FATAL: deadlock detected.
\&         PID SC  RSS USES Description              Where
\&    31976480 \-C  19k    0 [main::]                 [program:9]
\&    32223768 UC  12k    1                          [Coro.pm:691]
\&    32225088 \-\- 2068    1 [coro manager]           [Coro.pm:691]
\&    32225184 N\-  216    0 [unblock_sub scheduler]  \-
.Ve
.PP
Why is that? Well, when the \f(CW\*(C`async\*(C'\fR thread runs into the end of its
block, it will be terminated (via a call to \f(CW\*(C`Coro::terminate\*(C'\fR) and the
scheduler is called again. Since the \f(CW\*(C`async\*(C'\fR thread hasn't woken up the
main thread, and there aren't any other threads, there is nothing to wake
up, and the program cannot continue. Since there \fIare\fR threads that
\&\fIcould\fR be running (main) but none are \fIready\fR to do so, Coro signals a
\&\fIdeadlock\fR \- no progress is possible. Usually you also get a listing of
all threads, which might help you track down the problem.
.PP
However, there is an important case where progress \fIis\fR, in fact,
possible, despite no threads being ready \- namely in an event-based
program. In such a program, some threads could wait for \fIexternal\fR
events, such as a timeout, or some data to arrive on a socket.
.PP
Since a deadlock in such a case would not be very useful, there is a
module named Coro::AnyEvent that integrates threads into an event
loop. It configures Coro in a way that, instead of \f(CW\*(C`die\*(C'\fRing with an error
message, it instead runs the event loop in the hope of receiving an event
that will wake up some thread.
.SS "Semaphores and other locks"
.IX Subsection "Semaphores and other locks"
Using only \f(CW\*(C`ready\*(C'\fR, \f(CW\*(C`cede\*(C'\fR and \f(CW\*(C`schedule\*(C'\fR to synchronise threads is
difficult, especially if many threads are ready at the same time. Coro
supports a number of primitives to help synchronising threads in easier
ways. The first such primitives is Coro::Semaphore, which implements
counting semaphores (binary semaphores are available as Coro::Signal,
and there are Coro::SemaphoreSet and Coro::RWLock primitives as
well).
.PP
Counting semaphores, in a sense, store a count of resources. You can
remove/allocate/reserve a resource by calling the \f(CW\*(C`\->down\*(C'\fR method,
which decrements the counter, and you can add or free a resource by
calling the \f(CW\*(C`\->up\*(C'\fR method, which increments the counter. If the
counter is \f(CW0\fR, then \f(CW\*(C`\->down\*(C'\fR cannot decrement the semaphore \- it is
locked \- and the thread will wait until a count becomes available again.
.PP
Here is an example:
.PP
.Vb 1
\&   use Coro;
\&
\&   my $sem = new Coro::Semaphore 0; # a locked semaphore
\&
\&   async {
\&      print "unlocking semaphore\en";
\&      $sem\->up;
\&   };
\&
\&   print "trying to lock semaphore\en";
\&   $sem\->down;
\&   print "we got it!\en";
.Ve
.PP
This program creates a \fIlocked\fR semaphore (a semaphore with count \f(CW0\fR)
and tries to lock it (by trying to decrement it's counter in the \f(CW\*(C`down\*(C'\fR
method). Since the semaphore count is already exhausted, this will block
the main thread until the semaphore becomes available.
.PP
This yields the \s-1CPU\s0 to the only other read thread in the process,t he
one created with \f(CW\*(C`async\*(C'\fR, which unlocks the semaphore (and instantly
terminates itself by returning).
.PP
Since the semaphore is now available, the main program locks it and
continues: \*(L"we got it!\*(R".
.PP
Counting semaphores are most often used to lock resources, or to exclude
other threads from accessing or using a resource. For example, consider
a very costly function (that temporarily allocates a lot of ram, for
example). You wouldn't want to have many threads calling this function at
the same time, so you use a semaphore:
.PP
.Vb 1
\&   my $lock = new Coro::Semaphore; # unlocked initially \- default is 1
\&
\&   sub costly_function {
\&      $lock\->down; # acquire semaphore
\&
\&      # do costly operation that blocks
\&
\&      $lock\->up; # unlock it
\&   }
.Ve
.PP
No matter how many threads call \f(CW\*(C`costly_function\*(C'\fR, only one will run
the body of it, all others will wait in the \f(CW\*(C`down\*(C'\fR call. If you want to
limit the number of concurrent executions to five, you could create the
semaphore with an initial count of \f(CW5\fR.
.PP
Why does the comment mention an \*(L"operation the blocks\*(R"? Again, that's
because coro's threads are cooperative: unless \f(CW\*(C`costly_function\*(C'\fR
willingly gives up the \s-1CPU\s0, other threads of control will simply not
run. This makes locking superfluous in cases where the function itself
never gives up the \s-1CPU\s0, but when dealing with the outside world, this is
rare.
.PP
Now consider what happens when the code \f(CW\*(C`die\*(C'\fRs after executing \f(CW\*(C`down\*(C'\fR,
but before \f(CW\*(C`up\*(C'\fR. This will leave the semaphore in a locked state, which
often isn't what you want \- imagine the caller expecting a failure and
wrapping the call into an \f(CW\*(C`eval {}\*(C'\fR.
.PP
So normally you would want to free the lock again if execution somehow
leaves the function, whether \*(L"normally\*(R" or via an exception. Here the
\&\f(CW\*(C`guard\*(C'\fR method proves useful:
.PP
.Vb 1
\&   my $lock = new Coro::Semaphore; # unlocked initially
\&
\&   sub costly_function {
\&      my $guard = $lock\->guard; # acquire guard
\&
\&      # do costly operation that blocks
\&   }
.Ve
.PP
The \f(CW\*(C`guard\*(C'\fR method \f(CW\*(C`down\*(C'\fRs the semaphore and returns a so-called guard
object. Nothing happens as long as there are references to it (i.e. it is
in scope somehow), but when all references are gone, for example, when
\&\f(CW\*(C`costly_function\*(C'\fR returns or throws an exception, it will automatically
call \f(CW\*(C`up\*(C'\fR on the semaphore, no way to forget it. Even when the thread
gets \f(CW\*(C`cancel\*(C'\fRed by another thread will the guard object ensure that the
lock is freed.
.PP
This concludes this introduction to semaphores and locks. Apart from
Coro::Semaphore and Coro::Signal, there is also a reader-writer lock
(Coro::RWLock) and a semaphore set (Coro::SemaphoreSet). All of
these come with their own manpage.
.SS "Channels"
.IX Subsection "Channels"
Semaphores are fine, but usually you want to communicate by exchanging
data as well. Of course, you can just use some locks, and array of sorts
and use that to communicate, but there is a useful abstraction for
communicaiton between threads: Coro::Channel. Channels are the Coro
equivalent of a unix pipe (and very similar to AmigaOS message ports :) \-
you can put stuff into it on one side, and read data from it on the other.
.PP
Here is a simple example that creates a thread and sends numbers to
it. The thread calculates the square of each number and puts that into
another channel, which the main thread reads the result from:
.PP
.Vb 1
\&   use Coro;
\&
\&   my $calculate = new Coro::Channel;
\&   my $result    = new Coro::Channel;
\&
\&   async {
\&      # endless loop
\&      while () {
\&         my $num = $calculate\->get; # read a number
\&         $num **= 2; # square it
\&         $result\->put ($num); # put the result into the result queue
\&      }
\&   };
\&
\&   for (1, 2, 5, 10, 77) {
\&      $calculate\->put ($_);
\&      print "$_ ** 2 = ", $result\->get, "\en";
\&   }
.Ve
.PP
Gives:
.PP
.Vb 5
\&   1 ** 2 = 1
\&   2 ** 2 = 4
\&   5 ** 2 = 25
\&   10 ** 2 = 100
\&   77 ** 2 = 5929
.Ve
.PP
Both \f(CW\*(C`get\*(C'\fR and \f(CW\*(C`put\*(C'\fR methods can block the current thread: \f(CW\*(C`get\*(C'\fR first
checks whether there \fIis\fR some data available, and if not, it block the
current thread until some data arrives. \f(CW\*(C`put\*(C'\fR can also block, as each
Channel has a \*(L"maximum item capacity\*(R", i.e. you cannot store more than a
specific number of items, which can be configured when the Channel gets
created.
.PP
In the above example, \f(CW\*(C`put\*(C'\fR never blocks, as the default capacity
of a Channel is very high. So the for loop first puts data into the
channel, then tries to \f(CW\*(C`get\*(C'\fR the result. Since the async thread hasn't
put anything in there yet (on the first iteration it hasn't even run
yet), the result Channel is still empty, so the main thread blocks.
.PP
Since the only other runnable/ready thread at this point is the squaring
thread, it will be woken up, will \f(CW\*(C`get\*(C'\fR the number, square it and put it
into the result channel, waking up the main thread again. It will still
continue to run, as waking up other threads just puts them into the ready
queue, nothing less, nothing more.
.PP
Only when the async thread tries to \f(CW\*(C`get\*(C'\fR the next number from the
calculate channel will it block (because nothing is there yet) and the
main thread will continue running. And so on.
.PP
This illustrates a general principle used by Coro: a thread will \fIonly
ever block\fR when it has to. Neither the Coro module itself nor any of its
submodules will ever give up the \s-1CPU\s0 unless they have to, because they
wait for some event to happen.
.PP
Be careful, however: when multiple threads put numbers into \f(CW$calculate\fR
and read from \f(CW$result\fR, they won't know which result is theirs. The
solution for this is to either use a semaphore, or send not just the
number, but also your own private result channel.
.SS "What is mine, what is ours?"
.IX Subsection "What is mine, what is ours?"
What, exactly, constitutes a thread? Obviously it contains the current
point of execution. Not so obviously, it also has to include all
lexical variables, that means, every thread has its own set of lexical
variables.
.PP
To see why this is necessary, consider this program:
.PP
.Vb 1
\&   use Coro;
\&
\&   sub printit {
\&      my ($string) = @_;
\&
\&      cede;
\&
\&      print $string;
\&   }
\&
\&   async { printit "Hello, " };
\&   async { printit "World!\en" };
\&
\&   cede; cede; # do it
.Ve
.PP
The above prints \f(CW\*(C`Hello, World!\en\*(C'\fR. If \f(CW\*(C`printit\*(C'\fR wouldn't have
its own per-thread \f(CW$string\fR variable, it would probably print
\&\f(CW\*(C`World!\enWorld\en\*(C'\fR, which is rather unexpected, and would make it very
difficult to make good use of threads.
.PP
To make things run smoothly, there are quite a number of other things that
are per-thread:
.ie n .IP "$_, @_, $@ and the regex result vars, $&, %+, $1, $2, ..." 4
.el .IP "\f(CW$_\fR, \f(CW@_\fR, $@ and the regex result vars, $&, %+, \f(CW$1\fR, \f(CW$2\fR, ..." 4
.IX Item "$_, @_, $@ and the regex result vars, $&, %+, $1, $2, ..."
\&\f(CW$_\fR is used much like a local variable, so it gets localised
per-thread. The same is true for regex results (\f(CW$1\fR, \f(CW$2\fR and so on).
.Sp
\&\f(CW@_\fR contains the arguments, so like lexicals, it also must be
per-thread.
.Sp
\&\f(CW$@\fR is not obviously required to be per-thread, but it is quite useful.
.IP "$/ and the default output file handle" 4
.IX Item "$/ and the default output file handle"
Threads most often block when doing I/O. Since \f(CW$/\fR is used when reading
lines, it would be very inconvenient if it were a shared variable, so it
is per-thread.
.Sp
The default output handle (see \f(CW\*(C`select\*(C'\fR) is a difficult case: sometimes
being global is preferable, sometimes per-thread is preferable. Since
per-thread seems to be more common, it is per-thread.
.ie n .IP "$SIG{_\|_DIE_\|_} and $SIG{_\|_WARN_\|_}" 4
.el .IP "\f(CW$SIG\fR{_\|_DIE_\|_} and \f(CW$SIG\fR{_\|_WARN_\|_}" 4
.IX Item "$SIG{__DIE__} and $SIG{__WARN__}"
If these weren't per-thread, then common constructs such as:
.Sp
.Vb 4
\&   eval {
\&      local $SIG{_\|_DIE_\|_} = sub { ... };
\&      ...
\&   };
.Ve
.Sp
Would not allow coroutine switching. Since exception-handling is
per-thread, those variables should be per-thread as well.
.IP "Lots of other esoteric stuff" 4
.IX Item "Lots of other esoteric stuff"
For example, \f(CW$^H\fR is per-thread. Most of the additional per-thread state
is not directly visible to Perl, but required to make the interpreter
work. You won't normally notice these.
.PP
Everything else is shared between all threads. For example, the globals
\&\f(CW$a\fR and \f(CW$b\fR are shared. When does that matter? When using \f(CW\*(C`sort\*(C'\fR,
these variables become special, and therefore, switching threads when
sorting might have surprising results.
.PP
Other examples are the \f(CW$!\fR, errno, \f(CW$.\fR, the current input line number,
\&\f(CW$,\fR, \f(CW\*(C`$\e\*(C'\fR, \f(CW$"\fR and many other special variables.
.PP
While in some cases a good argument could be made for localising them to
the thread, they are rarely used, and sometimes hard to localise.
.PP
Future versions of Coro might include more per-thread state when it
becomes a problem.
.SS "Debugging"
.IX Subsection "Debugging"
Sometimes it can be useful to find out what each thread is doing (or which
threads exist in the first place). The Coro::Debug module has (among
other goodies), a function that allows you to print a \*(L"ps\*(R"\-like listing \-
you have seen it in action earlier when Coro detected a deadlock.
.PP
You use it like this:
.PP
.Vb 1
\&   use Coro::Debug;
\&
\&   Coro::Debug::command "ps";
.Ve
.PP
Remember the example with the two channels and a worker thread that
squared numbers? Running \*(L"ps\*(R" just after \f(CW\*(C`$calculate\->get\*(C'\fR outputs
something similar to this:
.PP
.Vb 6
\&        PID SC  RSS USES Description              Where
\&    8917312 \-C  22k    0 [main::]                 [introscript:20]
\&    8964448 N\-  152    0 [coro manager]           \-
\&    8964520 N\-  152    0 [unblock_sub scheduler]  \-
\&    8591752 UC  152    1                          [introscript:12]
\&   11546944 N\-  152    0 [EV idle process]        \-
.Ve
.PP
Interesting \- there is more going on in the background than one would
expect. Ignoring the extra threads, the main thread has pid
\&\f(CW8917312\fR, and the one started by \f(CW\*(C`async\*(C'\fR has pid \f(CW8591752\fR.
.PP
The latter is also the only thread that doesn't have a description,
simply because we haven't set one. Setting one is easy, just put it into
\&\f(CW\*(C`$Coro::current\->{desc}\*(C'\fR:
.PP
.Vb 4
\&   async {
\&      $Coro::current\->{desc} = "cruncher";
\&      ...
\&   };
.Ve
.PP
This can be rather useful when debugging a program, or when using the
interactive debug shell of Coro::Debug.
.SH "The Real World \- Event Loops"
.IX Header "The Real World - Event Loops"
Coro really wants to run in a program using some event loop. In fact, most
real-world programs using Coro threads are written with a combination of
event-based and thread-based techniques, as it is easy to get the best of
both worlds with Coro.
.PP
Coro integrates automatically into any event loop supported by AnyEvent
(see Coro::AnyEvent for details), but can take special advantage of the
\&\s-1EV\s0 and Event modules.
.PP
Here is a simple finger client, using whatever event loop AnyEvent
comes up with:
.PP
.Vb 2
\&   use Coro;
\&   use Coro::Socket;
\&
\&   sub finger {
\&      my ($user, $host) = @_;
\&
\&      my $fh = new Coro::Socket PeerHost => $host, PeerPort => "finger"
\&         or die "$user\e@$host: $!";
\&
\&      print $fh "$user\en";
\&
\&      print "$user\e@$host: $_" while <$fh>;
\&      print "$user\e@$host: done\en";
\&   }
\&
\&   # now finger a few accounts
\&   for (
\&      (async { finger "abc", "cornell.edu" }),
\&      (async { finger "sebbo", "world.std.com" }),
\&      (async { finger "trouble", "noc.dfn.de" }),
\&   ) {
\&      $_\->join; # wait for the result
\&   }
.Ve
.PP
There are a few new things here. First of all, there is
Coro::Socket. This module works much the same way as
IO::Socket::INET, except that it is coroutine-aware. This means that
IO::Socket::INET, when waiting for the network, will block the whole
process \- that means all threads, which is clearly undesirable.
.PP
On the other hand, Coro::Socket knows how to give up the \s-1CPU\s0 to other
threads when it waits for the network, which makes parallel execution
possible.
.PP
The other new thing is the \f(CW\*(C`join\*(C'\fR method: All we want to do in this
example is start three \f(CW\*(C`async\*(C'\fR threads and only exit when they have
done their job. This could be done using a counting semaphore, but it is
much simpler to synchronously wait for them to \f(CW\*(C`terminate\*(C'\fR, which is
exactly what the \f(CW\*(C`join\*(C'\fR method does.
.PP
It doesn't matter that the three \f(CW\*(C`async\*(C'\fRs will probably finish in a
different order then the for loop \f(CW\*(C`join\*(C'\fRs them \- when the thread is still
running, \f(CW\*(C`join\*(C'\fR simply waits. If the thread has already terminated, it
will simply fetch its return status.
.PP
If you are experienced in event-based programming, you will see that the
above program doesn't quite follow the normal pattern, where you start
some work, and then run the event loop (e.v. \f(CW\*(C`EV::loop\*(C'\fR).
.PP
In fact, nontrivial programs follow this pattern even with Coro, so a Coro
program that uses \s-1EV\s0 usually looks like this:
.PP
.Vb 2
\&   use EV;
\&   use Coro;
\&
\&   # start coroutines or event watchers
\&
\&   EV::loop; # and loop
.Ve
.PP
And in fact, for debugging, you often do something like this:
.PP
.Vb 2
\&   use EV;
\&   use Coro::Debug;
\&
\&   my $shell = new_unix_server Coro::Debug "/tmp/myshell";
\&
\&   EV::loop; # and loop
.Ve
.PP
This runs your program, but also an interactive shell on the unix domain
socket in \fI/tmp/myshell\fR. You can use the \fIsocat\fR program to access it:
.PP
.Vb 2
\&   # socat readline /tmp/myshell
\&   coro debug session. use help for more info
\&
\&   > ps
\&           PID SC  RSS USES Description              Where
\&     136672312 RC  19k 177k [main::]                 [myprog:28]
\&     136710424 \-\- 1268   48 [coro manager]           [Coro.pm:349]
\&   > help
\&   ps [w|v]                show the list of all coroutines (wide, verbose)
\&   bt <pid>                show a full backtrace of coroutine <pid>
\&   eval <pid> <perl>       evaluate <perl> expression in context of <pid>
\&   trace <pid>             enable tracing for this coroutine
\&   untrace <pid>           disable tracing for this coroutine
\&   kill <pid> <reason>     throws the given <reason> string in <pid>
\&   cancel <pid>            cancels this coroutine
\&   ready <pid>             force <pid> into the ready queue
\&   <anything else>         evaluate as perl and print results
\&   <anything else> &       same as above, but evaluate asynchronously
\&                           you can use (find_coro <pid>) in perl expressions
\&                           to find the coro with the given pid, e.g.
\&                           (find_coro 9768720)\->ready
\&   loglevel <int>          enable logging for messages of level <int> and lower
\&   exit                    end this session
.Ve
.PP
Microsft victims can of course use the even less secure \f(CW\*(C`new_tcp_server\*(C'\fR
constructor.
.SS "The Real World \- File I/O"
.IX Subsection "The Real World - File I/O"
Disk I/O, while often much faster than the network, nevertheless can take
quite a long time in which the \s-1CPU\s0 could do other things, if one would
only be able to do something.
.PP
Fortunately, the \s-1IO::AIO\s0 module on \s-1CPAN\s0 allows you to move these
I/O calls into the background, letting you do useful work in the
foreground. It is event\-/callback\-based, but Coro has a nice wrapper
around it, called Coro::AIO, which lets you use its functions
naturally from within threads:
.PP
.Vb 2
\&   use Fcntl;
\&   use Coro::AIO;
\&
\&   my $fh = aio_open "$filename~", O_WRONLY | O_CREAT, 0600
\&      or die "$filename~: $!";
\&
\&   aio_write $fh, 0, (length $data), $data, 0;
\&   aio_fsync $fh;
\&   aio_close $fh;
\&   aio_rename "$filename~", "$filename";
.Ve
.PP
The above creates a new file, writes data into it, syncs the data to disk
and atomically replaces a base file with a new copy.
.SS "Inversion of control \- rouse functions"
.IX Subsection "Inversion of control - rouse functions"
Last not least, me talk about inversion of control. The \*(L"control\*(R" refers
to \*(L"who calls whom\*(R", who is in control of the program. In this program,
the main program is in control and passes this to all functions it calls:
.PP
.Vb 1
\&   use LWP;
\&
\&   # pass control to get
\&   my $res = get "http://example.org/";
\&   # control returned to us
\&
\&   print $res;
.Ve
.PP
When switching to event-based programs, instead of \*(L"us calling them\*(R",
\&\*(L"they call us\*(R" \- this is the inversion of control form the title:
.PP
.Vb 1
\&   use AnyEvent::HTTP;
\&
\&   # do not pass control for long \- http_get immediately returns
\&   http_get "http://example.org/", sub {
\&      print $_[0];
\&   };
\&
\&   # we stay in control and can do other things
.Ve
.PP
Event based programming can be nice, but sometimes it's just easier to
write down some processing in \*(L"linear\*(R" fashion, without callbacks. Coro
provides some special functions to reduce typing:
.PP
.Vb 1
\&   use AnyEvent::HTTP;
\&
\&   # do not pass control for long \- http_get immediately returns
\&   http_get "http://example.org/", Coro::rouse_cb;
\&
\&   # we stay in control and can do other things...
\&   # ...such as wait for the result
\&   my ($res) = Coro::rouse_wait;
.Ve
.PP
\&\f(CW\*(C`Coro::rouse_cb\*(C'\fR creates and returns a special callback. You can pass
this callback to any function that would expect a callback.
.PP
\&\f(CW\*(C`Coro::rouse_wait\*(C'\fR waits (block the current thread) until the most
recently created callback has been called, and returns whatever was passed
to it.
.PP
These two functions allow you to \fImechanically\fR invert the control from
\&\*(L"callback based style\*(R" used by most event-based libraries to \*(L"blocking
style\*(R", whenever you wish to.
.PP
The pattern is simple: instead of...
.PP
.Vb 4
\&   some_func ..., sub {
\&      my @res = @_;
\&      ...
\&   };
.Ve
.PP
\&... you write:
.PP
.Vb 3
\&   some_func ..., Coro::rouse_cb;
\&   my @res = Coro::rouse_wait;
\&   ...
.Ve
.PP
Callback-based interfaces are plenty, and the rouse functions allow you to
use them in an often more convenient way.
.SH "Other Modules"
.IX Header "Other Modules"
This introduction only mentions a few methods and modules, Coro has many
other functions (see the Coro manpage) and modules (documented in the
\&\f(CW\*(C`SEE ALSO\*(C'\fR section of the Coro manpage).
.PP
Noteworthy modules are Coro::LWP (for parallel \s-1LWP\s0 requests, but see
AnyEvent::HTTP for a better HTTP-only alternative), Coro::BDB, for
when you need an asynchronous database, Coro::Handle, when you need
to use any file handle in a coroutine (popular to access \f(CW\*(C`STDIN\*(C'\fR and
\&\f(CW\*(C`STDOUT\*(C'\fR) and Coro::EV, the optimised interface to \s-1EV\s0 (which gets
used automatically by Coro::AnyEvent).
.PP
There are a number of Coro-related moduels that might be useful for your problem
(see <http://search.cpan.org/search?query=Coro&mode=module>). And since Coro
integrates so well into AnyEvent, it's often easy to adapt existing AnyEvent modules
(see <http://search.cpan.org/search?query=AnyEvent&mode=module>).
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\&   Marc Lehmann <schmorp@schmorp.de>
\&   http://home.schmorp.de/
.Ve
