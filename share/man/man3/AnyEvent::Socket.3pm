.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent::Socket 3"
.TH AnyEvent::Socket 3 "2012-04-22" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::Socket \- useful IPv4 and IPv6 stuff. also unix domain sockets. and stuff.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   use AnyEvent::Socket;
\&   
\&   tcp_connect "gameserver.deliantra.net", 13327, sub {
\&      my ($fh) = @_
\&         or die "gameserver.deliantra.net connect failed: $!";
\&   
\&      # enjoy your filehandle
\&   };
\&   
\&   # a simple tcp server
\&   tcp_server undef, 8888, sub {
\&      my ($fh, $host, $port) = @_;
\&   
\&      syswrite $fh, "The internet is full, $host:$port. Go away!\e015\e012";
\&   };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements various utility functions for handling internet
protocol addresses and sockets, in an as transparent and simple way as
possible.
.PP
All functions documented without \f(CW\*(C`AnyEvent::Socket::\*(C'\fR prefix are exported
by default.
.ie n .IP "$ipn = parse_ipv4 $dotted_quad" 4
.el .IP "\f(CW$ipn\fR = parse_ipv4 \f(CW$dotted_quad\fR" 4
.IX Item "$ipn = parse_ipv4 $dotted_quad"
Tries to parse the given dotted quad IPv4 address and return it in
octet form (or undef when it isn't in a parsable format). Supports all
forms specified by \s-1POSIX\s0 (e.g. \f(CW10.0.0.1\fR, \f(CW10.1\fR, \f(CW\*(C`10.0x020304\*(C'\fR,
\&\f(CW0x12345678\fR or \f(CW0377.0377.0377.0377\fR).
.ie n .IP "$ipn = parse_ipv6 $textual_ipv6_address" 4
.el .IP "\f(CW$ipn\fR = parse_ipv6 \f(CW$textual_ipv6_address\fR" 4
.IX Item "$ipn = parse_ipv6 $textual_ipv6_address"
Tries to parse the given IPv6 address and return it in
octet form (or undef when it isn't in a parsable format).
.Sp
Should support all forms specified by \s-1RFC\s0 2373 (and additionally all IPv4
forms supported by parse_ipv4). Note that scope-id's are not supported
(and will not parse).
.Sp
This function works similarly to \f(CW\*(C`inet_pton AF_INET6, ...\*(C'\fR.
.Sp
Example:
.Sp
.Vb 2
\&   print unpack "H*", parse_ipv6 "2002:5345::10.0.0.1";
\&   # => 2002534500000000000000000a000001
.Ve
.ie n .IP "$token = parse_unix $hostname" 4
.el .IP "\f(CW$token\fR = parse_unix \f(CW$hostname\fR" 4
.IX Item "$token = parse_unix $hostname"
This fucntion exists mainly for symmetry to the other \f(CW\*(C`parse_protocol\*(C'\fR
functions \- it takes a hostname and, if it is \f(CW\*(C`unix/\*(C'\fR, it returns a
special address token, otherwise \f(CW\*(C`undef\*(C'\fR.
.Sp
The only use for this function is probably to detect whether a hostname
matches whatever AnyEvent uses for unix domain sockets.
.ie n .IP "$ipn = parse_address $ip" 4
.el .IP "\f(CW$ipn\fR = parse_address \f(CW$ip\fR" 4
.IX Item "$ipn = parse_address $ip"
Combines \f(CW\*(C`parse_ipv4\*(C'\fR and \f(CW\*(C`parse_ipv6\*(C'\fR in one function. The address
here refers to the host address (not socket address) in network form
(binary).
.Sp
If the \f(CW$text\fR is \f(CW\*(C`unix/\*(C'\fR, then this function returns a special token
recognised by the other functions in this module to mean \*(L"\s-1UNIX\s0 domain
socket\*(R".
.Sp
If the \f(CW$text\fR to parse is a mapped IPv4 in IPv6 address (:ffff::<ipv4>),
then it will be treated as an IPv4 address. If you don't want that, you
have to call \f(CW\*(C`parse_ipv4\*(C'\fR and/or \f(CW\*(C`parse_ipv6\*(C'\fR manually.
.Sp
Example:
.Sp
.Vb 2
\&   print unpack "H*", parse_address "10.1.2.3";
\&   # => 0a010203
.Ve
.ie n .IP "$ipn = AnyEvent::Socket::aton $ip" 4
.el .IP "\f(CW$ipn\fR = AnyEvent::Socket::aton \f(CW$ip\fR" 4
.IX Item "$ipn = AnyEvent::Socket::aton $ip"
Same as \f(CW\*(C`parse_address\*(C'\fR, but not exported (think \f(CW\*(C`Socket::inet_aton\*(C'\fR but
\&\fIwithout\fR name resolution).
.ie n .IP "($name, $aliases, $proto) = getprotobyname $name" 4
.el .IP "($name, \f(CW$aliases\fR, \f(CW$proto\fR) = getprotobyname \f(CW$name\fR" 4
.IX Item "($name, $aliases, $proto) = getprotobyname $name"
Works like the builtin function of the same name, except it tries hard to
work even on broken platforms (well, that's windows), where getprotobyname
is traditionally very unreliable.
.Sp
Example: get the protocol number for \s-1TCP\s0 (usually 6)
.Sp
.Vb 1
\&   my $proto = getprotobyname "tcp";
.Ve
.ie n .IP "($host, $service) = parse_hostport $string[, $default_service]" 4
.el .IP "($host, \f(CW$service\fR) = parse_hostport \f(CW$string\fR[, \f(CW$default_service\fR]" 4
.IX Item "($host, $service) = parse_hostport $string[, $default_service]"
Splitting a string of the form \f(CW\*(C`hostname:port\*(C'\fR is a common
problem. Unfortunately, just splitting on the colon makes it hard to
specify IPv6 addresses and doesn't support the less common but well
standardised \f(CW\*(C`[ip literal]\*(C'\fR syntax.
.Sp
This function tries to do this job in a better way, it supports the
following formats, where \f(CW\*(C`port\*(C'\fR can be a numerical port number of a
service name, or a \f(CW\*(C`name=port\*(C'\fR string, and the \f(CW\*(C` port\*(C'\fR and \f(CW\*(C`:port\*(C'\fR
parts are optional. Also, everywhere where an \s-1IP\s0 address is supported
a hostname or unix domain socket address is also supported (see
\&\f(CW\*(C`parse_unix\*(C'\fR), and strings starting with \f(CW\*(C`/\*(C'\fR will also be interpreted as
unix domain sockets.
.Sp
.Vb 8
\&   hostname:port    e.g. "www.linux.org", "www.x.de:443", "www.x.de:https=443",
\&   ipv4:port        e.g. "198.182.196.56", "127.1:22"
\&   ipv6             e.g. "::1", "affe::1"
\&   [ipv4or6]:port   e.g. "[::1]", "[10.0.1]:80"
\&   [ipv4or6] port   e.g. "[127.0.0.1]", "[www.x.org] 17"
\&   ipv4or6 port     e.g. "::1 443", "10.0.0.1 smtp"
\&   unix/:path       e.g. "unix/:/path/to/socket"
\&   /path            e.g. "/path/to/socket"
.Ve
.Sp
It also supports defaulting the service name in a simple way by using
\&\f(CW$default_service\fR if no service was detected. If neither a service was
detected nor a default was specified, then this function returns the
empty list. The same happens when a parse error was detected, such as a
hostname with a colon in it (the function is rather conservative, though).
.Sp
Example:
.Sp
.Vb 2
\&  print join ",", parse_hostport "localhost:443";
\&  # => "localhost,443"
\&
\&  print join ",", parse_hostport "localhost", "https";
\&  # => "localhost,https"
\&
\&  print join ",", parse_hostport "[::1]";
\&  # => "," (empty list)
\&
\&  print join ",", parse_host_port "/tmp/debug.sock";
\&  # => "unix/", "/tmp/debug.sock"
.Ve
.ie n .IP "$string = format_hostport $host, $port" 4
.el .IP "\f(CW$string\fR = format_hostport \f(CW$host\fR, \f(CW$port\fR" 4
.IX Item "$string = format_hostport $host, $port"
Takes a host (in textual form) and a port and formats in unambigiously in
a way that \f(CW\*(C`parse_hostport\*(C'\fR can parse it again. \f(CW$port\fR can be \f(CW\*(C`undef\*(C'\fR.
.ie n .IP "$sa_family = address_family $ipn" 4
.el .IP "\f(CW$sa_family\fR = address_family \f(CW$ipn\fR" 4
.IX Item "$sa_family = address_family $ipn"
Returns the address family/protocol\-family (AF_xxx/PF_xxx, in one value :)
of the given host address in network format.
.ie n .IP "$text = format_ipv4 $ipn" 4
.el .IP "\f(CW$text\fR = format_ipv4 \f(CW$ipn\fR" 4
.IX Item "$text = format_ipv4 $ipn"
Expects a four octet string representing a binary IPv4 address and returns
its textual format. Rarely used, see \f(CW\*(C`format_address\*(C'\fR for a nicer
interface.
.ie n .IP "$text = format_ipv6 $ipn" 4
.el .IP "\f(CW$text\fR = format_ipv6 \f(CW$ipn\fR" 4
.IX Item "$text = format_ipv6 $ipn"
Expects a sixteen octet string representing a binary IPv6 address and
returns its textual format. Rarely used, see \f(CW\*(C`format_address\*(C'\fR for a
nicer interface.
.ie n .IP "$text = format_address $ipn" 4
.el .IP "\f(CW$text\fR = format_address \f(CW$ipn\fR" 4
.IX Item "$text = format_address $ipn"
Covnvert a host address in network format (e.g. 4 octets for IPv4 or 16
octets for IPv6) and convert it into textual form.
.Sp
Returns \f(CW\*(C`unix/\*(C'\fR for \s-1UNIX\s0 domain sockets.
.Sp
This function works similarly to \f(CW\*(C`inet_ntop AF_INET || AF_INET6, ...\*(C'\fR,
except it automatically detects the address type.
.Sp
Returns \f(CW\*(C`undef\*(C'\fR if it cannot detect the type.
.Sp
If the \f(CW$ipn\fR is a mapped IPv4 in IPv6 address (:ffff::<ipv4>), then just
the contained IPv4 address will be returned. If you do not want that, you
have to call \f(CW\*(C`format_ipv6\*(C'\fR manually.
.Sp
Example:
.Sp
.Vb 2
\&   print format_address "\ex01\ex02\ex03\ex05";
\&   => 1.2.3.5
.Ve
.ie n .IP "$text = AnyEvent::Socket::ntoa $ipn" 4
.el .IP "\f(CW$text\fR = AnyEvent::Socket::ntoa \f(CW$ipn\fR" 4
.IX Item "$text = AnyEvent::Socket::ntoa $ipn"
Same as format_address, but not exported (think \f(CW\*(C`inet_ntoa\*(C'\fR).
.ie n .IP "inet_aton $name_or_address, $cb\->(@addresses)" 4
.el .IP "inet_aton \f(CW$name_or_address\fR, \f(CW$cb\fR\->(@addresses)" 4
.IX Item "inet_aton $name_or_address, $cb->(@addresses)"
Works similarly to its Socket counterpart, except that it uses a
callback. Use the length to distinguish between ipv4 and ipv6 (4 octets
for IPv4, 16 for IPv6), or use \f(CW\*(C`format_address\*(C'\fR to convert it to a more
readable format.
.Sp
Note that \f(CW\*(C`resolve_sockaddr\*(C'\fR, while initially a more complex interface,
resolves host addresses, IDNs, service names and \s-1SRV\s0 records and gives you
an ordered list of socket addresses to try and should be preferred over
\&\f(CW\*(C`inet_aton\*(C'\fR.
.Sp
Example.
.Sp
.Vb 5
\&   inet_aton "www.google.com", my $cv = AE::cv;
\&   say unpack "H*", $_
\&      for $cv\->recv;
\&   # => d155e363
\&   # => d155e367 etc.
\&
\&   inet_aton "ipv6.google.com", my $cv = AE::cv;
\&   say unpack "H*", $_
\&      for $cv\->recv;
\&   # => 20014860a00300000000000000000068
.Ve
.ie n .IP "$sa = AnyEvent::Socket::pack_sockaddr $service, $host" 4
.el .IP "\f(CW$sa\fR = AnyEvent::Socket::pack_sockaddr \f(CW$service\fR, \f(CW$host\fR" 4
.IX Item "$sa = AnyEvent::Socket::pack_sockaddr $service, $host"
Pack the given port/host combination into a binary sockaddr
structure. Handles both IPv4 and IPv6 host addresses, as well as \s-1UNIX\s0
domain sockets (\f(CW$host\fR == \f(CW\*(C`unix/\*(C'\fR and \f(CW$service\fR == absolute
pathname).
.Sp
Example:
.Sp
.Vb 3
\&   my $bind = AnyEvent::Socket::pack_sockaddr 43, v195.234.53.120;
\&   bind $socket, $bind
\&      or die "bind: $!";
.Ve
.ie n .IP "($service, $host) = AnyEvent::Socket::unpack_sockaddr $sa" 4
.el .IP "($service, \f(CW$host\fR) = AnyEvent::Socket::unpack_sockaddr \f(CW$sa\fR" 4
.IX Item "($service, $host) = AnyEvent::Socket::unpack_sockaddr $sa"
Unpack the given binary sockaddr structure (as used by bind, getpeername
etc.) into a \f(CW\*(C`$service, $host\*(C'\fR combination.
.Sp
For IPv4 and IPv6, \f(CW$service\fR is the port number and \f(CW$host\fR the host
address in network format (binary).
.Sp
For \s-1UNIX\s0 domain sockets, \f(CW$service\fR is the absolute pathname and \f(CW$host\fR
is a special token that is understood by the other functions in this
module (\f(CW\*(C`format_address\*(C'\fR converts it to \f(CW\*(C`unix/\*(C'\fR).
.ie n .IP "resolve_sockaddr $node, $service, $proto, $family, $type, $cb\->([$family, $type, $proto, $sockaddr], ...)" 4
.el .IP "resolve_sockaddr \f(CW$node\fR, \f(CW$service\fR, \f(CW$proto\fR, \f(CW$family\fR, \f(CW$type\fR, \f(CW$cb\fR\->([$family, \f(CW$type\fR, \f(CW$proto\fR, \f(CW$sockaddr\fR], ...)" 4
.IX Item "resolve_sockaddr $node, $service, $proto, $family, $type, $cb->([$family, $type, $proto, $sockaddr], ...)"
Tries to resolve the given nodename and service name into protocol families
and sockaddr structures usable to connect to this node and service in a
protocol-independent way. It works remotely similar to the getaddrinfo
posix function.
.Sp
For internet addresses, \f(CW$node\fR is either an IPv4 or IPv6 address, an
internet hostname (\s-1DNS\s0 domain name or \s-1IDN\s0), and \f(CW$service\fR is either
a service name (port name from \fI/etc/services\fR) or a numerical port
number. If both \f(CW$node\fR and \f(CW$service\fR are names, then \s-1SRV\s0 records
will be consulted to find the real service, otherwise they will be
used as-is. If you know that the service name is not in your services
database, then you can specify the service in the format \f(CW\*(C`name=port\*(C'\fR
(e.g. \f(CW\*(C`http=80\*(C'\fR).
.Sp
If a host cannot be found via \s-1DNS\s0, then it will be looked up in
\&\fI/etc/hosts\fR (or the file specified via \f(CW$ENV{PERL_ANYEVENT_HOSTS}\fR). If they are found, the addresses there will be used. The effect is as
if entries from \fI/etc/hosts\fR would yield \f(CW\*(C`A\*(C'\fR and \f(CW\*(C`AAAA\*(C'\fR records for the
host name unless \s-1DNS\s0 already had records for them.
.Sp
For \s-1UNIX\s0 domain sockets, \f(CW$node\fR must be the string \f(CW\*(C`unix/\*(C'\fR and
\&\f(CW$service\fR must be the absolute pathname of the socket. In this case,
\&\f(CW$proto\fR will be ignored.
.Sp
\&\f(CW$proto\fR must be a protocol name, currently \f(CW\*(C`tcp\*(C'\fR, \f(CW\*(C`udp\*(C'\fR or
\&\f(CW\*(C`sctp\*(C'\fR. The default is currently \f(CW\*(C`tcp\*(C'\fR, but in the future, this function
might try to use other protocols such as \f(CW\*(C`sctp\*(C'\fR, depending on the socket
type and any \s-1SRV\s0 records it might find.
.Sp
\&\f(CW$family\fR must be either \f(CW0\fR (meaning any protocol is \s-1OK\s0), \f(CW4\fR (use
only IPv4) or \f(CW6\fR (use only IPv6). The default is influenced by
\&\f(CW$ENV{PERL_ANYEVENT_PROTOCOLS}\fR.
.Sp
\&\f(CW$type\fR must be \f(CW\*(C`SOCK_STREAM\*(C'\fR, \f(CW\*(C`SOCK_DGRAM\*(C'\fR or \f(CW\*(C`SOCK_SEQPACKET\*(C'\fR (or
\&\f(CW\*(C`undef\*(C'\fR in which case it gets automatically chosen to be \f(CW\*(C`SOCK_STREAM\*(C'\fR
unless \f(CW$proto\fR is \f(CW\*(C`udp\*(C'\fR).
.Sp
The callback will receive zero or more array references that contain
\&\f(CW\*(C`$family, $type, $proto\*(C'\fR for use in \f(CW\*(C`socket\*(C'\fR and a binary
\&\f(CW$sockaddr\fR for use in \f(CW\*(C`connect\*(C'\fR (or \f(CW\*(C`bind\*(C'\fR).
.Sp
The application should try these in the order given.
.Sp
Example:
.Sp
.Vb 1
\&   resolve_sockaddr "google.com", "http", 0, undef, undef, sub { ... };
.Ve
.ie n .IP "$guard = tcp_connect $host, $service, $connect_cb[, $prepare_cb]" 4
.el .IP "\f(CW$guard\fR = tcp_connect \f(CW$host\fR, \f(CW$service\fR, \f(CW$connect_cb\fR[, \f(CW$prepare_cb\fR]" 4
.IX Item "$guard = tcp_connect $host, $service, $connect_cb[, $prepare_cb]"
This is a convenience function that creates a \s-1TCP\s0 socket and makes a
100% non-blocking connect to the given \f(CW$host\fR (which can be a \s-1DNS/IDN\s0
hostname or a textual \s-1IP\s0 address, or the string \f(CW\*(C`unix/\*(C'\fR for \s-1UNIX\s0 domain
sockets) and \f(CW$service\fR (which can be a numeric port number or a service
name, or a \f(CW\*(C`servicename=portnumber\*(C'\fR string, or the pathname to a \s-1UNIX\s0
domain socket).
.Sp
If both \f(CW$host\fR and \f(CW$port\fR are names, then this function will use \s-1SRV\s0
records to locate the real target(s).
.Sp
In either case, it will create a list of target hosts (e.g. for multihomed
hosts or hosts with both IPv4 and IPv6 addresses) and try to connect to
each in turn.
.Sp
After the connection is established, then the \f(CW$connect_cb\fR will be
invoked with the socket file handle (in non-blocking mode) as first, and
the peer host (as a textual \s-1IP\s0 address) and peer port as second and third
arguments, respectively. The fourth argument is a code reference that you
can call if, for some reason, you don't like this connection, which will
cause \f(CW\*(C`tcp_connect\*(C'\fR to try the next one (or call your callback without
any arguments if there are no more connections). In most cases, you can
simply ignore this argument.
.Sp
.Vb 1
\&   $cb\->($filehandle, $host, $port, $retry)
.Ve
.Sp
If the connect is unsuccessful, then the \f(CW$connect_cb\fR will be invoked
without any arguments and \f(CW$!\fR will be set appropriately (with \f(CW\*(C`ENXIO\*(C'\fR
indicating a \s-1DNS\s0 resolution failure).
.Sp
The callback will \fInever\fR be invoked before \f(CW\*(C`tcp_connect\*(C'\fR returns, even
if \f(CW\*(C`tcp_connect\*(C'\fR was able to connect immediately (e.g. on unix domain
sockets).
.Sp
The file handle is perfect for being plugged into AnyEvent::Handle, but
can be used as a normal perl file handle as well.
.Sp
Unless called in void context, \f(CW\*(C`tcp_connect\*(C'\fR returns a guard object that
will automatically cancel the connection attempt when it gets destroyed
\&\- in which case the callback will not be invoked. Destroying it does not
do anything to the socket after the connect was successful \- you cannot
\&\*(L"uncall\*(R" a callback that has been invoked already.
.Sp
Sometimes you need to \*(L"prepare\*(R" the socket before connecting, for example,
to \f(CW\*(C`bind\*(C'\fR it to some port, or you want a specific connect timeout that
is lower than your kernel's default timeout. In this case you can specify
a second callback, \f(CW$prepare_cb\fR. It will be called with the file handle
in not-yet-connected state as only argument and must return the connection
timeout value (or \f(CW0\fR, \f(CW\*(C`undef\*(C'\fR or the empty list to indicate the default
timeout is to be used).
.Sp
Note that the socket could be either a IPv4 \s-1TCP\s0 socket or an IPv6 \s-1TCP\s0
socket (although only IPv4 is currently supported by this module).
.Sp
Note to the poor Microsoft Windows users: Windows (of course) doesn't
correctly signal connection errors, so unless your event library works
around this, failed connections will simply hang. The only event libraries
that handle this condition correctly are \s-1EV\s0 and Glib. Additionally,
AnyEvent works around this bug with Event and in its pure-perl
backend. All other libraries cannot correctly handle this condition. To
lessen the impact of this windows bug, a default timeout of 30 seconds
will be imposed on windows. Cygwin is not affected.
.Sp
Simple Example: connect to localhost on port 22.
.Sp
.Vb 5
\&   tcp_connect localhost => 22, sub {
\&      my $fh = shift
\&         or die "unable to connect: $!";
\&      # do something
\&   };
.Ve
.Sp
Complex Example: connect to www.google.com on port 80 and make a simple
\&\s-1GET\s0 request without much error handling. Also limit the connection timeout
to 15 seconds.
.Sp
.Vb 4
\&   tcp_connect "www.google.com", "http",
\&      sub {
\&         my ($fh) = @_
\&            or die "unable to connect: $!";
\&
\&         my $handle; # avoid direct assignment so on_eof has it in scope.
\&         $handle = new AnyEvent::Handle
\&            fh     => $fh,
\&            on_error => sub {
\&               AE::log error => $_[2];
\&               $_[0]\->destroy;
\&            },
\&            on_eof => sub {
\&               $handle\->destroy; # destroy handle
\&               AE::log info => "Done.";
\&            };
\&
\&         $handle\->push_write ("GET / HTTP/1.0\e015\e012\e015\e012");
\&
\&         $handle\->push_read (line => "\e015\e012\e015\e012", sub {
\&            my ($handle, $line) = @_;
\&
\&            # print response header
\&            print "HEADER\en$line\en\enBODY\en";
\&
\&            $handle\->on_read (sub {
\&               # print response body
\&               print $_[0]\->rbuf;
\&               $_[0]\->rbuf = "";
\&            });
\&         });
\&      }, sub {
\&         my ($fh) = @_;
\&         # could call $fh\->bind etc. here
\&
\&         15
\&      };
.Ve
.Sp
Example: connect to a \s-1UNIX\s0 domain socket.
.Sp
.Vb 3
\&   tcp_connect "unix/", "/tmp/.X11\-unix/X0", sub {
\&      ...
\&   }
.Ve
.ie n .IP "$guard = tcp_server $host, $service, $accept_cb[, $prepare_cb]" 4
.el .IP "\f(CW$guard\fR = tcp_server \f(CW$host\fR, \f(CW$service\fR, \f(CW$accept_cb\fR[, \f(CW$prepare_cb\fR]" 4
.IX Item "$guard = tcp_server $host, $service, $accept_cb[, $prepare_cb]"
Create and bind a stream socket to the given host address and port, set
the \s-1SO_REUSEADDR\s0 flag (if applicable) and call \f(CW\*(C`listen\*(C'\fR. Unlike the name
implies, this function can also bind on \s-1UNIX\s0 domain sockets.
.Sp
For internet sockets, \f(CW$host\fR must be an IPv4 or IPv6 address (or
\&\f(CW\*(C`undef\*(C'\fR, in which case it binds either to \f(CW0\fR or to \f(CW\*(C`::\*(C'\fR, depending
on whether IPv4 or IPv6 is the preferred protocol, and maybe to both in
future versions, as applicable).
.Sp
To bind to the IPv4 wildcard address, use \f(CW0\fR, to bind to the IPv6
wildcard address, use \f(CW\*(C`::\*(C'\fR.
.Sp
The port is specified by \f(CW$service\fR, which must be either a service name
or a numeric port number (or \f(CW0\fR or \f(CW\*(C`undef\*(C'\fR, in which case an ephemeral
port will be used).
.Sp
For \s-1UNIX\s0 domain sockets, \f(CW$host\fR must be \f(CW\*(C`unix/\*(C'\fR and \f(CW$service\fR must be
the absolute pathname of the socket. This function will try to \f(CW\*(C`unlink\*(C'\fR
the socket before it tries to bind to it, and will try to unlink it after
it stops using it. See \s-1SECURITY\s0 \s-1CONSIDERATIONS\s0, below.
.Sp
For each new connection that could be \f(CW\*(C`accept\*(C'\fRed, call the \f(CW\*(C`$accept_cb\->($fh, $host, $port)\*(C'\fR with the file handle (in non-blocking
mode) as first, and the peer host and port as second and third arguments
(see \f(CW\*(C`tcp_connect\*(C'\fR for details).
.Sp
Croaks on any errors it can detect before the listen.
.Sp
If called in non-void context, then this function returns a guard object
whose lifetime it tied to the \s-1TCP\s0 server: If the object gets destroyed,
the server will be stopped (but existing accepted connections will
not be affected).
.Sp
Regardless, when the function returns to the caller, the socket is bound
and in listening state.
.Sp
If you need more control over the listening socket, you can provide a
\&\f(CW\*(C`$prepare_cb\->($fh, $host, $port)\*(C'\fR, which is called just before the
\&\f(CW\*(C`listen ()\*(C'\fR call, with the listen file handle as first argument, and \s-1IP\s0
address and port number of the local socket endpoint as second and third
arguments.
.Sp
It should return the length of the listen queue (or \f(CW0\fR for the default).
.Sp
Note to IPv6 users: RFC-compliant behaviour for IPv6 sockets listening on
\&\f(CW\*(C`::\*(C'\fR is to bind to both IPv6 and IPv4 addresses by default on dual-stack
hosts. Unfortunately, only GNU/Linux seems to implement this properly, so
if you want both IPv4 and IPv6 listening sockets you should create the
IPv6 socket first and then attempt to bind on the IPv4 socket, but ignore
any \f(CW\*(C`EADDRINUSE\*(C'\fR errors.
.Sp
Example: bind on some \s-1TCP\s0 port on the local machine and tell each client
to go away.
.Sp
.Vb 2
\&   tcp_server undef, undef, sub {
\&      my ($fh, $host, $port) = @_;
\&
\&      syswrite $fh, "The internet is full, $host:$port. Go away!\e015\e012";
\&   }, sub {
\&      my ($fh, $thishost, $thisport) = @_;
\&      AE::log info => "Bound to $thishost, port $thisport.";
\&   };
.Ve
.Sp
Example: bind a server on a unix domain socket.
.Sp
.Vb 3
\&   tcp_server "unix/", "/tmp/mydir/mysocket", sub {
\&      my ($fh) = @_;
\&   };
.Ve
.ie n .IP "tcp_nodelay $fh, $enable" 4
.el .IP "tcp_nodelay \f(CW$fh\fR, \f(CW$enable\fR" 4
.IX Item "tcp_nodelay $fh, $enable"
Enables (or disables) the \f(CW\*(C`TCP_NODELAY\*(C'\fR socket option (also known as
Nagle's algorithm). Returns false on error, true otherwise.
.ie n .IP "tcp_congestion $fh, $algorithm" 4
.el .IP "tcp_congestion \f(CW$fh\fR, \f(CW$algorithm\fR" 4
.IX Item "tcp_congestion $fh, $algorithm"
Sets the tcp congestion avoidance algorithm (via the \f(CW\*(C`TCP_CONGESTION\*(C'\fR
socket option). The default is OS-specific, but is usually
\&\f(CW\*(C`reno\*(C'\fR. Typical other available choices include \f(CW\*(C`cubic\*(C'\fR, \f(CW\*(C`lp\*(C'\fR, \f(CW\*(C`bic\*(C'\fR,
\&\f(CW\*(C`highspeed\*(C'\fR, \f(CW\*(C`htcp\*(C'\fR, \f(CW\*(C`hybla\*(C'\fR, \f(CW\*(C`illinois\*(C'\fR, \f(CW\*(C`scalable\*(C'\fR, \f(CW\*(C`vegas\*(C'\fR,
\&\f(CW\*(C`veno\*(C'\fR, \f(CW\*(C`westwood\*(C'\fR and \f(CW\*(C`yeah\*(C'\fR.
.SH "SECURITY CONSIDERATIONS"
.IX Header "SECURITY CONSIDERATIONS"
This module is quite powerful, with with power comes the ability to abuse
as well: If you accept \*(L"hostnames\*(R" and ports from untrusted sources,
then note that this can be abused to delete files (host=\f(CW\*(C`unix/\*(C'\fR). This
is not really a problem with this module, however, as blindly accepting
any address and protocol and trying to bind a server or connect to it is
harmful in general.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>
\& http://anyevent.schmorp.de
.Ve
