.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PSGI::FAQ 3"
.TH PSGI::FAQ 3 "2011-09-05" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PSGI::FAQ \- Frequently Asked Questions and answers
.SH "QUESTIONS"
.IX Header "QUESTIONS"
.SS "General"
.IX Subsection "General"
\fIHow do you pronounce \s-1PSGI\s0?\fR
.IX Subsection "How do you pronounce PSGI?"
.PP
We read it simply P\-S-G-I.
.PP
\fISo what is this?\fR
.IX Subsection "So what is this?"
.PP
\&\s-1PSGI\s0 is an interface between web servers and perl-based web
applications akin to what \s-1CGI\s0 does for web servers and \s-1CGI\s0 scripts.
.PP
\fIWhy do we need this?\fR
.IX Subsection "Why do we need this?"
.PP
Perl has \s-1CGI\s0 as a core module that somewhat abstracts the
difference between \s-1CGI\s0, mod_perl and FastCGI. However, most web
application framework developers (e.g. Catalyst and Jifty) usually
avoid using it to maximize the performance and to access low-level
APIs. So they end up writing adapters for all of those different
environments, some of which may be well tested while others are not.
.PP
\&\s-1PSGI\s0 allows web application framework developers to only write an
adapter for \s-1PSGI\s0.  End users can choose from among all the backends that
support the \s-1PSGI\s0 interface.
.PP
\fIYou said \s-1PSGI\s0 is similar to \s-1CGI\s0. How is the \s-1PSGI\s0 interface different from \s-1CGI\s0?\fR
.IX Subsection "You said PSGI is similar to CGI. How is the PSGI interface different from CGI?"
.PP
The \s-1PSGI\s0 interface is intentionally designed to be very similar to \s-1CGI\s0 so
that supporting \s-1PSGI\s0 in addition to \s-1CGI\s0 would be extremely easy. Here's
a highlight of the key differences between \s-1CGI\s0 and \s-1PSGI:\s0
.IP "\(bu" 4
In \s-1CGI\s0, servers are the actual web servers written in any languages
but mostly in C, and script is a script that can be written in any
language such as C, Perl, Shell scripts, Ruby or Python.
.Sp
In \s-1PSGI\s0, servers are still web servers, but they're perl processes that
are usually embedded in the web server (like mod_perl) or a perl daemon
process called by a web server (like FastCGI), or an entirely perl based
web server. And \s-1PSGI\s0 application is a perl code reference.
.IP "\(bu" 4
In \s-1CGI\s0, we use \s-1STDIN\s0, \s-1STDERR\s0, and environment variables to read
parameters and the \s-1HTTP\s0 request body and to send errors from the
application.
.Sp
In \s-1PSGI\s0, we use the \f(CW$env\fR hash references and the \fIpsgi.input\fR and
\&\fIpsgi.errors\fR streams to pass that data between servers and applications.
.IP "\(bu" 4
In \s-1CGI\s0, applications are supposed to print \s-1HTTP\s0 headers and body to
\&\s-1STDOUT\s0 to pass it back to the web server.
.Sp
In \s-1PSGI\s0, applications are supposed to return a \s-1HTTP\s0 status code,
headers, and body (as an array ref or a filehandle-like object) to the
application as an array reference.
.PP
\fIMy framework already does \s-1CGI\s0, \s-1FCGI\s0 and mod_perl. Why do I want to support \s-1PSGI\s0?\fR
.IX Subsection "My framework already does CGI, FCGI and mod_perl. Why do I want to support PSGI?"
.PP
There are many benefits for the web application framework to support \s-1PSGI\s0.
.IP "\(bu" 4
You can stop writing code to support many web server
environments.
.Sp
Plack has a lot of well-tested server adapters to environments such as
\&\s-1CGI\s0, FastCGI and mod_perl. There are also many new web servers built
to support the \s-1PSGI\s0 standard interface, such as Starman, Starlet
and Twiggy. Once your framework supports \s-1PSGI\s0, there's nothing you
need to do to run your application on these new web servers. You can
get that \fIfor free\fR.
.Sp
Also, even if your framework already supports most server environments
like discussed above, you can now drop these code in favor of only
supporting \s-1PSGI\s0. This is what Jifty and Catalyst have done, when
they implemented the \s-1PSGI\s0 support. Less code means less bugs :)
.IP "\(bu" 4
Your framework can now use all of Plack middleware components.
.Sp
Just search for \f(CW\*(C`Plack::Middleware\*(C'\fR on \s-1CPAN\s0 and you'll see hundreds
of \s-1PSGI\s0 compatible middleware components. They're often newly created,
but also extracted from plugins for certain web frameworks such as
Catalyst. By supporting \s-1PSGI\s0 interface, your framework can make use
of all of these useful middleware, such as session management, content
caching, \s-1URL\s0 rewriting and debug panel to name just a few.
.IP "\(bu" 4
You can test the application using the consistent Plack::Test interface.
.Sp
Any \s-1PSGI\s0 application can be tested using Plack::Test, either
through a mock request or a live server implementation. There's also
Test::WWW::Mechanize::PSGI to allow Mechanize-style testing.
.PP
\fII'm writing a web application. What's the benefit of \s-1PSGI\s0 for me?\fR
.IX Subsection "I'm writing a web application. What's the benefit of PSGI for me?"
.PP
If the framework you're using supports \s-1PSGI\s0, that means your
application can run on any of existing and future \s-1PSGI\s0
implementations. You can provide a \f(CW\*(C`.psgi\*(C'\fR file that returns \s-1PSGI\s0
application, the end users of your application should be able to
configure and run your application in a bunch of different ways.
.PP
\fIBut I'm writing a web application in \s-1CGI\s0 and it works well. Should I switch to \s-1PSGI\s0?\fR
.IX Subsection "But I'm writing a web application in CGI and it works well. Should I switch to PSGI?"
.PP
If you're writing a web application with a plain \s-1CGI\s0.pm and without
using any web frameworks, you're limiting your application in the
plain \s-1CGI\s0 environments, along with mod_perl and FastCGI with some
tweaks. If you're the only one developer and user of your application
then that's probably fine.
.PP
One day you want to deploy your application in a shared hosting
environment for your clients, or run your server in the standalone
mode rather than as a \s-1CGI\s0 script, or distribute your application as
open source software. Limiting your application in the \s-1CGI\s0 environment
by using \s-1CGI\s0.pm will bite you then.
.PP
You can start using one of \s-1PSGI\s0 compatible frameworks (either
full-stack ones or micro ones), or use Plack::Request if you are
anti frameworks, to make your application \s-1PSGI\s0 aware, to be more
future proof.
.PP
Even if you ignore \s-1PSGI\s0 today and write applications in plain \s-1CGI\s0, you
can always later switch to \s-1PSGI\s0 with the \s-1CGI::PSGI\s0 wrapper.
.PP
\fIWhat should I do to support \s-1PSGI\s0?\fR
.IX Subsection "What should I do to support PSGI?"
.PP
If you're a web server developer, write a \s-1PSGI\s0 implementation that
calls a \s-1PSGI\s0 application. Also join the development on Plack, the \s-1PSGI\s0
toolkit and utilities, to add a server adapter for your web server.
.PP
If you're a web application framework developer, write an adapter for
\&\s-1PSGI\s0. Now you're freed from supporting all different server
environments.
.PP
If you're a web application developer (or a web application framework
user), choose the framework that supports \s-1PSGI\s0, or ask the author to
support it. :) If your application is a large scale installable
application that doesn't use any existing frameworks (e.g. WebGUI or
Movable Type) you're considered as a framework developer instead from
the \s-1PSGI\s0 point of view. So, writing an adapter for \s-1PSGI\s0 on your
application would make more sense.
.PP
\fIIs \s-1PSGI\s0 faster than (my framework)?\fR
.IX Subsection "Is PSGI faster than (my framework)?"
.PP
Again, \s-1PSGI\s0 is not an implementation, but there's a potential for a
very fast \s-1PSGI\s0 implementation that preloads everything and runs fully
optimized code as a preforked standalone with \s-1XS\s0 parsers, an
event-based tiny web server written in C and embedded perl that
supports \s-1PSGI\s0, or a plain-old \s-1CGI\s0.pm based backend that doesn't load
any modules at all and runs pretty quickly without eating so much
memory under the \s-1CGI\s0 environment.
.PP
There are prefork web server implementations such as Starman and
Starlet, as well as fully asynchronous event based implementations
such as Twiggy, Corona or Feersum. They're pretty fast and
they include adapters for Plack so you can run with the plackup
utility.
.PP
Users of your framework can choose which backend is the best for their
needs.  You, as a web application framework developer, don't need to
think about lots of different users with different needs.
.SS "Plack"
.IX Subsection "Plack"
\fIWhat is Plack? What is the difference between \s-1PSGI\s0 and Plack?\fR
.IX Subsection "What is Plack? What is the difference between PSGI and Plack?"
.PP
\&\s-1PSGI\s0 is a specification, so there's no software or module called \s-1PSGI\s0.
End users will need to choose one of the \s-1PSGI\s0 server implementations
to run \s-1PSGI\s0 applications on. Plack is a set of \s-1PSGI\s0 utilities and
contains the reference \s-1PSGI\s0 server HTTP::Server::PSGI, as well as
Web server adapters for \s-1CGI\s0, FastCGI and mod_perl.
.PP
Plack also has useful APIs and helpers on top of \s-1PSGI\s0, such as
Plack::Request to provide a nice object-oriented \s-1API\s0 on request
objects, plackup that allows you to run an \s-1PSGI\s0 application from
the command line and configure it using \f(CW\*(C`app.psgi\*(C'\fR (a la Rack's
Rackup), and Plack::Test that allows you to test your application
using standard HTTP::Request and HTTP::Response pair through
mocked \s-1HTTP\s0 or live \s-1HTTP\s0 servers. See Plack for details.
.PP
\fIWhat kind of server backends would be available?\fR
.IX Subsection "What kind of server backends would be available?"
.PP
In Plack, we already support most web servers like Apache2, and also
the ones that supports standard \s-1CGI\s0 or FastCGI, but also try to
support special web servers that can embed perl, like Perlbal or
nginx. We think it would be really nice if Apache module mod_perlite
and Google AppEngine supported \s-1PSGI\s0 too, so that you could run your
PSGI/Plack based perl app in the cloud.
.PP
\fIRuby is Rack and JavaScript is Jack. Why is it not called Pack?\fR
.IX Subsection "Ruby is Rack and JavaScript is Jack. Why is it not called Pack?"
.PP
Well Pack indeed is a cute name, but Perl has a built-in function pack
so it's a little confusing, especially when speaking instead of writing.
.PP
\fIWhat namespaces should I use to implement \s-1PSGI\s0 support?\fR
.IX Subsection "What namespaces should I use to implement PSGI support?"
.PP
\&\fBDo not use the \s-1PSGI::\s0 namespace to implement \s-1PSGI\s0 backends
or adapters\fR.
.PP
The \s-1PSGI\s0 namespace is reserved for \s-1PSGI\s0 specifications and reference
unit tests that implementors have to pass. It should not be used by
particular implementations.
.PP
If you write a plugin or an extension to support \s-1PSGI\s0 for an
(imaginary) web application framework called \f(CW\*(C`Camper\*(C'\fR, name the code
such as \f(CW\*(C`Camper::Engine::PSGI\*(C'\fR.
.PP
If you write a web server that supports \s-1PSGI\s0 interface, then name it
however you want. You can optionally support Plack::Handler's
abstract interface or write an adapter for it, which is:
.PP
.Vb 2
\&  my $server = Plack::Handler::FooBar\->new(%opt);
\&  $server\->run($app);
.Ve
.PP
By supporting this \f(CW\*(C`new\*(C'\fR and \f(CW\*(C`run\*(C'\fR in your server, it becomes
plackup compatible, so users can run your app via \f(CW\*(C`plackup\*(C'\fR. You're
recommended to, but not required to follow this \s-1API\s0, in which case you
have to provide your own \s-1PSGI\s0 app launcher.
.PP
\fII have a \s-1CGI\s0 or mod_perl application that I want to run on PSGI/Plack. What should I do?\fR
.IX Subsection "I have a CGI or mod_perl application that I want to run on PSGI/Plack. What should I do?"
.PP
You have several choices:
.IP "\s-1CGI::PSGI\s0" 4
.IX Item "CGI::PSGI"
If you have a web application (or framework) that uses \s-1CGI\s0.pm to handle
query parameters, \s-1CGI::PSGI\s0 can help you migrate to \s-1PSGI\s0.  You'll
need to change how you create \s-1CGI\s0 objects and how to return the response
headers and body, but the rest of your code will work unchanged.
.IP "CGI::Emulate::PSGI and CGI::Compile" 4
.IX Item "CGI::Emulate::PSGI and CGI::Compile"
If you have a dead old \s-1CGI\s0 script that you want to change as little as
possible (or even no change at all), then CGI::Emulate::PSGI and
CGI::Compile can compile and wrap them up as a \s-1PSGI\s0 application.
.Sp
Compared to \s-1CGI::PSGI\s0, this might be less efficient because of
\&\s-1STDIN/STDOUT\s0 capturing and environment variable mangling, but should
work with any \s-1CGI\s0 implementation, not just \s-1CGI\s0.pm, and CGI::Compile
does the job of compiling a \s-1CGI\s0 script into a code reference just like
mod_perl's Registry does.
.IP "Plack::Request and Plack::Response" 4
.IX Item "Plack::Request and Plack::Response"
If you have an HTTP::Engine based application (framework), or want to
write an app from scratch and need a better interface than \s-1CGI\s0, or
you're used to Apache::Request, then Plack::Request and
Plack::Response might be what you want. It gives you a nice
Request/Response object \s-1API\s0 on top of the \s-1PSGI\s0 env hash and response
array.
.PP
\&\s-1NOTE:\s0 Don't forget that whenever you have a \s-1CGI\s0 script that runs once
and exits, and you turn it into a persistent process, it may have
cleanup that needs to happen after every request \*(-- variables that need
to be reset, files that need to be closed or deleted, etc.  \s-1PSGI\s0 can do
nothing about that (you have to fix it) except give you this friendly
reminder.
.SS "HTTP::Engine"
.IX Subsection "HTTP::Engine"
\fIWhy PSGI/Plack instead of HTTP::Engine?\fR
.IX Subsection "Why PSGI/Plack instead of HTTP::Engine?"
.PP
HTTP::Engine was a great experiment, but it mixed the application
interface (the \f(CW\*(C`request_handler\*(C'\fR interface) with implementations, and
the monolithic class hierarchy and role based interfaces make it really
hard to write a new backend. We kept the existing HTTP::Engine and broke
it into three parts: The interface specification (\s-1PSGI\s0), Reference
server implementations (Plack::Handler) and Standard APIs and Tools
(Plack).
.PP
\fIWill HTTP::Engine be dead?\fR
.IX Subsection "Will HTTP::Engine be dead?"
.PP
It won't be dead. HTTP::Engine will stay as it is and still be useful
if you want to write a micro webserver application rather than a
framework.
.PP
\fIDo I have to rewrite my HTTP::Engine application to follow \s-1PSGI\s0 interface?\fR
.IX Subsection "Do I have to rewrite my HTTP::Engine application to follow PSGI interface?"
.PP
No, you don't need to rewrite your existing HTTP::Engine application.
It can be easily turned into a \s-1PSGI\s0 application using
HTTP::Engine::Interface::PSGI.
.PP
Alternatively, you can use Plack::Request and Plack::Response
which gives compatible APIs to HTTP::Engine::Request and
HTTP::Engine::Response:
.PP
.Vb 2
\&  use Plack::Request;
\&  use Plack::Response;
\&
\&  sub request_handler {
\&      my $req = Plack::Request\->new(shift);
\&      my $res = Plack::Response\->new;
\&      # ...
\&      return $res\->finalize;
\&  }
.Ve
.PP
And this \f(CW\*(C`request_handler\*(C'\fR is a \s-1PSGI\s0 application now.
.SS "\s-1API\s0 Design"
.IX Subsection "API Design"
Keep in mind that most design choices made in the \s-1PSGI\s0 spec are to
minimize the requirements on backends so they can optimize things.
Adding a fancy interface or allowing flexibility in the \s-1PSGI\s0 layers
might sound catchy to end users, but it would just add things that
backends have to support, which would end up getting in the way of
optimizations, or introducing more bugs. What makes a fancy \s-1API\s0 to
attract web application developers is your framework, not \s-1PSGI\s0.
.PP
\fIWhy a big env hash instead of objects with APIs?\fR
.IX Subsection "Why a big env hash instead of objects with APIs?"
.PP
The simplicity of the interface is the key that made \s-1WSGI\s0 and Rack
successful. \s-1PSGI\s0 is a low-level interface between backends and web
application framework developers. If we define an \s-1API\s0 on what type of
objects should be passed and which method they need to implement,
there will be so much duplicated code in the backends, some of
which may be buggy.
.PP
For instance, \s-1PSGI\s0 defines \f(CW\*(C`$env\->{SERVER_NAME}\*(C'\fR as a
string. What if the \s-1PSGI\s0 spec required it to be an instance of Net::IP?
Backend code would have to depend on the Net::IP module, or have to
write a mock object that implements \s-1ALL\s0 of Net::IP's methods.
Backends depending on specific modules or having to reinvent lots
of stuff is considered harmful and that's why the interface is as minimal
as possible.
.PP
Making a nice \s-1API\s0 for the end users is a job that web application
frameworks (adapter developers) should do, not something \s-1PSGI\s0 needs to
define.
.PP
\fIWhy is the application a code ref rather than an object with a \->call method?\fR
.IX Subsection "Why is the application a code ref rather than an object with a ->call method?"
.PP
Requiring an object \fIin addition to\fR a code ref would make \s-1EVERY\s0
backend's code a few lines more tedious, while requiring an object
\&\fIinstead of\fR a code ref would make application developers write
another class and instanciate an object.
.PP
In other words, yes an object with a \f(CW\*(C`call\*(C'\fR method could work, but
again \s-1PSGI\s0 was designed to be as simple as possible, and making a code
reference out of class/object is no brainer but the other way round
always requires a few lines of code and possibly a new file.
.PP
\fIWhy are the headers returned as an array ref and not a hash ref?\fR
.IX Subsection "Why are the headers returned as an array ref and not a hash ref?"
.PP
Short: In order to support multiple headers (e.g. \f(CW\*(C`Set\-Cookie\*(C'\fR).
.PP
Long: In Python \s-1WSGI\s0, the response header is a list of (\f(CW\*(C`header_name\*(C'\fR,
\&\f(CW\*(C`header_value\*(C'\fR) \fItuples\fR i.e. \f(CW\*(C`type(response_headers) is ListType\*(C'\fR
so there can be multiple entries for the same header key. In Rack and
\&\s-1JSGI\s0, a header value is a String consisting of lines separated by
"\f(CW\*(C`\en\*(C'\fR".
.PP
We liked Python's specification here, and since Perl hashes don't
allow multiple entries with the same key (unless it's \f(CW\*(C`tie\*(C'\fRd), using
an array reference to store \f(CW\*(C`[ key => value, key => value ]\*(C'\fR is
the simplest solution to keep both framework adapters and
backends simple. Other options, like allowing an array ref
in addition to a plain scalar, make either side of the code
unnecessarily tedious.
.PP
\fII want to send Unicode content in the \s-1HTTP\s0 response. How can I do so?\fR
.IX Subsection "I want to send Unicode content in the HTTP response. How can I do so?"
.PP
\&\s-1PSGI\s0 mocks wire protocols like \s-1CGI\s0, and the interface doesn't care too
much about the character encodings and string semantics. That means,
all the data on \s-1PSGI\s0 environment values, content body etc. are sent as
byte strings, and it is an application's responsibility to properly
decode or encode characters such that it's being sent over \s-1HTTP\s0.
.PP
If you have a decoded string in your application and want to send them
in \f(CW\*(C`UTF\-8\*(C'\fR as an \s-1HTTP\s0 body, you should use Encode module to encode
it to utf\-8. Note that if you use one of PSGI-supporting frameworks,
chances are that they allow you to set Unicode text in the response
body and they do the encoding for you. Check the documentation of your
framework to see if that's the case.
.PP
This design decision was made so it gives more flexibility to \s-1PSGI\s0
applications and frameworks, without putting complicated work into
\&\s-1PSGI\s0 web servers and interface specification itself.
.PP
\fINo iterators support in \f(CI$body\fI?\fR
.IX Subsection "No iterators support in $body?"
.PP
We learned that \s-1WSGI\s0 and Rack really enjoy the benefit of Python and
Ruby's language beauty, which are iterable objects in Python or
iterators in Ruby.
.PP
Rack, for instance, expects the body as an object that responds to
the \f(CW\*(C`each\*(C'\fR method and then yields the buffer, so
.PP
.Vb 1
\&  body.each { |buf| request.write(buf) }
.Ve
.PP
would just magically work whether body is an Array, FileIO object or an
object that implements iterators. Perl doesn't have such a beautiful
thing in the language unless autobox is loaded.  \s-1PSGI\s0 should not make
autobox as a requirement, so we only support a simple array ref or file
handle.
.PP
Writing an IO::Handle\-like object is pretty easy since it's only
\&\f(CW\*(C`getline\*(C'\fR and \f(CW\*(C`close\*(C'\fR. You can also use PerlIO to write an object that
behaves like a filehandle, though it might be considered a little
unstable.
.PP
See also IO::Handle::Util to turn anything iterators-like into
IO::Handle\-like.
.PP
\fIHow should server determine to switch to \fIsendfile\fI\|(2) based serving?\fR
.IX Subsection "How should server determine to switch to sendfile based serving?"
.PP
First of all, an application \s-1SHOULD\s0 always set a IO::Handle\-like
object (or an array of chunks) that responds to \f(CW\*(C`getline\*(C'\fR and
\&\f(CW\*(C`close\*(C'\fR as a body. That is guaranteed to work with any servers.
.PP
Optionally, if the server is written in perl or can tell a file
descriptor number to the C\-land to serve the file, then the server \s-1MAY\s0
check if the body is a real filehandle (possibly using
Plack::Util's \f(CW\*(C`is_real_fh\*(C'\fR function), then get a file descriptor
with \f(CW\*(C`fileno\*(C'\fR and call \fIsendfile\fR\|(2) or equivalent zero-copy data
transfer using that.
.PP
Otherwise, if the server can't send a file using the file descriptor
but needs a local file path (like mod_perl or nginx), the application
can return an IO::Handle\-like object that also responds to \f(CW\*(C`path\*(C'\fR
method. This type of IO-like object can easily be created using
IO::File::WithPath, IO::Handle::Util or Plack::Util's
\&\f(CW\*(C`set_io_path\*(C'\fR function.
.PP
Middlewares can also look to see if the body has \f(CW\*(C`path\*(C'\fR method and
does something interesting with it, like setting \f(CW\*(C`X\-Sendfile\*(C'\fR
headers.
.PP
To summarize:
.IP "\(bu" 4
When to serve static files, applications should always return a real
filehandle or IO::Handle object. That should work everywhere, and can
be optimized in some environments.
.IP "\(bu" 4
Applications can also set IO::Handle like object with an additional
\&\f(CW\*(C`path\*(C'\fR method, then it should work everywhere again, and can be
optimized in even more environments.
.PP
\fIWhat if I want to stream content or do a long-poll Comet?\fR
.IX Subsection "What if I want to stream content or do a long-poll Comet?"
.PP
The most straightforward way to implement server push is for your
application to return a IO::Handle\-like object as a content body that
implements \f(CW\*(C`getline\*(C'\fR to return pushed content. This is guaranteed to
work everywhere, but it's more like \fIpull\fR than \fIpush\fR, and it's
hard to do non-blocking I/O unless you use Coro.
.PP
If you want to do server push, where your application runs in an event
loop and push content body to the client as it's ready, you should
return a callback to delay the response.
.PP
.Vb 10
\&  # long\-poll comet like a chat application
\&  my $app = sub {
\&      my $env = shift;
\&      unless ($env\->{\*(Aqpsgi.streaming\*(Aq}) {
\&          die "This application needs psgi.streaming support";
\&      }
\&      return sub {
\&          my $respond = shift;
\&          wait_for_new_message(sub {
\&              my $message = shift;
\&              my $body = [ $message\->to_json ];
\&              $respond\->([200, [\*(AqContent\-Type\*(Aq, \*(Aqapplication/json\*(Aq], $body]);
\&          });
\&      };
\&  };
.Ve
.PP
\&\f(CW\*(C`wait_for_new_message\*(C'\fR can be blocking or non-blocking: it's up to
you. Most of the case you want to run it non-blockingly and should use
event loops like AnyEvent. You may also check \f(CW\*(C`psgi.nonblocking\*(C'\fR
value to see that it's possible and fallback to a blocking call
otherwise.
.PP
Also, to stream the content body (like streaming messages over the
Flash socket or multipart XMLHTTPRequest):
.PP
.Vb 10
\&  my $app = sub {
\&      my $env = shift;
\&      unless ($env\->{\*(Aqpsgi.streaming\*(Aq}) {
\&          die "This application needs psgi.streaming support";
\&      }
\&      return sub {
\&          my $respond = shift;
\&          my $writer = $respond\->([200, [\*(AqContent\-Type\*(Aq, \*(Aqtext/plain\*(Aq]]);
\&          wait_for_new_message(sub {
\&              my $message = shift;
\&              if ($message) {
\&                  $writer\->write($message\->to_json);
\&              } else {
\&                  $writer\->close;
\&              }
\&          });
\&      };
\&  };
.Ve
.PP
\fIWhich framework should I use to do streaming though?\fR
.IX Subsection "Which framework should I use to do streaming though?"
.PP
We have servers that support non-blocking (where \f(CW\*(C`psgi.nonblocking\*(C'\fR
is set to true), but the problem is that framework side doesn't
necessarily support asynchronous event loop. For instance Catalyst has
\&\f(CW\*(C`write\*(C'\fR method on the response object:
.PP
.Vb 3
\&  while ($cond) {
\&      $c\->res\->write($some_stuff);
\&  }
.Ve
.PP
This should work with all servers with \f(CW\*(C`psgi.streaming\*(C'\fR support even
if they are blocking, and it should be fine if they're running in
multiple processes (\f(CW\*(C`psgi.multiprocess\*(C'\fR is true).
.PP
Catalyst::Engine::PSGI also supports setting an IO::Handle\-like
object that supports \f(CW\*(C`getline\*(C'\fR, so using IO::Handle::Util
.PP
.Vb 4
\&  my $io = io_from_getline sub {
\&       return $data; # or undef when done()
\&  };
\&  $c\->res\->body($io);
.Ve
.PP
And that works fine to do streaming, but it's blocking (\fIpull\fR)
rather than asynchronous server push, so again you should be careful
not to run this application on non-blocking (and non-multiprocess)
server environments.
.PP
We expect that more web frameworks will appear that is focused on, or
existent frameworks will add support for, asynchronous and
non-blocking streaming interface.
.PP
\fIIs psgi.streaming interface a requirement for the servers?\fR
.IX Subsection "Is psgi.streaming interface a requirement for the servers?"
.PP
It is specified as \fB\s-1SHOULD\s0\fR, so unless there is a strong reason not
to implement the interface, all servers are encouraged to implement
this interface.
.PP
However, if you implement a \s-1PSGI\s0 server using an Perl \s-1XS\s0 interface for
the ultimate performance or integration with web servers like Apache
or nginx, or implement a sandbox like environment (like Google
AppEngine or Heroku) or distributed platform using tools like Gearman,
you might not want to implement this interface.
.PP
That's fine, and in that case applications relying on the streaming
interface can still use Plack::Middleware::BufferedStreaming to
fallback to the buffered write on unsupported servers.
.PP
\fIWhy CGI-style environment variables instead of \s-1HTTP\s0 headers as a hash?\fR
.IX Subsection "Why CGI-style environment variables instead of HTTP headers as a hash?"
.PP
Most existing web application frameworks already have code or a handler
to run under the \s-1CGI\s0 environment. Using CGI-style hash keys instead of
\&\s-1HTTP\s0 headers makes it trivial for the framework developers to implement
an adapter to support \s-1PSGI\s0. For instance, Catalyst::Engine::PSGI is
only a few dozens lines different from Catalyst::Engine::CGI and was
written in less than an hour.
.PP
\fIWhy is \s-1PATH_INFO\s0 \s-1URI\s0 decoded?\fR
.IX Subsection "Why is PATH_INFO URI decoded?"
.PP
To be compatible with \s-1CGI\s0 spec (\s-1RFC\s0 3875) and most web servers'
implementations (like Apache and lighttpd).
.PP
I understand it could be inconvenient that you can't distinguish
\&\f(CW\*(C`foo%2fbar\*(C'\fR from \f(CW\*(C`foo/bar\*(C'\fR in the trailing path, but the \s-1CGI\s0 spec
clearly says \f(CW\*(C`PATH_INFO\*(C'\fR should be decoded by servers, and that web
servers can deny such requests containing \f(CW%2f\fR (since such requests
would lose information in \s-1PATH_INFO\s0). Leaving those reserved characters
undecoded (partial decoding) would make things worse, since then you
can't tell \f(CW\*(C`foo%2fbar\*(C'\fR from \f(CW\*(C`foo%252fbar\*(C'\fR and could be a security hole
with double encoding or decoding.
.PP
For web application frameworks that need more control over the actual
raw \s-1URI\s0 (such as Catalyst), we made the \f(CW\*(C`REQUEST_URI\*(C'\fR environment
hash key \s-1REQUIRED\s0. The servers should set the undecoded (unparsed)
original \s-1URI\s0 (containing the query string) to this key. Note that
\&\f(CW\*(C`REQUEST_URI\*(C'\fR is completely raw even if the encoded entities are
URI-safe.
.PP
For comparison, \s-1WSGI\s0 (\s-1PEP\-333\s0) defines both \f(CW\*(C`SCRIPT_NAME\*(C'\fR and
\&\f(CW\*(C`PATH_INFO\*(C'\fR be decoded and Rack leaves it implementation dependent,
while \fIfixing\fR most of \s-1PATH_INFO\s0 left encoded in Ruby web server
implementations.
.PP
<http://www.python.org/dev/peps/pep\-0333/#url\-reconstruction>
<http://groups.google.com/group/rack\-devel/browse_thread/thread/ddf4622e69bea53f>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1WSGI\s0's \s-1FAQ\s0 clearly answers lots of questions about how some \s-1API\s0 design
decisions were made, some of which can directly apply to \s-1PSGI\s0.
.PP
<http://www.python.org/dev/peps/pep\-0333/#questions\-and\-answers>
.SH "MORE QUESTIONS?"
.IX Header "MORE QUESTIONS?"
If you have a question that is not answered here, or things you totally
disagree with, come join the \s-1IRC\s0 channel #plack on irc.perl.org or
mailing list <http://groups.google.com/group/psgi\-plack>. Be sure you
clarify which hat you're wearing: application developers, server
implementors or middleware developers. And don't criticize the spec just
to criticize it: show your exact code that doesn't work or get too messy
because of spec restrictions etc. We'll ignore all nitpicks and bikeshed
discussion.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tatsuhiko Miyagawa <miyagawa@bulknews.net>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright Tatsuhiko Miyagawa, 2009\-2010.
.PP
This document is licensed under the Creative Commons license by-sa.
