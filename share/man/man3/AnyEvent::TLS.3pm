.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AnyEvent::TLS 3"
.TH AnyEvent::TLS 3 "2012-04-13" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
AnyEvent::TLS \- SSLv2/SSLv3/TLSv1 contexts for use in AnyEvent::Handle
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   # via AnyEvent::Handle
\&
\&   use AnyEvent;
\&   use AnyEvent::Handle;
\&   use AnyEvent::Socket;
\&
\&   # simple https\-client
\&   my $handle = new AnyEvent::Handle
\&      connect  => [$host, $port],
\&      tls      => "connect",
\&      tls_ctx  => { verify => 1, verify_peername => "https" },
\&      ...
\&
\&   # simple ssl\-server
\&   tcp_server undef, $port, sub {
\&      my ($fh) = @_;
\&
\&      my $handle = new AnyEvent::Handle
\&         fh       => $fh,
\&         tls      => "accept",
\&         tls_ctx  => { cert_file => "my\-server\-keycert.pem" },
\&         ...
\&
\&   # directly
\&
\&   my $tls = new AnyEvent::TLS
\&      verify => 1,
\&      verify_peername => "ldaps",
\&      ca_file => "/etc/cacertificates.pem";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is a helper module that implements \s-1TLS/SSL\s0 (Transport Layer
Security/Secure Sockets Layer) contexts. A \s-1TLS\s0 context is a common set of
configuration values for use in establishing \s-1TLS\s0 connections.
.PP
For some quick facts about \s-1SSL/TLS\s0, see the section of the same name near
the end of the document.
.PP
A single \s-1TLS\s0 context can be used for any number of \s-1TLS\s0 connections that
wish to use the same certificates, policies etc.
.PP
Note that this module is inherently tied to Net::SSLeay, as this
library is used to implement it. Since that perl module is rather ugly,
and OpenSSL has a rather ugly license, AnyEvent might switch \s-1TLS\s0 providers
at some future point, at which this \s-1API\s0 will change dramatically, at least
in the Net::SSLeay\-specific parts (most constructor arguments should still
work, though).
.PP
Although this module does not require a specific version of Net::SSLeay,
many features will gradually stop working, or bugs will be introduced with
old versions (verification might succeed when it shouldn't \- this is a
real security issue). Version 1.35 is recommended, 1.33 should work, 1.32
might, and older versions are yours to keep.
.SH "USAGE EXAMPLES"
.IX Header "USAGE EXAMPLES"
See the AnyEvent::Handle manpage, \s-1NONFREQUENTLY\s0 \s-1ASKED\s0 \s-1QUESTIONS\s0, for
some actual usage examples.
.SH "PUBLIC METHODS AND FUNCTIONS"
.IX Header "PUBLIC METHODS AND FUNCTIONS"
.ie n .IP "$tls = new AnyEvent::TLS key => value..." 4
.el .IP "\f(CW$tls\fR = new AnyEvent::TLS key => value..." 4
.IX Item "$tls = new AnyEvent::TLS key => value..."
The constructor supports these arguments (all as key => value pairs).
.RS 4
.ie n .IP "method => ""SSLv2"" | ""SSLv3"" | ""TLSv1"" | ""any""" 4
.el .IP "method => ``SSLv2'' | ``SSLv3'' | ``TLSv1'' | ``any''" 4
.IX Item "method => SSLv2 | SSLv3 | TLSv1 | any"
The protocol parser to use. \f(CW\*(C`SSLv2\*(C'\fR, \f(CW\*(C`SSLv3\*(C'\fR and \f(CW\*(C`TLSv1\*(C'\fR will use
a parser for those protocols only (so will \fInot\fR accept or create
connections with/to other protocol versions), while \f(CW\*(C`any\*(C'\fR (the
default) uses a parser capable of all three protocols.
.Sp
The default is to use \f(CW"any"\fR but disable SSLv2. This has the effect of
sending a SSLv2 hello, indicating the support for SSLv3 and TLSv1, but not
actually negotiating an (insecure) SSLv2 connection.
.Sp
Specifying a specific version is almost always wrong to use for a server
speaking to a wide variety of clients (e.g. web browsers), and often wrong
for a client. If you only want to allow a specific protocol version, use
the \f(CW\*(C`sslv2\*(C'\fR, \f(CW\*(C`sslv3\*(C'\fR or \f(CW\*(C`tlsv1\*(C'\fR arguments instead.
.Sp
For new services it is usually a good idea to enforce a \f(CW\*(C`TLSv1\*(C'\fR method
from the beginning.
.ie n .IP "sslv2 => $enabled" 4
.el .IP "sslv2 => \f(CW$enabled\fR" 4
.IX Item "sslv2 => $enabled"
Enable or disable SSLv2 (normally \fIdisabled\fR).
.ie n .IP "sslv3 => $enabled" 4
.el .IP "sslv3 => \f(CW$enabled\fR" 4
.IX Item "sslv3 => $enabled"
Enable or disable SSLv3 (normally \fIenabled\fR).
.ie n .IP "tlsv1 => $enabled" 4
.el .IP "tlsv1 => \f(CW$enabled\fR" 4
.IX Item "tlsv1 => $enabled"
Enable or disable TLSv1 (normally \fIenabled\fR).
.ie n .IP "verify => $enable" 4
.el .IP "verify => \f(CW$enable\fR" 4
.IX Item "verify => $enable"
Enable or disable peer certificate checking (default is \fIdisabled\fR, which
is \fInot recommended\fR).
.Sp
This is the \*(L"master switch\*(R" for all verify-related parameters and
functions.
.Sp
If it is disabled, then no peer certificate verification will be done
\&\- the connection will be encrypted, but the peer certificate won't be
verified against any known CAs, or whether it is still valid or not. No
peername verification or custom verification will be done either.
.Sp
If enabled, then the peer certificate (required in client mode, optional
in server mode, see \f(CW\*(C`verify_require_client_cert\*(C'\fR) will be checked against
its \s-1CA\s0 certificate chain \- that means there must be a signing chain from
the peer certificate to any of the \s-1CA\s0 certificates you trust locally, as
specified by the \f(CW\*(C`ca_file\*(C'\fR and/or \f(CW\*(C`ca_path\*(C'\fR and/or \f(CW\*(C`ca_cert\*(C'\fR parameters
(or the system default \s-1CA\s0 repository, if all of those parameters are
missing \- see also the AnyEvent manpage for the description of
\&\s-1PERL_ANYEVENT_CA_FILE\s0).
.Sp
Other basic checks, such as checking the validity period, will also be
done, as well as optional peername/hostname/common name verification
\&\f(CW\*(C`verify_peername\*(C'\fR.
.Sp
An optional \f(CW\*(C`verify_cb\*(C'\fR callback can also be set, which will be invoked
with the verification results, and which can override the decision.
.ie n .IP "verify_require_client_cert => $enable" 4
.el .IP "verify_require_client_cert => \f(CW$enable\fR" 4
.IX Item "verify_require_client_cert => $enable"
Enable or disable mandatory client certificates (default is
\&\fIdisabled\fR). When this mode is enabled, then a client certificate will be
required in server mode (a server certificate is mandatory, so in client
mode, this switch has no effect).
.ie n .IP "verify_peername => $scheme | $callback\->($tls, $cert, $peername)" 4
.el .IP "verify_peername => \f(CW$scheme\fR | \f(CW$callback\fR\->($tls, \f(CW$cert\fR, \f(CW$peername\fR)" 4
.IX Item "verify_peername => $scheme | $callback->($tls, $cert, $peername)"
\&\s-1TLS\s0 only protects the data that is sent \- it cannot automatically verify
that you are really talking to the right peer. The reason is that
certificates contain a \*(L"common name\*(R" (and a set of possible alternative
\&\*(L"names\*(R") that need to be checked against the peername (usually, but not
always, the \s-1DNS\s0 name of the server) in a protocol-dependent way.
.Sp
This can be implemented by specifying a callback that has to verify that
the actual \f(CW$peername\fR matches the given certificate in \f(CW$cert\fR.
.Sp
Since this can be rather hard to implement, AnyEvent::TLS offers a variety
of predefined \*(L"schemes\*(R" (lifted from IO::Socket::SSL) that are named
like the protocols that use them:
.RS 4
.IP "ldap (rfc4513), pop3,imap,acap (rfc2995), nntp (rfc4642)" 4
.IX Item "ldap (rfc4513), pop3,imap,acap (rfc2995), nntp (rfc4642)"
Simple wildcards in subjectAltNames are possible, e.g. *.example.org
matches www.example.org but not lala.www.example.org. If nothing from
subjectAltNames matches, it checks against the common name, but there are
no wildcards allowed.
.IP "http (rfc2818)" 4
.IX Item "http (rfc2818)"
Extended wildcards in subjectAltNames are possible, e.g. *.example.org or
even www*.example.org. Wildcards in the common name are not allowed. The
common name will be only checked if no host names are given in
subjectAltNames.
.IP "smtp (rfc3207)" 4
.IX Item "smtp (rfc3207)"
This \s-1RFC\s0 isn't very useful in determining how to do verification so it
just assumes that subjectAltNames are possible, but no wildcards are
possible anywhere.
.ie n .IP "[$check_cn, $wildcards_in_alt, $wildcards_in_cn]" 4
.el .IP "[$check_cn, \f(CW$wildcards_in_alt\fR, \f(CW$wildcards_in_cn\fR]" 4
.IX Item "[$check_cn, $wildcards_in_alt, $wildcards_in_cn]"
You can also specify a scheme yourself by using an array reference with
three integers.
.Sp
\&\f(CW$check_cn\fR specifies if and how the common name field is used: \f(CW0\fR
means it will be completely ignored, \f(CW1\fR means it will only be used if
no host names have been found in the subjectAltNames, and \f(CW2\fR means the
common name will always be checked against the peername.
.Sp
\&\f(CW$wildcards_in_alt\fR and \f(CW$wildcards_in_cn\fR specify whether and where
wildcards (\f(CW\*(C`*\*(C'\fR) are allowed in subjectAltNames and the common name,
respectively. \f(CW0\fR means no wildcards are allowed, \f(CW1\fR means they
are allowed only as the first component (\f(CW\*(C`*.example.org\*(C'\fR), and \f(CW2\fR
means they can be used anywhere (\f(CW\*(C`www*.example.org\*(C'\fR), except that very
dangerous matches will not be allowed (\f(CW\*(C`*.org\*(C'\fR or \f(CW\*(C`*\*(C'\fR).
.RE
.RS 4
.Sp
You can specify either the name of the parent protocol (recommended,
e.g. \f(CW\*(C`http\*(C'\fR, \f(CW\*(C`ldap\*(C'\fR), the protocol name as usually used in URIs
(e.g. \f(CW\*(C`https\*(C'\fR, \f(CW\*(C`ldaps\*(C'\fR) or the \s-1RFC\s0 (not recommended, e.g. \f(CW\*(C`rfc2995\*(C'\fR,
\&\f(CW\*(C`rfc3920\*(C'\fR).
.Sp
This verification will only be done when verification is enabled (\f(CW\*(C`verify => 1\*(C'\fR).
.RE
.ie n .IP "verify_cb => $callback\->($tls, $ref, $cn, $depth, $preverify_ok, $x509_store_ctx, $cert)" 4
.el .IP "verify_cb => \f(CW$callback\fR\->($tls, \f(CW$ref\fR, \f(CW$cn\fR, \f(CW$depth\fR, \f(CW$preverify_ok\fR, \f(CW$x509_store_ctx\fR, \f(CW$cert\fR)" 4
.IX Item "verify_cb => $callback->($tls, $ref, $cn, $depth, $preverify_ok, $x509_store_ctx, $cert)"
Provide a custom peer verification callback used by \s-1TLS\s0 sessions,
which is called with the result of any other verification (\f(CW\*(C`verify\*(C'\fR,
\&\f(CW\*(C`verify_peername\*(C'\fR).
.Sp
This callback will only be called when verification is enabled (\f(CW\*(C`verify
=> 1\*(C'\fR).
.Sp
\&\f(CW$tls\fR is the \f(CW\*(C`AnyEvent::TLS\*(C'\fR object associated with the session,
while \f(CW$ref\fR is whatever the user associated with the session (usually
an AnyEvent::Handle object when used by AnyEvent::Handle).
.Sp
\&\f(CW$depth\fR is the current verification depth \- \f(CW\*(C`$depth = 0\*(C'\fR means the
certificate to verify is the peer certificate, higher levels are its \s-1CA\s0
certificate and so on. In most cases, you can just return \f(CW$preverify_ok\fR
if the \f(CW$depth\fR is non-zero:
.Sp
.Vb 2
\&   verify_cb => sub {
\&      my ($tls, $ref, $cn, $depth, $preverify_ok, $x509_store_ctx, $cert) = @_;
\&
\&      return $preverify_ok
\&         if $depth;
\&
\&      # more verification
\&   },
.Ve
.Sp
\&\f(CW$preverify_ok\fR is true iff the basic verification of the certificates
was successful (a valid \s-1CA\s0 chain must exist, the certificate has passed
basic validity checks, peername verification succeeded).
.Sp
\&\f(CW$x509_store_ctx\fR is the Net::SSLeay::X509_CTX> object.
.Sp
\&\f(CW$cert\fR is the \f(CW\*(C`Net::SSLeay::X509\*(C'\fR object representing the
peer certificate, or zero if there was an error. You can call
\&\f(CW\*(C`AnyEvent::TLS::certname $cert\*(C'\fR to get a nice user-readable string to
identify the certificate.
.Sp
The callback must return either \f(CW0\fR to indicate failure, or \f(CW1\fR to
indicate success.
.ie n .IP "verify_client_once => $enable" 4
.el .IP "verify_client_once => \f(CW$enable\fR" 4
.IX Item "verify_client_once => $enable"
Enable or disable skipping the client certificate verification on
renegotiations (default is \fIdisabled\fR, the certificate will always be
checked). Only makes sense in server mode.
.ie n .IP "ca_file => $path" 4
.el .IP "ca_file => \f(CW$path\fR" 4
.IX Item "ca_file => $path"
If this parameter is specified and non-empty, it will be the path to a
file with (server) \s-1CA\s0 certificates in \s-1PEM\s0 format that will be loaded. Each
certificate will look like:
.Sp
.Vb 3
\&   \-\-\-\-\-BEGIN CERTIFICATE\-\-\-\-\-
\&   ... (CA certificate in base64 encoding) ...
\&   \-\-\-\-\-END CERTIFICATE\-\-\-\-\-
.Ve
.Sp
You have to enable verify mode (\f(CW\*(C`verify => 1\*(C'\fR) for this parameter to
have any effect.
.ie n .IP "ca_path => $path" 4
.el .IP "ca_path => \f(CW$path\fR" 4
.IX Item "ca_path => $path"
If this parameter is specified and non-empty, it will be
the path to a directory with hashed \s-1CA\s0 certificate files in
\&\s-1PEM\s0 format. When the ca certificate is being verified, the
certificate will be hashed and looked up in that directory (see
<http://www.openssl.org/docs/ssl/SSL_CTX_load_verify_locations.html> for
details)
.Sp
The certificates specified via \f(CW\*(C`ca_file\*(C'\fR take precedence over the ones
found in \f(CW\*(C`ca_path\*(C'\fR.
.Sp
You have to enable verify mode (\f(CW\*(C`verify => 1\*(C'\fR) for this parameter to
have any effect.
.ie n .IP "ca_cert => $string" 4
.el .IP "ca_cert => \f(CW$string\fR" 4
.IX Item "ca_cert => $string"
In addition or instead of using \f(CW\*(C`ca_file\*(C'\fR and/or \f(CW\*(C`ca_path\*(C'\fR, you can
also use \f(CW\*(C`ca_cert\*(C'\fR to directly specify the \s-1CA\s0 certificates (there can be
multiple) in \s-1PEM\s0 format, in a string.
.ie n .IP "check_crl => $enable" 4
.el .IP "check_crl => \f(CW$enable\fR" 4
.IX Item "check_crl => $enable"
Enable or disable certificate revocation list checking. If enabled, then
peer certificates will be checked against a list of revoked certificates
issued by the \s-1CA\s0. The revocation lists will be expected in the \f(CW\*(C`ca_path\*(C'\fR
directory.
.Sp
certificate verification will fail if this is enabled but no revocation
list was found.
.Sp
This requires OpenSSL >= 0.9.7b. Check the OpenSSL documentation for more
details.
.ie n .IP "key_file => $path" 4
.el .IP "key_file => \f(CW$path\fR" 4
.IX Item "key_file => $path"
Path to the local private key file in \s-1PEM\s0 format (might be a combined
certificate/private key file).
.Sp
The local certificate is used to authenticate against the peer \- servers
mandatorily need a certificate and key, clients can use a certificate and
key optionally to authenticate, e.g. for log-in purposes.
.Sp
The key in the file should look similar this:
.Sp
.Vb 4
\&   \-\-\-\-\-BEGIN RSA PRIVATE KEY\-\-\-\-\-
\&   ...header data
\&   ... (key data in base64 encoding) ...
\&   \-\-\-\-\-END RSA PRIVATE KEY\-\-\-\-\-
.Ve
.ie n .IP "key => $string" 4
.el .IP "key => \f(CW$string\fR" 4
.IX Item "key => $string"
The private key string in \s-1PEM\s0 format (see \f(CW\*(C`key_file\*(C'\fR, only one of
\&\f(CW\*(C`key_file\*(C'\fR or \f(CW\*(C`key\*(C'\fR can be specified).
.Sp
The idea behind being able to specify a string is to avoid blocking in
I/O. Unfortunately, Net::SSLeay fails to implement any interface to the
needed OpenSSL functionality, this is currently implemented by writing to
a temporary file.
.ie n .IP "cert_file => $path" 4
.el .IP "cert_file => \f(CW$path\fR" 4
.IX Item "cert_file => $path"
The path to the local certificate file in \s-1PEM\s0 format (might be a combined
certificate/private key file, including chained certificates).
.Sp
The local certificate (and key) are used to authenticate against the
peer \- servers mandatorily need a certificate and key, clients can use
certificate and key optionally to authenticate, e.g. for log-in purposes.
.Sp
The certificate in the file should look like this:
.Sp
.Vb 3
\&   \-\-\-\-\-BEGIN CERTIFICATE\-\-\-\-\-
\&   ... (certificate in base64 encoding) ...
\&   \-\-\-\-\-END CERTIFICATE\-\-\-\-\-
.Ve
.Sp
If the certificate file or string contain both the certificate and
private key, then there is no need to specify a separate \f(CW\*(C`key_file\*(C'\fR or
\&\f(CW\*(C`key\*(C'\fR.
.Sp
Additional signing certifiates to send to the peer (in SSLv3 and newer)
can be specified by appending them to the certificate proper: the order
must be from issuer certificate over any intermediate \s-1CA\s0 certificates to
the root \s-1CA\s0.
.Sp
So the recommended ordering for a combined key/cert/chain file, specified
via \f(CW\*(C`cert_file\*(C'\fR or \f(CW\*(C`cert\*(C'\fR looks like this:
.Sp
.Vb 5
\&  certificate private key
\&  client/server certificate
\&  ca 1, signing client/server certficate
\&  ca 2, signing ca 1
\&  ...
.Ve
.ie n .IP "cert => $string" 4
.el .IP "cert => \f(CW$string\fR" 4
.IX Item "cert => $string"
The local certificate in \s-1PEM\s0 format (might be a combined
certificate/private key file). See \f(CW\*(C`cert_file\*(C'\fR.
.Sp
The idea behind being able to specify a string is to avoid blocking in
I/O. Unfortunately, Net::SSLeay fails to implement any interface to the
needed OpenSSL functionality, this is currently implemented by writing to
a temporary file.
.ie n .IP "cert_password => $string | $callback\->($tls)" 4
.el .IP "cert_password => \f(CW$string\fR | \f(CW$callback\fR\->($tls)" 4
.IX Item "cert_password => $string | $callback->($tls)"
The certificate password \- if the certificate is password-protected, then
you can specify its password here.
.Sp
Instead of providing a password directly (which is not so recommended),
you can also provide a password-query callback. The callback will be
called whenever a password is required to decode a local certificate, and
is supposed to return the password.
.ie n .IP "dh_file => $path" 4
.el .IP "dh_file => \f(CW$path\fR" 4
.IX Item "dh_file => $path"
Path to a file containing Diffie-Hellman parameters in \s-1PEM\s0 format, for
use in servers. See also \f(CW\*(C`dh\*(C'\fR on how to specify them directly, or use a
pre-generated set.
.Sp
Diffie-Hellman key exchange generates temporary encryption keys that
are not transferred over the connection, which means that even if the
certificate key(s) are made public at a later time and a full dump of the
connection exists, the key still cannot be deduced.
.Sp
These ciphers are only available with SSLv3 and later (which is the
default with AnyEvent::TLS), and are only used in server/accept
mode. Anonymous \s-1DH\s0 protocols are usually disabled by default, and usually
not even compiled into the underlying library, as they provide no direct
protection against man-in-the-middle attacks. The same is true for the
common practise of self-signed certificates that you have to accept first,
of course.
.ie n .IP "dh => $string" 4
.el .IP "dh => \f(CW$string\fR" 4
.IX Item "dh => $string"
Specify the Diffie-Hellman parameters in \s-1PEM\s0 format directly as a string
(see \f(CW\*(C`dh_file\*(C'\fR), the default is \f(CW\*(C`schmorp1539\*(C'\fR unless \f(CW\*(C`dh_file\*(C'\fR was
specified.
.Sp
AnyEvent::TLS supports supports a number of precomputed \s-1DH\s0 parameters,
since computing them is expensive. They are:
.Sp
.Vb 2
\&   # from "Assigned Number for SKIP Protocols"
\&   skip512, skip1024, skip2048, skip4096
\&
\&   # from schmorp
\&   schmorp1024, schmorp1539, schmorp2048, schmorp4096, schmorp8192
.Ve
.Sp
The default was chosen as a trade-off between security and speed, and
should be secure for a few years. It is said that 2048 bit \s-1DH\s0 parameters
are safe till 2030, and \s-1DH\s0 parameters shorter than 900 bits are totally
insecure.
.Sp
To disable \s-1DH\s0 protocols completely, specify \f(CW\*(C`undef\*(C'\fR as \f(CW\*(C`dh\*(C'\fR parameter.
.ie n .IP "dh_single_use => $enable" 4
.el .IP "dh_single_use => \f(CW$enable\fR" 4
.IX Item "dh_single_use => $enable"
Enables or disables \*(L"use only once\*(R" mode when using Diffie-Hellman key
exchange. When enabled (default), each time a new key is exchanged a new
Diffie-Hellman key is generated, which improves security as each key is
only used once. When disabled, the key will be created as soon as the
AnyEvent::TLS object is created and will be reused.
.Sp
All the \s-1DH\s0 parameters supplied with AnyEvent::TLS should be safe with
\&\f(CW\*(C`dh_single_use\*(C'\fR switched off, but \s-1YMMV\s0.
.ie n .IP "cipher_list => $string" 4
.el .IP "cipher_list => \f(CW$string\fR" 4
.IX Item "cipher_list => $string"
The list of ciphers to use, as a string (example:
\&\f(CW\*(C`AES:ALL:!aNULL:!eNULL:+RC4:@STRENGTH\*(C'\fR). The format
of this string and its default value is documented at
<http://www.openssl.org/docs/apps/ciphers.html#CIPHER_STRINGS>.
.ie n .IP "session_ticket => $enable" 4
.el .IP "session_ticket => \f(CW$enable\fR" 4
.IX Item "session_ticket => $enable"
Enables or disables \s-1RC5077\s0 support (Session Resumption without Server-Side
State). The default is disabled for clients, as many (buggy) \s-1TLS/SSL\s0
servers choke on it, but enabled for servers.
.Sp
When enabled and supported by the server, a session ticket will be
provided to the client, which allows fast resuming of connections.
.ie n .IP "prepare => $coderef\->($tls)" 4
.el .IP "prepare => \f(CW$coderef\fR\->($tls)" 4
.IX Item "prepare => $coderef->($tls)"
If this argument is present, then it will be called with the new
AnyEvent::TLS object after any other initialisation has bee done, in case
you wish to fine-tune something...
.RE
.RS 4
.RE
.ie n .IP "$tls = new_from_ssleay AnyEvent::TLS $ctx" 4
.el .IP "\f(CW$tls\fR = new_from_ssleay AnyEvent::TLS \f(CW$ctx\fR" 4
.IX Item "$tls = new_from_ssleay AnyEvent::TLS $ctx"
This constructor takes an existing Net::SSLeay \s-1SSL_CTX\s0 object
(which is just an integer) and converts it into an \f(CW\*(C`AnyEvent::TLS\*(C'\fR
object. This only works because AnyEvent::TLS is currently implemented
using Net::SSLeay. As this is such a horrible perl module and OpenSSL has
such an annoying license, this might change in the future, in which case
this method might vanish.
.ie n .IP "$ctx = $tls\->ctx" 4
.el .IP "\f(CW$ctx\fR = \f(CW$tls\fR\->ctx" 4
.IX Item "$ctx = $tls->ctx"
Returns the actual Net::SSLeay::CTX object (just an integer).
.IP "AnyEvent::TLS::init" 4
.IX Item "AnyEvent::TLS::init"
AnyEvent::TLS does on-demand initialisation, and normally there is no need to call an initialise
function.
.Sp
As initialisation might take some time (to read e.g. \f(CW\*(C`/dev/urandom\*(C'\fR), this
could be annoying in some highly interactive programs. In that case, you can
call \f(CW\*(C`AnyEvent::TLS::init\*(C'\fR to make sure there will be no costly initialisation
later. It is harmless to call \f(CW\*(C`AnyEvent::TLS::init\*(C'\fR multiple times.
.ie n .IP "$certname = AnyEvent::TLS::certname $x509" 4
.el .IP "\f(CW$certname\fR = AnyEvent::TLS::certname \f(CW$x509\fR" 4
.IX Item "$certname = AnyEvent::TLS::certname $x509"
Utility function that returns a user-readable string identifying the X509
certificate object.
.SH "SSL/TLS QUICK FACTS"
.IX Header "SSL/TLS QUICK FACTS"
Here are some quick facts about \s-1TLS/SSL\s0 that might help you:
.IP "\(bu" 4
A certificate is the public key part, a key is the private key part.
.Sp
While not strictly true, certificates are the things you can hand around
publicly as a kind of identity, while keys should really be kept private,
as proving that you have the private key is usually interpreted as being
the entity behind the certificate.
.IP "\(bu" 4
A certificate is signed by a \s-1CA\s0 (Certificate Authority).
.Sp
By signing, the \s-1CA\s0 basically claims that the certificate it signs
really belongs to the identity named in it, verified according to the
\&\s-1CA\s0 policies. For e.g. \s-1HTTPS\s0, the \s-1CA\s0 usually makes some checks that the
hostname mentioned in the certificate really belongs to the company/person
that requested the signing and owns the domain.
.IP "\(bu" 4
CAs can be certified by other CAs.
.Sp
Or by themselves \- a certificate that is signed by a \s-1CA\s0 that is itself
is called a self-signed certificate, a trust chain of length zero. When
you find a certificate signed by another \s-1CA\s0, which is in turn signed by
another \s-1CA\s0 you trust, you have a trust chain of depth two.
.IP "\(bu" 4
\&\*(L"Trusting\*(R" a \s-1CA\s0 means trusting all certificates it has signed.
.Sp
If you \*(L"trust\*(R" a \s-1CA\s0 certificate, then all certificates signed by it are
automatically considered trusted as well.
.IP "\(bu" 4
A successfully verified certificate means that you can be
reasonably sure that whoever you are talking with really is who he claims
he is.
.Sp
By verifying certificates against a number of CAs that you trust (meaning
it is signed directly or indirectly by such a \s-1CA\s0), you can find out that
the other side really is whoever he claims, according to the \s-1CA\s0 policies,
and your belief in the integrity of the \s-1CA\s0.
.IP "\(bu" 4
Verifying the certificate signature is not everything.
.Sp
Even when the certificate is correct, it might belong to somebody else: if
www.attacker.com can make your computer believe that it is really called
www.mybank.com (by making your \s-1DNS\s0 server believe this for example),
then it could send you the certificate for www.attacker.com that your
software trusts because it is signed by a \s-1CA\s0 you trust, and intercept
all your traffic that you think goes to www.mybank.com. This works
because your software sees that the certificate is correctly signed (for
www.attacker.com) and you think you are talking to your bank.
.Sp
To thwart this attack vector, peername verification should be used, which
basically checks that the certificate (for www.attacker.com) really
belongs to the host you are trying to talk to (www.mybank.com), which in
this example is not the case, as www.attacker.com (from the certificate)
doesn't match www.mybank.com (the hostname used to create the connection).
.Sp
So peername verification is almost as important as checking the \s-1CA\s0
signing. Unfortunately, every protocol implements this differently, if at
all...
.IP "\(bu" 4
Switching off verification is sometimes reasonable.
.Sp
You can switch off verification. You still get an encrypted connection
that is protected against eavesdropping and injection \- you just lose
protection against man in the middle attacks, i.e. somebody else with
enough abilities to to intercept all traffic can masquerade herself as the
other side.
.Sp
For many applications, switching off verification is entirely
reasonable. Downloading random stuff from websites using \s-1HTTPS\s0 for no
reason is such an application. Talking to your bank and entering TANs is
not such an application.
.IP "\(bu" 4
A \s-1SSL/TLS\s0 server always needs a certificate/key pair to operate,
for clients this is optional.
.Sp
Apart from (usually disabled) anonymous cipher suites, a server always
needs a certificate/key pair to operate.
.Sp
Clients almost never use certificates, but if they do, they can be used
to authenticate the client, just as server certificates can be used to
authenticate the server.
.IP "\(bu" 4
\&\s-1SSL\s0 version 2 is very insecure.
.Sp
\&\s-1SSL\s0 version 2 is old and not only has it some security issues, SSLv2\-only
implementations are usually buggy, too, due to their age.
.IP "\(bu" 4
Sometimes, even losing your \*(L"private\*(R" key might not expose all your
data.
.Sp
With Diffie-Hellman ephemeral key exchange, you can lose the \s-1DH\s0 parameters
(the \*(L"keys\*(R"), but all your connections are still protected. Diffie-Hellman
needs special set-up (done by default by AnyEvent::TLS).
.SH "SECURITY CONSIDERATIONS"
.IX Header "SECURITY CONSIDERATIONS"
When you use any of the options that pass in keys or certificates
as strings (e.g. \f(CW\*(C`ca_cert\*(C'\fR), then, due to serious shortcomings in
Net::SSLeay, this module creates a temporary file to store the string \-
see File::Temp and possibly its \f(CW\*(C`safe_level\*(C'\fR setting for more details
on what to watch out for.
.SH "BUGS"
.IX Header "BUGS"
To to the abysmal code quality of Net::SSLeay, this module will leak small
amounts of memory per \s-1TLS\s0 connection (currently at least one perl scalar).
.SH "AUTHORS"
.IX Header "AUTHORS"
Marc Lehmann <schmorp@schmorp.de>.
.PP
Some of the \s-1API\s0, documentation and implementation (verify_hostname),
and a lot of ideas/workarounds/knowledge have been taken from the
IO::Socket::SSL module. Care has been taken to keep the \s-1API\s0 similar to
that and other modules, to the extent possible while providing a sensible
\&\s-1API\s0 for AnyEvent.
